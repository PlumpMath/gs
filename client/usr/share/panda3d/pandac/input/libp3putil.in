1448427287
2 3
10 libp3putil 4 xqRv 12 panda3d.core 
880
893 5 clear 0 4 1775 56 PointerToBase< ReferenceCountedVector< ushort > >::clear 0 1 13 0
75
inline void PointerToBase< ReferenceCountedVector< ushort > >::clear(void);

894 6 output 0 4 1775 57 PointerToBase< ReferenceCountedVector< ushort > >::output 0 1 14 0
83
void PointerToBase< ReferenceCountedVector< ushort > >::output(ostream &out) const;

895 19 ~PointerToArrayBase 0 4 1774 49 PointerToArrayBase< ushort >::~PointerToArrayBase 0 0 0
63
inline PointerToArrayBase< ushort >::~PointerToArrayBase(void);

896 19 ConstPointerToArray 0 4 1773 50 ConstPointerToArray< ushort >::ConstPointerToArray 0 3 1 2 3 0
284
inline ConstPointerToArray< ushort >::ConstPointerToArray(PointerToArray< ushort > const &copy);
inline ConstPointerToArray< ushort >::ConstPointerToArray(ConstPointerToArray< ushort > const &copy);
ConstPointerToArray< ushort >::ConstPointerToArray(PyObject *self, PyObject *source);

897 4 size 0 4 1773 35 ConstPointerToArray< ushort >::size 0 1 4 0
62
inline size_t ConstPointerToArray< ushort >::size(void) const;

898 11 get_element 0 4 1773 42 ConstPointerToArray< ushort >::get_element 0 1 5 0
80
inline ushort const &ConstPointerToArray< ushort >::get_element(size_t n) const;

899 11 __getitem__ 0 4 1773 42 ConstPointerToArray< ushort >::__getitem__ 0 1 6 0
73
ushort const &ConstPointerToArray< ushort >::__getitem__(size_t n) const;

900 8 get_data 0 4 1773 39 ConstPointerToArray< ushort >::get_data 0 1 7 0
66
inline string ConstPointerToArray< ushort >::get_data(void) const;

901 11 get_subdata 0 4 1773 42 ConstPointerToArray< ushort >::get_subdata 0 1 8 0
87
inline string ConstPointerToArray< ushort >::get_subdata(size_t n, size_t count) const;

902 13 get_ref_count 0 4 1773 44 ConstPointerToArray< ushort >::get_ref_count 0 1 9 0
68
inline int ConstPointerToArray< ushort >::get_ref_count(void) const;

903 18 get_node_ref_count 0 4 1773 49 ConstPointerToArray< ushort >::get_node_ref_count 0 1 10 0
73
inline int ConstPointerToArray< ushort >::get_node_ref_count(void) const;

904 13 __getbuffer__ 0 4 1773 44 ConstPointerToArray< ushort >::__getbuffer__ 0 1 11 0
99
int ConstPointerToArray< ushort >::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

905 17 __releasebuffer__ 0 4 1773 48 ConstPointerToArray< ushort >::__releasebuffer__ 0 1 12 0
93
void ConstPointerToArray< ushort >::__releasebuffer__(PyObject *self, Py_buffer *view) const;

906 20 ~ConstPointerToArray 0 4 1773 51 ConstPointerToArray< ushort >::~ConstPointerToArray 0 0 0
58
ConstPointerToArray< ushort >::~ConstPointerToArray(void);

907 14 PointerToArray 0 4 1777 40 PointerToArray< ushort >::PointerToArray 0 3 15 16 17 0
277
inline PointerToArray< ushort >::PointerToArray(TypeHandle type_handle = (_get_type_handle((ushort const *)(0))));
inline PointerToArray< ushort >::PointerToArray(PointerToArray< ushort > const &copy);
PointerToArray< ushort >::PointerToArray(PyObject *self, PyObject *source);

908 11 empty_array 0 4 1777 37 PointerToArray< ushort >::empty_array 0 1 18 0
153
static inline PointerToArray< ushort > PointerToArray< ushort >::empty_array(size_t n, TypeHandle type_handle = (_get_type_handle((ushort const *)(0))));

909 4 size 0 4 1777 30 PointerToArray< ushort >::size 0 1 19 0
57
inline size_t PointerToArray< ushort >::size(void) const;

910 9 push_back 0 4 1777 35 PointerToArray< ushort >::push_back 0 1 20 0
65
inline void PointerToArray< ushort >::push_back(ushort const &x);

911 8 pop_back 0 4 1777 34 PointerToArray< ushort >::pop_back 0 1 21 0
53
inline void PointerToArray< ushort >::pop_back(void);

912 11 get_element 0 4 1777 37 PointerToArray< ushort >::get_element 0 1 22 0
75
inline ushort const &PointerToArray< ushort >::get_element(size_t n) const;

913 11 set_element 0 4 1777 37 PointerToArray< ushort >::set_element 0 1 23 0
81
inline void PointerToArray< ushort >::set_element(size_t n, ushort const &value);

914 11 __getitem__ 0 4 1777 37 PointerToArray< ushort >::__getitem__ 0 1 24 0
68
ushort const &PointerToArray< ushort >::__getitem__(size_t n) const;

915 11 __setitem__ 0 4 1777 37 PointerToArray< ushort >::__setitem__ 0 1 25 0
74
void PointerToArray< ushort >::__setitem__(size_t n, ushort const &value);

916 8 get_data 0 4 1777 34 PointerToArray< ushort >::get_data 0 1 26 0
61
inline string PointerToArray< ushort >::get_data(void) const;

917 8 set_data 0 4 1777 34 PointerToArray< ushort >::set_data 0 1 27 0
67
inline void PointerToArray< ushort >::set_data(string const &data);

918 11 get_subdata 0 4 1777 37 PointerToArray< ushort >::get_subdata 0 1 28 0
82
inline string PointerToArray< ushort >::get_subdata(size_t n, size_t count) const;

919 11 set_subdata 0 4 1777 37 PointerToArray< ushort >::set_subdata 0 1 29 0
94
inline void PointerToArray< ushort >::set_subdata(size_t n, size_t count, string const &data);

920 13 get_ref_count 0 4 1777 39 PointerToArray< ushort >::get_ref_count 0 1 30 0
63
inline int PointerToArray< ushort >::get_ref_count(void) const;

921 18 get_node_ref_count 0 4 1777 44 PointerToArray< ushort >::get_node_ref_count 0 1 31 0
68
inline int PointerToArray< ushort >::get_node_ref_count(void) const;

922 13 __getbuffer__ 0 4 1777 39 PointerToArray< ushort >::__getbuffer__ 0 1 32 0
88
int PointerToArray< ushort >::__getbuffer__(PyObject *self, Py_buffer *view, int flags);

923 17 __releasebuffer__ 0 4 1777 43 PointerToArray< ushort >::__releasebuffer__ 0 1 33 0
88
void PointerToArray< ushort >::__releasebuffer__(PyObject *self, Py_buffer *view) const;

924 15 ~PointerToArray 0 4 1777 41 PointerToArray< ushort >::~PointerToArray 0 0 0
48
PointerToArray< ushort >::~PointerToArray(void);

925 14 ~AnimInterface 0 6 1779 29 AnimInterface::~AnimInterface 0 0 233
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::Destructor
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
44
virtual AnimInterface::~AnimInterface(void);

926 4 play 0 4 1779 19 AnimInterface::play 0 2 34 35 1032
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::play
//       Access: Published
//  Description: Runs the entire animation from beginning to end and
//               stops.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::play
//       Access: Published
//  Description: Runs the animation from the frame "from" to and
//               including the frame "to", at which point the
//               animation is stopped.  Both "from" and "to" frame
//               numbers may be outside the range (0,
//               get_num_frames()) and the animation will follow the
//               range correctly, reporting numbers modulo
//               get_num_frames().  For instance, play(0,
//               get_num_frames() * 2) will play the animation twice
//               and then stop.
////////////////////////////////////////////////////////////////////
95
inline void AnimInterface::play(void);
inline void AnimInterface::play(double from, double to);

927 4 loop 0 4 1779 19 AnimInterface::loop 0 2 36 37 898
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::loop
//       Access: Published
//  Description: Starts the entire animation looping.  If restart is
//               true, the animation is restarted from the beginning;
//               otherwise, it continues from the current frame.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::loop
//       Access: Published
//  Description: Loops the animation from the frame "from" to and
//               including the frame "to", indefinitely.  If restart
//               is true, the animation is restarted from the
//               beginning; otherwise, it continues from the current
//               frame.
////////////////////////////////////////////////////////////////////
117
inline void AnimInterface::loop(bool restart);
inline void AnimInterface::loop(bool restart, double from, double to);

928 8 pingpong 0 4 1779 23 AnimInterface::pingpong 0 2 38 39 886
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::pingpong
//       Access: Published
//  Description: Starts the entire animation bouncing back and forth
//               between its first frame and last frame.  If restart
//               is true, the animation is restarted from the
//               beginning; otherwise, it continues from the current
//               frame.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::pingpong
//       Access: Published
//  Description: Loops the animation from the frame "from" to and
//               including the frame "to", and then back in the
//               opposite direction, indefinitely.
////////////////////////////////////////////////////////////////////
125
inline void AnimInterface::pingpong(bool restart);
inline void AnimInterface::pingpong(bool restart, double from, double to);

929 4 stop 0 4 1779 19 AnimInterface::stop 0 1 40 369
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::stop
//       Access: Published
//  Description: Stops a currently playing or looping animation right
//               where it is.  The animation remains posed at the
//               current frame.
////////////////////////////////////////////////////////////////////
38
inline void AnimInterface::stop(void);

930 4 pose 0 4 1779 19 AnimInterface::pose 0 1 41 297
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::pose
//       Access: Published
//  Description: Sets the animation to the indicated frame and holds
//               it there.
////////////////////////////////////////////////////////////////////
46
inline void AnimInterface::pose(double frame);

931 13 set_play_rate 0 4 1779 28 AnimInterface::set_play_rate 0 1 42 519
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::set_play_rate
//       Access: Published
//  Description: Changes the rate at which the animation plays.  1.0
//               is the normal speed, 2.0 is twice normal speed, and
//               0.5 is half normal speed.  0.0 is legal to pause the
//               animation, and a negative value will play the
//               animation backwards.
////////////////////////////////////////////////////////////////////
59
inline void AnimInterface::set_play_rate(double play_rate);

932 13 get_play_rate 0 4 1779 28 AnimInterface::get_play_rate 0 1 43 313
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_play_rate
//       Access: Published
//  Description: Returns the rate at which the animation plays.  See
//               set_play_rate().
////////////////////////////////////////////////////////////////////
55
inline double AnimInterface::get_play_rate(void) const;

933 14 get_frame_rate 0 4 1779 29 AnimInterface::get_frame_rate 0 1 44 514
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_frame_rate
//       Access: Published
//  Description: Returns the native frame rate of the animation.  This
//               is the number of frames per second that will elapse
//               when the play_rate is set to 1.0.  It is a fixed
//               property of the animation and may not be adjusted by
//               the user.
////////////////////////////////////////////////////////////////////
56
inline double AnimInterface::get_frame_rate(void) const;

934 14 get_num_frames 0 6 1779 29 AnimInterface::get_num_frames 0 1 45 581
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_num_frames
//       Access: Published, Virtual
//  Description: Returns the number of frames in the animation.  This
//               is a property of the animation and may not be
//               directly adjusted by the user (although it may change
//               without warning with certain kinds of animations,
//               since this is a virtual method that may be
//               overridden).
////////////////////////////////////////////////////////////////////
54
virtual int AnimInterface::get_num_frames(void) const;

935 9 get_frame 0 4 1779 24 AnimInterface::get_frame 0 1 46 359
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_frame
//       Access: Published
//  Description: Returns the current integer frame number.
//               This number will be in the range 0 <= f <
//               get_num_frames().
////////////////////////////////////////////////////////////////////
48
inline int AnimInterface::get_frame(void) const;

936 14 get_next_frame 0 4 1779 29 AnimInterface::get_next_frame 0 1 47 638
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_next_frame
//       Access: Published
//  Description: Returns the current integer frame number + 1,
//               constrained to the range 0 <= f < get_num_frames().
//
//               If the play mode is PM_play, this will clamp to the
//               same value as get_frame() at the end of the
//               animation.  If the play mode is any other value, this
//               will wrap around to frame 0 at the end of the
//               animation.
////////////////////////////////////////////////////////////////////
53
inline int AnimInterface::get_next_frame(void) const;

937 8 get_frac 0 4 1779 23 AnimInterface::get_frac 0 1 48 598
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_frac
//       Access: Published
//  Description: Returns the fractional part of the current frame.
//               Normally, this is in the range 0.0 <= f < 1.0, but in
//               the one special case of an animation playing to its
//               end frame and stopping, it might exactly equal 1.0.
//
//               It will always be true that get_full_frame() +
//               get_frac() == get_full_fframe().
////////////////////////////////////////////////////////////////////
50
inline double AnimInterface::get_frac(void) const;

938 14 get_full_frame 0 4 1779 29 AnimInterface::get_full_frame 0 1 49 693
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_full_frame
//       Access: Published
//  Description: Returns the current integer frame number.
//
//               Unlike the value returned by get_frame(), this frame
//               number may extend beyond the range of
//               get_num_frames() if the frame range passed to play(),
//               loop(), etc. did.
//
//               Unlike the value returned by get_full_fframe(), this
//               return value will never exceed the value passed to
//               to_frame in the play() method.
////////////////////////////////////////////////////////////////////
53
inline int AnimInterface::get_full_frame(void) const;

939 15 get_full_fframe 0 4 1779 30 AnimInterface::get_full_fframe 0 1 50 841
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_full_fframe
//       Access: Published
//  Description: Returns the current floating-point frame number.
//
//               Unlike the value returned by get_frame(), this frame
//               number may extend beyond the range of
//               get_num_frames() if the frame range passed to play(),
//               loop(), etc. did.
//
//               Unlike the value returned by get_full_frame(), this
//               return value may equal (to_frame + 1.0), when the
//               animation has played to its natural end.  However, in
//               this case the return value of get_full_frame() will
//               be to_frame, not (to_frame + 1).
////////////////////////////////////////////////////////////////////
57
inline double AnimInterface::get_full_fframe(void) const;

940 10 is_playing 0 4 1779 25 AnimInterface::is_playing 0 1 51 466
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::is_playing
//       Access: Published
//  Description: Returns true if the animation is currently playing,
//               false if it is stopped (e.g. because stop() or pose()
//               was called, or because it reached the end of the
//               animation after play() was called).
////////////////////////////////////////////////////////////////////
50
inline bool AnimInterface::is_playing(void) const;

941 6 output 0 6 1779 21 AnimInterface::output 0 1 52 230
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::output
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
55
virtual void AnimInterface::output(ostream &out) const;

942 14 get_class_type 0 4 1779 29 AnimInterface::get_class_type 0 1 53 0
54
static TypeHandle AnimInterface::get_class_type(void);

943 9 UpdateSeq 0 4 1781 20 UpdateSeq::UpdateSeq 0 2 54 55 502
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::Default Constructor
//       Access: Published
//  Description: Creates an UpdateSeq in the 'initial' state.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
86
inline UpdateSeq::UpdateSeq(void);
inline UpdateSeq::UpdateSeq(UpdateSeq const &copy);

944 7 initial 0 4 1781 18 UpdateSeq::initial 0 1 56 290
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::initial (named constructor)
//       Access: Published, Static
//  Description: Returns an UpdateSeq in the 'initial' state.
////////////////////////////////////////////////////////////////////
49
static inline UpdateSeq UpdateSeq::initial(void);

945 3 old 0 4 1781 14 UpdateSeq::old 0 1 57 282
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::old (named constructor)
//       Access: Published, Static
//  Description: Returns an UpdateSeq in the 'old' state.
////////////////////////////////////////////////////////////////////
45
static inline UpdateSeq UpdateSeq::old(void);

946 5 fresh 0 4 1781 16 UpdateSeq::fresh 0 1 58 286
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::fresh (named constructor)
//       Access: Published, Static
//  Description: Returns an UpdateSeq in the 'fresh' state.
////////////////////////////////////////////////////////////////////
47
static inline UpdateSeq UpdateSeq::fresh(void);

947 10 operator = 0 4 1781 21 UpdateSeq::operator = 0 1 59 234
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::Copy Assignment operator
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
63
inline UpdateSeq &UpdateSeq::operator =(UpdateSeq const &copy);

948 5 clear 0 4 1781 16 UpdateSeq::clear 0 1 60 260
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::clear
//       Access: Published
//  Description: Resets the UpdateSeq to the 'initial' state.
////////////////////////////////////////////////////////////////////
35
inline void UpdateSeq::clear(void);

949 10 is_initial 0 4 1781 21 UpdateSeq::is_initial 0 1 61 294
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_initial
//       Access: Published
//  Description: Returns true if the UpdateSeq is in the 'initial'
//               state.
////////////////////////////////////////////////////////////////////
46
inline bool UpdateSeq::is_initial(void) const;

950 6 is_old 0 4 1781 17 UpdateSeq::is_old 0 1 62 269
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_old
//       Access: Published
//  Description: Returns true if the UpdateSeq is in the 'old' state.
////////////////////////////////////////////////////////////////////
42
inline bool UpdateSeq::is_old(void) const;

951 8 is_fresh 0 4 1781 19 UpdateSeq::is_fresh 0 1 63 290
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_fresh
//       Access: Published
//  Description: Returns true if the UpdateSeq is in the 'fresh'
//               state.
////////////////////////////////////////////////////////////////////
44
inline bool UpdateSeq::is_fresh(void) const;

952 10 is_special 0 4 1781 21 UpdateSeq::is_special 0 1 64 328
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_special
//       Access: Published
//  Description: Returns true if the UpdateSeq is in any special
//               states, i.e. 'initial', 'old', or 'fresh'.
////////////////////////////////////////////////////////////////////
46
inline bool UpdateSeq::is_special(void) const;

953 11 operator == 0 4 1781 22 UpdateSeq::operator == 0 1 65 0
65
inline bool UpdateSeq::operator ==(UpdateSeq const &other) const;

954 11 operator != 0 4 1781 22 UpdateSeq::operator != 0 1 66 0
65
inline bool UpdateSeq::operator !=(UpdateSeq const &other) const;

955 10 operator < 0 4 1781 21 UpdateSeq::operator < 0 1 67 0
64
inline bool UpdateSeq::operator <(UpdateSeq const &other) const;

956 11 operator <= 0 4 1781 22 UpdateSeq::operator <= 0 1 68 0
65
inline bool UpdateSeq::operator <=(UpdateSeq const &other) const;

957 10 operator > 0 4 1781 21 UpdateSeq::operator > 0 1 69 0
64
inline bool UpdateSeq::operator >(UpdateSeq const &other) const;

958 11 operator >= 0 4 1781 22 UpdateSeq::operator >= 0 1 70 0
65
inline bool UpdateSeq::operator >=(UpdateSeq const &other) const;

959 11 operator ++ 0 68 1781 22 UpdateSeq::operator ++ 0 1 71 0
46
inline UpdateSeq UpdateSeq::operator ++(void);

960 11 operator ++ 0 4 1781 22 UpdateSeq::operator ++ 0 1 72 0
46
inline UpdateSeq UpdateSeq::operator ++(int );

961 7 get_seq 0 4 1781 18 UpdateSeq::get_seq 0 1 73 328
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::get_seq
//       Access: Published
//  Description: Returns the internal integer value associated with
//               the UpdateSeq.  Useful for debugging only.
////////////////////////////////////////////////////////////////////
60
inline AtomicAdjust::Integer UpdateSeq::get_seq(void) const;

962 6 output 0 4 1781 17 UpdateSeq::output 0 1 74 216
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::output
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
50
inline void UpdateSeq::output(ostream &out) const;

963 10 ~UpdateSeq 0 4 1781 21 UpdateSeq::~UpdateSeq 0 0 0
28
UpdateSeq::~UpdateSeq(void);

964 17 mark_bam_modified 0 4 1782 32 TypedWritable::mark_bam_modified 0 1 75 653
////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::mark_bam_modified
//       Access: Public
//  Description: Increments the bam_modified counter, so that this
//               object will be invalidated and retransmitted on any
//               open bam streams.  This should normally not need to
//               be called by user code; it should be called
//               internally when the object has been changed in a way
//               that legitimately requires its retransmission to any
//               connected clients.
////////////////////////////////////////////////////////////////////
51
inline void TypedWritable::mark_bam_modified(void);

965 16 get_bam_modified 0 4 1782 31 TypedWritable::get_bam_modified 0 1 76 388
////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::get_bam_modified
//       Access: Public
//  Description: Returns the current bam_modified counter.  This
//               counter is normally incremented automatically
//               whenever the object is modified.
////////////////////////////////////////////////////////////////////
61
inline UpdateSeq TypedWritable::get_bam_modified(void) const;

966 10 __reduce__ 0 4 1782 25 TypedWritable::__reduce__ 0 1 77 0
58
PyObject *TypedWritable::__reduce__(PyObject *self) const;

967 18 __reduce_persist__ 0 4 1782 33 TypedWritable::__reduce_persist__ 0 1 78 0
85
PyObject *TypedWritable::__reduce_persist__(PyObject *self, PyObject *pickler) const;

968 20 encode_to_bam_stream 0 4 1782 35 TypedWritable::encode_to_bam_stream 0 2 79 80 1528
////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::encode_to_bam_stream
//       Access: Published
//  Description: Converts the TypedWritable object into a single
//               stream of data using a BamWriter, and returns that
//               data as a string string.  Returns empty string on
//               failure.
//
//               This is a convenience method particularly useful for
//               cases when you are only serializing a single object.
//               If you have many objects to process, it is more
//               efficient to use the same BamWriter to serialize all
//               of them together.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::encode_to_bam_stream
//       Access: Published
//  Description: Converts the TypedWritable object into a single
//               stream of data using a BamWriter, and stores that
//               data in the indicated string.  Returns true on
//               success, false on failure.
//
//               This is a convenience method particularly useful for
//               cases when you are only serializing a single object.
//               If you have many objects to process, it is more
//               efficient to use the same BamWriter to serialize all
//               of them together.
////////////////////////////////////////////////////////////////////
147
inline string TypedWritable::encode_to_bam_stream(void) const;
bool TypedWritable::encode_to_bam_stream(string &data, BamWriter *writer = 0) const;

969 26 decode_raw_from_bam_stream 0 4 1782 41 TypedWritable::decode_raw_from_bam_stream 0 0 1476
////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::decode_raw_from_bam_stream
//       Access: Published, Static
//  Description: Reads the string created by a previous call to
//               encode_to_bam_stream(), and extracts the single
//               object on that string.  Returns true on success,
//               false on on error.
//
//               This variant sets the TypedWritable and
//               ReferenceCount pointers separately; both are pointers
//               to the same object.  The reference count is not
//               incremented; it is the caller's responsibility to
//               manage the reference count.
//
//               Note that this method cannot be used to retrieve
//               objects that do not inherit from ReferenceCount,
//               because these objects cannot persist beyond the
//               lifetime of the BamReader that reads them.  To
//               retrieve these objects from a bam stream, you must
//               construct a BamReader directly.
//
//               If you happen to know that the particular object in
//               question inherits from TypedWritableReferenceCount or
//               PandaNode, consider calling the variant of
//               decode_from_bam_stream() defined for those methods,
//               which presents a simpler interface.
////////////////////////////////////////////////////////////////////
144
static bool TypedWritable::decode_raw_from_bam_stream(TypedWritable *&ptr, ReferenceCount *&ref_ptr, string const &data, BamReader *reader = 0);

970 14 get_class_type 0 4 1782 29 TypedWritable::get_class_type 0 1 81 0
54
static TypeHandle TypedWritable::get_class_type(void);

971 23 upcast_to_TypedWritable 0 12 1784 52 TypedWritableReferenceCount::upcast_to_TypedWritable 0 1 84 56
upcast from TypedWritableReferenceCount to TypedWritable
74
TypedWritable *TypedWritableReferenceCount::upcast_to_TypedWritable(void);

972 39 downcast_to_TypedWritableReferenceCount 0 12 1782 54 TypedWritable::downcast_to_TypedWritableReferenceCount 0 1 85 58
downcast from TypedWritable to TypedWritableReferenceCount
90
TypedWritableReferenceCount *TypedWritable::downcast_to_TypedWritableReferenceCount(void);

973 24 upcast_to_ReferenceCount 0 12 1784 53 TypedWritableReferenceCount::upcast_to_ReferenceCount 0 1 86 57
upcast from TypedWritableReferenceCount to ReferenceCount
76
ReferenceCount *TypedWritableReferenceCount::upcast_to_ReferenceCount(void);

974 39 downcast_to_TypedWritableReferenceCount 0 12 1785 55 ReferenceCount::downcast_to_TypedWritableReferenceCount 0 1 87 59
downcast from ReferenceCount to TypedWritableReferenceCount
91
TypedWritableReferenceCount *ReferenceCount::downcast_to_TypedWritableReferenceCount(void);

975 22 decode_from_bam_stream 0 4 1784 51 TypedWritableReferenceCount::decode_from_bam_stream 0 1 82 872
////////////////////////////////////////////////////////////////////
//     Function: TypedWritableReferenceCount::decode_from_bam_stream
//       Access: Published, Static
//  Description: Reads the string created by a previous call to
//               encode_to_bam_stream(), and extracts and returns the
//               single object on that string.  Returns NULL on error.
//
//               This method is intended to replace
//               decode_raw_from_bam_stream() when you know the stream
//               in question returns an object of type
//               TypedWritableReferenceCount, allowing for easier
//               reference count management.  Note that the caller is
//               still responsible for maintaining the reference count
//               on the return value.
////////////////////////////////////////////////////////////////////
143
static PointerTo< TypedWritableReferenceCount > TypedWritableReferenceCount::decode_from_bam_stream(string const &data, BamReader *reader = 0);

976 14 get_class_type 0 4 1784 43 TypedWritableReferenceCount::get_class_type 0 1 83 0
68
static TypeHandle TypedWritableReferenceCount::get_class_type(void);

977 28 ~TypedWritableReferenceCount 0 4 1784 57 TypedWritableReferenceCount::~TypedWritableReferenceCount 0 0 0
64
TypedWritableReferenceCount::~TypedWritableReferenceCount(void);

978 37 upcast_to_TypedWritableReferenceCount 0 12 1786 53 BamCacheRecord::upcast_to_TypedWritableReferenceCount 0 1 107 57
upcast from BamCacheRecord to TypedWritableReferenceCount
89
TypedWritableReferenceCount *BamCacheRecord::upcast_to_TypedWritableReferenceCount(void);

979 26 downcast_to_BamCacheRecord 0 12 1784 55 TypedWritableReferenceCount::downcast_to_BamCacheRecord 0 1 108 59
downcast from TypedWritableReferenceCount to BamCacheRecord
78
BamCacheRecord *TypedWritableReferenceCount::downcast_to_BamCacheRecord(void);

980 24 upcast_to_LinkedListNode 0 12 1786 40 BamCacheRecord::upcast_to_LinkedListNode 0 0 44
upcast from BamCacheRecord to LinkedListNode
63
LinkedListNode *BamCacheRecord::upcast_to_LinkedListNode(void);

981 26 downcast_to_BamCacheRecord 0 12 1787 42 LinkedListNode::downcast_to_BamCacheRecord 0 0 46
downcast from LinkedListNode to BamCacheRecord
65
BamCacheRecord *LinkedListNode::downcast_to_BamCacheRecord(void);

982 15 ~BamCacheRecord 0 6 1786 31 BamCacheRecord::~BamCacheRecord 0 0 235
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::Destructor
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
46
virtual BamCacheRecord::~BamCacheRecord(void);

983 9 make_copy 0 4 1786 25 BamCacheRecord::make_copy 0 1 88 438
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::make_copy
//       Access: Published
//  Description: Returns a duplicate of the BamCacheRecord.  The
//               duplicate will not have a data pointer set, even
//               though one may have been assigned to the original via
//               set_data().
////////////////////////////////////////////////////////////////////
73
inline PointerTo< BamCacheRecord > BamCacheRecord::make_copy(void) const;

984 11 operator == 0 4 1786 27 BamCacheRecord::operator == 0 1 89 0
75
inline bool BamCacheRecord::operator ==(BamCacheRecord const &other) const;

985 19 get_source_pathname 0 4 1786 35 BamCacheRecord::get_source_pathname 0 1 90 523
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_source_pathname
//       Access: Published
//  Description: Returns the full pathname to the source file that
//               originally generated this cache request.  In some
//               cases, for instance in the case of a of a multipage
//               texture like "cube_#.png", this may not not a true
//               filename on disk.
////////////////////////////////////////////////////////////////////
71
inline Filename const &BamCacheRecord::get_source_pathname(void) const;

986 18 get_cache_filename 0 4 1786 34 BamCacheRecord::get_cache_filename 0 1 91 516
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_cache_filename
//       Access: Published
//  Description: Returns the name of the cache file as hashed from the
//               source_pathname.  This will be relative to the root
//               of the cache directory, and it will not include any
//               suffixes that may be appended to resolve hash
//               conflicts.
////////////////////////////////////////////////////////////////////
70
inline Filename const &BamCacheRecord::get_cache_filename(void) const;

987 20 get_source_timestamp 0 4 1786 36 BamCacheRecord::get_source_timestamp 0 1 92 473
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_source_timestamp
//       Access: Published
//  Description: Returns the file timestamp of the original source
//               file that generated this cache record, if available.
//               In some cases the original file timestamp is not
//               available, and this will return 0.
////////////////////////////////////////////////////////////////////
63
inline time_t BamCacheRecord::get_source_timestamp(void) const;

988 17 get_recorded_time 0 4 1786 33 BamCacheRecord::get_recorded_time 0 1 93 323
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_recorded_time
//       Access: Published
//  Description: Returns the time at which this particular record was
//               recorded or updated.
////////////////////////////////////////////////////////////////////
60
inline time_t BamCacheRecord::get_recorded_time(void) const;

989 23 get_num_dependent_files 0 4 1786 39 BamCacheRecord::get_num_dependent_files 0 1 94 320
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_num_dependent_files
//       Access: Published
//  Description: Returns the number of source files that contribute to
//               the cache.
////////////////////////////////////////////////////////////////////
63
inline int BamCacheRecord::get_num_dependent_files(void) const;

990 22 get_dependent_pathname 0 4 1786 38 BamCacheRecord::get_dependent_pathname 0 1 95 335
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_dependent_pathname
//       Access: Published
//  Description: Returns the full pathname of the nth source files
//               that contributes to the cache.
////////////////////////////////////////////////////////////////////
75
inline Filename const &BamCacheRecord::get_dependent_pathname(int n) const;

991 20 dependents_unchanged 0 4 1786 36 BamCacheRecord::dependents_unchanged 0 1 96 380
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::dependents_unchanged
//       Access: Published
//  Description: Returns true if all of the dependent files are still
//               the same as when the cache was recorded, false
//               otherwise.
////////////////////////////////////////////////////////////////////
54
bool BamCacheRecord::dependents_unchanged(void) const;

992 21 clear_dependent_files 0 4 1786 37 BamCacheRecord::clear_dependent_files 0 1 97 323
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::clear_dependent_files
//       Access: Published
//  Description: Empties the list of files that contribute to the data
//               in this record.
////////////////////////////////////////////////////////////////////
49
void BamCacheRecord::clear_dependent_files(void);

993 18 add_dependent_file 0 4 1786 34 BamCacheRecord::add_dependent_file 0 1 98 509
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::add_dependent_file
//       Access: Published
//  Description: Adds the indicated file to the list of files that
//               will be loaded to generate the data in this record.
//               This should be called once for the primary source
//               file, and again for each secondary source file, if
//               any.
////////////////////////////////////////////////////////////////////
66
void BamCacheRecord::add_dependent_file(Filename const &pathname);

994 8 has_data 0 4 1786 24 BamCacheRecord::has_data 0 1 99 373
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::has_data
//       Access: Published
//  Description: Returns true if this cache record has an in-memory
//               data object associated--that is, the object stored in
//               the cache.
////////////////////////////////////////////////////////////////////
49
inline bool BamCacheRecord::has_data(void) const;

995 10 clear_data 0 4 1786 26 BamCacheRecord::clear_data 0 1 100 394
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::clear_data
//       Access: Published
//  Description: Removes the in-memory data object associated with
//               this record, if any.  This does not affect the
//               on-disk representation of the record.
////////////////////////////////////////////////////////////////////
45
inline void BamCacheRecord::clear_data(void);

996 8 get_data 0 4 1786 24 BamCacheRecord::get_data 0 1 101 383
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_data
//       Access: Published
//  Description: Returns a pointer to the data stored in the
//               record, or NULL if there is no data.  The pointer is
//               not removed from the record.
////////////////////////////////////////////////////////////////////
59
inline TypedWritable *BamCacheRecord::get_data(void) const;

997 12 extract_data 0 4 1786 28 BamCacheRecord::extract_data 0 0 737
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::extract_data
//       Access: Published
//  Description: Fills ptr and ref_ptr with the two different-typed
//               pointers to the same object, the data stored within
//               this record.  This transfers ownership of the data
//               pointer; the caller will be responsible for managing
//               the reference counts on this object subsequently.
//
//               Returns true if the record contained any data (and
//               the pointers have been filled), false if it didn't
//               (and the pointers are NULL).
////////////////////////////////////////////////////////////////////
88
inline bool BamCacheRecord::extract_data(TypedWritable *&ptr, ReferenceCount *&ref_ptr);

998 8 set_data 0 4 1786 24 BamCacheRecord::set_data 0 2 102 103 1279
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::set_data
//       Access: Published
//  Description: Stores a new data object on the record.  You should
//               pass the same pointer twice, to both parameters; this
//               allows the C++ typecasting to automatically convert
//               the pointer into both a TypedWritable and a
//               ReferenceCount pointer, so that the BamCacheRecord
//               object can reliably manage the reference counts.
//
//               You may pass 0 or NULL as the second parameter.  If
//               you do this, the BamCacheRecord will not manage the
//               object's reference count; it will be up to you to
//               ensure the object is not deleted during the lifetime
//               of the BamCacheRecord object.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::set_data
//       Access: Published
//  Description: This variant on set_data() is provided just to allow
//               Python code to pass a 0 as the second parameter.
////////////////////////////////////////////////////////////////////
151
inline void BamCacheRecord::set_data(TypedWritable *ptr, ReferenceCount *ref_ptr);
inline void BamCacheRecord::set_data(TypedWritable *ptr, int dummy);

999 6 output 0 4 1786 22 BamCacheRecord::output 0 1 104 222
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
48
void BamCacheRecord::output(ostream &out) const;

1000 5 write 0 4 1786 21 BamCacheRecord::write 0 1 105 221
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::write
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
69
void BamCacheRecord::write(ostream &out, int indent_level = 0) const;

1001 14 get_class_type 0 4 1786 30 BamCacheRecord::get_class_type 0 1 106 0
55
static TypeHandle BamCacheRecord::get_class_type(void);

1002 8 BamCache 0 4 1788 18 BamCache::BamCache 0 1 109 220
////////////////////////////////////////////////////////////////////
//     Function: BamCache::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
25
BamCache::BamCache(void);

1003 9 ~BamCache 0 4 1788 19 BamCache::~BamCache 0 0 219
////////////////////////////////////////////////////////////////////
//     Function: BamCache::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
26
BamCache::~BamCache(void);

1004 10 set_active 0 4 1788 20 BamCache::set_active 0 1 110 646
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_active
//       Access: Published
//  Description: Changes the state of the active flag.  "active" means
//               that the cache should be consulted automatically on
//               loads, "not active" means that objects should be
//               loaded directly without consulting the cache.
//
//               This represents the global flag.  Also see the
//               individual cache_models, cache_textures,
//               cache_compressed_textures flags.
////////////////////////////////////////////////////////////////////
44
inline void BamCache::set_active(bool flag);

1005 10 get_active 0 4 1788 20 BamCache::get_active 0 1 111 695
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_active
//       Access: Published
//  Description: Returns true if the BamCache is currently active,
//               false if it is not.  "active" means that the cache
//               should be consulted automatically on loads, "not
//               active" means that objects should be loaded directly
//               without consulting the cache.
//
//               This represents the global flag.  Also see the
//               individual cache_models, cache_textures,
//               cache_compressed_textures flags.
////////////////////////////////////////////////////////////////////
45
inline bool BamCache::get_active(void) const;

1006 16 set_cache_models 0 4 1788 26 BamCache::set_cache_models 0 1 112 346
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_models
//       Access: Published
//  Description: Indicates whether model files (e.g. egg files and bam
//               files) will be stored in the cache, as bam files.
////////////////////////////////////////////////////////////////////
50
inline void BamCache::set_cache_models(bool flag);

1007 16 get_cache_models 0 4 1788 26 BamCache::get_cache_models 0 1 113 414
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_models
//       Access: Published
//  Description: Returns whether model files (e.g. egg files and bam
//               files) will be stored in the cache, as bam files.
//
//               This also returns false if get_active() is false.
////////////////////////////////////////////////////////////////////
51
inline bool BamCache::get_cache_models(void) const;

1008 18 set_cache_textures 0 4 1788 28 BamCache::set_cache_textures 0 1 114 332
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_textures
//       Access: Published
//  Description: Indicates whether texture files will be stored in the
//               cache, as uncompressed txo files.
////////////////////////////////////////////////////////////////////
52
inline void BamCache::set_cache_textures(bool flag);

1009 18 get_cache_textures 0 4 1788 28 BamCache::get_cache_textures 0 1 115 418
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_textures
//       Access: Published
//  Description: Returns whether texture files (e.g. egg files and bam
//               files) will be stored in the cache, as txo files.
//
//               This also returns false if get_active() is false.
////////////////////////////////////////////////////////////////////
53
inline bool BamCache::get_cache_textures(void) const;

1010 29 set_cache_compressed_textures 0 4 1788 39 BamCache::set_cache_compressed_textures 0 1 116 1143
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_compressed_textures
//       Access: Published
//  Description: Indicates whether compressed texture files will be
//               stored in the cache, as compressed txo files.  The
//               compressed data may either be generated in-CPU, via
//               the squish library, or it may be extracted from the
//               GSG after the texture has been loaded.
//
//               This may be set in conjunction with
//               set_cache_textures(), or independently of it.  If
//               set_cache_textures() is true and this is false, all
//               textures will be cached in their uncompressed form.
//               If set_cache_textures() is false and this is true,
//               only compressed textures will be cached, and they
//               will be cached in their compressed form.  If both are
//               true, all textures will be cached, in their
//               uncompressed or compressed form appropriately.
////////////////////////////////////////////////////////////////////
63
inline void BamCache::set_cache_compressed_textures(bool flag);

1011 29 get_cache_compressed_textures 0 4 1788 39 BamCache::get_cache_compressed_textures 0 1 117 475
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_compressed_textures
//       Access: Published
//  Description: Returns whether compressed texture files will be
//               stored in the cache, as compressed txo files.  See
//               set_cache_compressed_textures().
//
//               This also returns false if get_active() is false.
////////////////////////////////////////////////////////////////////
64
inline bool BamCache::get_cache_compressed_textures(void) const;

1012 8 set_root 0 4 1788 18 BamCache::set_root 0 1 118 665
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_root
//       Access: Published
//  Description: Changes the current root pathname of the cache.  This
//               specifies where the cache files are stored on disk.
//               This should name a directory that is on a disk local
//               to the machine (not on a network-mounted disk), for
//               instance, /tmp/panda-cache or /c/panda-cache.
//
//               If the directory does not already exist, it will be
//               created as a result of this call.
////////////////////////////////////////////////////////////////////
46
void BamCache::set_root(Filename const &root);

1013 8 get_root 0 4 1788 18 BamCache::get_root 0 1 119 299
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_root
//       Access: Published
//  Description: Returns the current root pathname of the cache.  See
//               set_root().
////////////////////////////////////////////////////////////////////
47
inline Filename BamCache::get_root(void) const;

1014 14 set_flush_time 0 4 1788 24 BamCache::set_flush_time 0 1 120 316
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_flush_time
//       Access: Published
//  Description: Specifies the time in seconds between automatic
//               flushes of the cache index.
////////////////////////////////////////////////////////////////////
53
inline void BamCache::set_flush_time(int flush_time);

1015 14 get_flush_time 0 4 1788 24 BamCache::get_flush_time 0 1 121 314
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_flush_time
//       Access: Published
//  Description: Returns the time in seconds between automatic
//               flushes of the cache index.
////////////////////////////////////////////////////////////////////
48
inline int BamCache::get_flush_time(void) const;

1016 20 set_cache_max_kbytes 0 4 1788 30 BamCache::set_cache_max_kbytes 0 1 122 767
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_max_kbytes
//       Access: Published
//  Description: Specifies the maximum size, in kilobytes, which the
//               cache is allowed to grow to.  If a newly cached file
//               would exceed this size, an older file is removed from
//               the cache.
//
//               Note that in the case of multiple different processes
//               simultaneously operating on the same cache directory,
//               the actual cache size may slightly exceed this value
//               from time to time due to latency in checking between
//               the processes.
////////////////////////////////////////////////////////////////////
59
inline void BamCache::set_cache_max_kbytes(int max_kbytes);

1017 20 get_cache_max_kbytes 0 4 1788 30 BamCache::get_cache_max_kbytes 0 1 123 371
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_max_kbytes
//       Access: Published
//  Description: Returns the maximum size, in kilobytes, which the
//               cache is allowed to grow to.  See
//               set_cache_max_kbytes().
////////////////////////////////////////////////////////////////////
54
inline int BamCache::get_cache_max_kbytes(void) const;

1018 13 set_read_only 0 4 1788 23 BamCache::set_read_only 0 1 124 523
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_read_only
//       Access: Published
//  Description: Can be used to put the cache in read-only mode,
//               or take it out of read-only mode.  Note that if you
//               put it into read-write mode, and it discovers that
//               it does not have write access, it will put itself
//               right back into read-only mode.
////////////////////////////////////////////////////////////////////
45
inline void BamCache::set_read_only(bool ro);

1019 13 get_read_only 0 4 1788 23 BamCache::get_read_only 0 1 125 503
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_read_only
//       Access: Published
//  Description: Returns true if the cache is in read-only mode.
//               Normally, the cache starts in read-write mode.  It
//               can put itself into read-only mode automatically if
//               it discovers that it does not have write access to
//               the cache.
////////////////////////////////////////////////////////////////////
48
inline bool BamCache::get_read_only(void) const;

1020 6 lookup 0 4 1788 16 BamCache::lookup 0 1 126 1209
////////////////////////////////////////////////////////////////////
//     Function: BamCache::lookup
//       Access: Published
//  Description: Looks up a file in the cache.
//
//               If the file is cacheable, then regardless of whether
//               the file is found in the cache or not, this returns a
//               BamCacheRecord.  On the other hand, if the file
//               cannot be cached, returns NULL.
//
//               If record->has_data() returns true, then the file was
//               found in the cache, and you may call
//               record->extract_data() to get the object.  If
//               record->has_data() returns false, then the file was
//               not found in the cache or the cache was stale; and
//               you should reload the source file (calling
//               record->add_dependent_file() for each file loaded,
//               including the original source file), and then call
//               record->set_data() to record the resulting loaded
//               object; and finally, you should call store() to write
//               the cached record to disk.
////////////////////////////////////////////////////////////////////
109
PointerTo< BamCacheRecord > BamCache::lookup(Filename const &source_filename, string const &cache_extension);

1021 5 store 0 4 1788 15 BamCache::store 0 1 127 478
////////////////////////////////////////////////////////////////////
//     Function: BamCache::store
//       Access: Published
//  Description: Flushes a cache entry to disk.  You must have
//               retrieved the cache record via a prior call to
//               lookup(), and then stored the data via
//               record->set_data().  Returns true on success, false
//               on failure.
////////////////////////////////////////////////////////////////////
45
bool BamCache::store(BamCacheRecord *record);

1022 20 consider_flush_index 0 4 1788 30 BamCache::consider_flush_index 0 1 128 325
////////////////////////////////////////////////////////////////////
//     Function: BamCache::consider_flush_index
//       Access: Published
//  Description: Flushes the index if enough time has elapsed since
//               the index was last flushed.
////////////////////////////////////////////////////////////////////
42
void BamCache::consider_flush_index(void);

1023 11 flush_index 0 4 1788 21 BamCache::flush_index 0 1 129 258
////////////////////////////////////////////////////////////////////
//     Function: BamCache::flush_index
//       Access: Published
//  Description: Ensures the index is written to disk.
////////////////////////////////////////////////////////////////////
33
void BamCache::flush_index(void);

1024 10 list_index 0 4 1788 20 BamCache::list_index 0 1 130 272
////////////////////////////////////////////////////////////////////
//     Function: BamCache::list_index
//       Access: Published
//  Description: Writes the contents of the index to standard output.
////////////////////////////////////////////////////////////////////
68
void BamCache::list_index(ostream &out, int indent_level = 0) const;

1025 14 get_global_ptr 0 4 1788 24 BamCache::get_global_ptr 0 1 131 376
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_global_ptr
//       Access: Published, Static
//  Description: Returns a pointer to the global BamCache object,
//               which is used automatically by the ModelPool and
//               TexturePool.
////////////////////////////////////////////////////////////////////
55
static inline BamCache *BamCache::get_global_ptr(void);

1026 27 consider_flush_global_index 0 4 1788 37 BamCache::consider_flush_global_index 0 1 132 335
////////////////////////////////////////////////////////////////////
//     Function: BamCache::consider_flush_global_index
//       Access: Published, Static
//  Description: If there is a global BamCache object, calls
//               consider_flush_index() on it.
////////////////////////////////////////////////////////////////////
63
static inline void BamCache::consider_flush_global_index(void);

1027 18 flush_global_index 0 4 1788 28 BamCache::flush_global_index 0 1 133 317
////////////////////////////////////////////////////////////////////
//     Function: BamCache::flush_global_index
//       Access: Published, Static
//  Description: If there is a global BamCache object, calls
//               flush_index() on it.
////////////////////////////////////////////////////////////////////
54
static inline void BamCache::flush_global_index(void);

1028 9 ~BamEnums 0 4 1789 19 BamEnums::~BamEnums 0 0 0
26
BamEnums::~BamEnums(void);

1029 13 LoaderOptions 0 4 1793 28 LoaderOptions::LoaderOptions 0 3 134 135 136 684
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
238
LoaderOptions::LoaderOptions(int flags = (::LoaderOptions::LF_search | ::LoaderOptions::LF_report_errors));
inline LoaderOptions::LoaderOptions(int flags, int texture_flags);
inline LoaderOptions::LoaderOptions(LoaderOptions const &copy);

1030 10 operator = 0 4 1793 25 LoaderOptions::operator = 0 1 137 0
65
inline void LoaderOptions::operator =(LoaderOptions const &copy);

1031 9 set_flags 0 4 1793 24 LoaderOptions::set_flags 0 1 138 223
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_flags
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
48
inline void LoaderOptions::set_flags(int flags);

1032 9 get_flags 0 4 1793 24 LoaderOptions::get_flags 0 1 139 223
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_flags
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
48
inline int LoaderOptions::get_flags(void) const;

1033 17 set_texture_flags 0 4 1793 32 LoaderOptions::set_texture_flags 0 1 140 231
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_texture_flags
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
56
inline void LoaderOptions::set_texture_flags(int flags);

1034 17 get_texture_flags 0 4 1793 32 LoaderOptions::get_texture_flags 0 1 141 231
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_texture_flags
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
56
inline int LoaderOptions::get_texture_flags(void) const;

1035 21 set_texture_num_views 0 4 1793 36 LoaderOptions::set_texture_num_views 0 1 142 767
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_texture_num_views
//       Access: Published
//  Description: Specifies the expected number of views to load for
//               the texture.  This is ignored unless TF_multiview is
//               included in texture_flags.  This must be specified
//               when loading a 3-d multiview texture, in which case
//               it is used to differentiate z levels from separate
//               views; it may be zero in the case of 2-d textures or
//               cube maps, in which case the number of views can be
//               inferred from the number of images found on disk.
////////////////////////////////////////////////////////////////////
64
inline void LoaderOptions::set_texture_num_views(int num_views);

1036 21 get_texture_num_views 0 4 1793 36 LoaderOptions::get_texture_num_views 0 1 143 264
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_texture_num_views
//       Access: Published
//  Description: See set_texture_num_views().
////////////////////////////////////////////////////////////////////
60
inline int LoaderOptions::get_texture_num_views(void) const;

1037 22 set_auto_texture_scale 0 4 1793 37 LoaderOptions::set_auto_texture_scale 0 1 144 480
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_auto_texture_scale
//       Access: Published
//  Description: Set this flag to ATS_none, ATS_up, ATS_down, or
//               ATS_pad to control how a texture is scaled from
//               disk when it is subsequently loaded.  Set it to
//               ATS_unspecified to restore the default behavior.
////////////////////////////////////////////////////////////////////
74
inline void LoaderOptions::set_auto_texture_scale(AutoTextureScale scale);

1038 22 get_auto_texture_scale 0 4 1793 37 LoaderOptions::get_auto_texture_scale 0 1 145 266
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_auto_texture_scale
//       Access: Published
//  Description: See set_auto_texture_scale().
////////////////////////////////////////////////////////////////////
74
inline AutoTextureScale LoaderOptions::get_auto_texture_scale(void) const;

1039 6 output 0 4 1793 21 LoaderOptions::output 0 1 146 221
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
47
void LoaderOptions::output(ostream &out) const;

1040 14 ~LoaderOptions 0 4 1793 29 LoaderOptions::~LoaderOptions 0 0 0
36
LoaderOptions::~LoaderOptions(void);

1041 9 BamReader 0 4 1796 20 BamReader::BamReader 0 1 147 261
// The primary interface for a caller.

////////////////////////////////////////////////////////////////////
//     Function: BamReader::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
52
BamReader::BamReader(DatagramGenerator *source = 0);

1042 10 ~BamReader 0 4 1796 21 BamReader::~BamReader 0 0 220
////////////////////////////////////////////////////////////////////
//     Function: BamReader::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
28
BamReader::~BamReader(void);

1043 10 set_source 0 4 1796 21 BamReader::set_source 0 1 148 383
////////////////////////////////////////////////////////////////////
//     Function: BamReader::set_source
//       Access: Published
//  Description: Changes the source of future datagrams for this
//               BamReader.  This also implicitly calls init() if it
//               has not already been called.
////////////////////////////////////////////////////////////////////
54
void BamReader::set_source(DatagramGenerator *source);

1044 10 get_source 0 4 1796 21 BamReader::get_source 0 1 149 324
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_source
//       Access: Published
//  Description: Returns the current source of the BamReader as set by
//               set_source() or the constructor.
////////////////////////////////////////////////////////////////////
54
inline DatagramGenerator *BamReader::get_source(void);

1045 4 init 0 4 1796 15 BamReader::init 0 1 150 474
////////////////////////////////////////////////////////////////////
//     Function: BamReader::init
//       Access: Published
//  Description: Initializes the BamReader prior to reading any
//               objects from its source.  This includes reading the
//               Bam header.
//
//               This returns true if the BamReader successfully
//               initialized, false otherwise.
////////////////////////////////////////////////////////////////////
27
bool BamReader::init(void);

1046 12 set_aux_data 0 4 1796 23 BamReader::set_aux_data 0 1 151 1496
////////////////////////////////////////////////////////////////////
//     Function: BamReader::set_aux_data
//       Access: Published
//  Description: Associates an arbitrary block of data with the
//               indicated object (or NULL), and the indicated name.
//
//               This is intended to provide a place for temporary
//               storage for objects reading themselves from the bam
//               file.  To use it, inherit from BamReader::AuxData and
//               store whatever data you like there.  Then associate
//               your AuxData with the object as it is being read with
//               set_aux_data().  You may later set the aux data to
//               NULL to remove it; or it will automatically be
//               removed (and deleted) after finalize() is called for
//               the object in question.
//
//               If the TypedWritable pointer is NULL, the the aux
//               data is stored globally for the BamReader in general.
//               This pointer is available to any bam objects, and
//               will not be automatically removed until the BamReader
//               itself destructs.
//
//               In either case, the name is just an arbitrary
//               user-defined key.  If there is already a data pointer
//               stored for the obj/name pair, that data pointer will
//               be replaced (and deleted).
////////////////////////////////////////////////////////////////////
95
void BamReader::set_aux_data(TypedWritable *obj, string const &name, BamReader::AuxData *data);

1047 12 get_aux_data 0 4 1796 23 BamReader::get_aux_data 0 1 152 413
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_aux_data
//       Access: Published
//  Description: Returns the pointer previously associated with the
//               bam reader by a previous call to set_aux_data(), or
//               NULL if data with the indicated key has not been set.
////////////////////////////////////////////////////////////////////
90
BamReader::AuxData *BamReader::get_aux_data(TypedWritable *obj, string const &name) const;

1048 12 get_filename 0 4 1796 23 BamReader::get_filename 0 1 153 457
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_filename
//       Access: Published
//  Description: If a BAM is a file, then the BamReader should
//               contain the name of the file.  This enables the
//               reader to interpret pathnames in the BAM as relative
//               to the directory containing the BAM.
////////////////////////////////////////////////////////////////////
59
inline Filename const &BamReader::get_filename(void) const;

1049 18 get_loader_options 0 4 1796 29 BamReader::get_loader_options 0 1 154 330
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_loader_options
//       Access: Published
//  Description: Returns the LoaderOptions passed to the loader when
//               the model was requested, if any.
////////////////////////////////////////////////////////////////////
70
inline LoaderOptions const &BamReader::get_loader_options(void) const;

1050 18 set_loader_options 0 4 1796 29 BamReader::set_loader_options 0 1 155 276
////////////////////////////////////////////////////////////////////
//     Function: BamReader::set_loader_options
//       Access: Published
//  Description: Specifies the LoaderOptions for this BamReader.
////////////////////////////////////////////////////////////////////
72
inline void BamReader::set_loader_options(LoaderOptions const &options);

1051 11 read_object 0 4 1796 22 BamReader::read_object 0 1 156 2207
////////////////////////////////////////////////////////////////////
//     Function: BamReader::read_object
//       Access: Published
//  Description: Reads a single object from the Bam file.  If the
//               object type is known, a new object of the appropriate
//               type is created and returned; otherwise, NULL is
//               returned.  NULL is also returned when the end of the
//               file is reached.  is_eof() may be called to
//               differentiate between these two cases.
//
//               This may be called repeatedly to extract out all the
//               objects in the Bam file, but typically (especially
//               for scene graph files, indicated with the .bam
//               extension), only one object is retrieved directly
//               from the Bam file: the root of the scene graph.  The
//               remaining objects will all be retrieved recursively
//               by the first object.
//
//               Note that the object returned may not yet be
//               complete.  In particular, some of its pointers may
//               not be filled in; you must call resolve() to fill in
//               all the available pointers before you can safely use
//               any objects returned by read_object().
//
//               This flavor of read_object() requires the caller to
//               know what type of object it has received in order to
//               properly manage the reference counts.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: BamReader::read_object
//       Access: Published
//  Description: Reads a single object from the Bam file.  
//
//               This flavor of read_object() returns both a
//               TypedWritable and a ReferenceCount pointer to the
//               same object, so the reference count may be tracked
//               reliably, without having to know precisely what type
//               of object we have.  It returns true on success, or
//               false on failure.
////////////////////////////////////////////////////////////////////
120
TypedWritable *BamReader::read_object(void);
bool BamReader::read_object(TypedWritable *&ptr, ReferenceCount *&ref_ptr);

1052 6 is_eof 0 4 1796 17 BamReader::is_eof 0 1 157 375
////////////////////////////////////////////////////////////////////
//     Function: BamReader::is_eof
//       Access: Published
//  Description: Returns true if the reader has reached end-of-file,
//               false otherwise.  This call is only valid after a
//               call to read_object().
////////////////////////////////////////////////////////////////////
42
inline bool BamReader::is_eof(void) const;

1053 7 resolve 0 4 1796 18 BamReader::resolve 0 1 158 935
////////////////////////////////////////////////////////////////////
//     Function: BamReader::resolve
//       Access: Published
//  Description: This may be called at any time during processing of
//               the Bam file to resolve all the known pointers so
//               far.  It is usually called at the end of the
//               processing, after all objects have been read, which
//               is generally the best time to call it.
//
//               This must be called at least once after reading a
//               particular object via get_object() in order to
//               validate that object.
//
//               The return value is true if all objects have been
//               resolved, or false if some objects are still
//               outstanding (in which case you will need to call
//               resolve() again later).
////////////////////////////////////////////////////////////////////
30
bool BamReader::resolve(void);

1054 14 change_pointer 0 4 1796 25 BamReader::change_pointer 0 1 159 724
////////////////////////////////////////////////////////////////////
//     Function: BamReader::change_pointer
//       Access: Published
//  Description: Indicates that an object recently read from the bam
//               stream should be replaced with a new object.  Any
//               future occurrences of the original object in the
//               stream will henceforth return the new object instead.
//
//               The return value is true if the replacement was
//               successfully made, or false if the object was not
//               read from the stream (or if change_pointer had
//               already been called on it).
////////////////////////////////////////////////////////////////////
100
bool BamReader::change_pointer(TypedWritable const *orig_pointer, TypedWritable const *new_pointer);

1055 18 get_file_major_ver 0 4 1796 29 BamReader::get_file_major_ver 0 1 160 316
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_major_ver
//       Access: Published
//  Description: Returns the major version number of the Bam file
//               currently being read.
////////////////////////////////////////////////////////////////////
53
inline int BamReader::get_file_major_ver(void) const;

1056 18 get_file_minor_ver 0 4 1796 29 BamReader::get_file_minor_ver 0 1 161 316
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_minor_ver
//       Access: Published
//  Description: Returns the minor version number of the Bam file
//               currently being read.
////////////////////////////////////////////////////////////////////
53
inline int BamReader::get_file_minor_ver(void) const;

1057 15 get_file_endian 0 4 1796 26 BamReader::get_file_endian 0 1 162 528
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_endian
//       Access: Published
//  Description: Returns the endian preference indicated by the Bam
//               file currently being read.  This does not imply that
//               every number is stored using the indicated
//               convention, but individual objects may choose to
//               respect this flag when recording data.
////////////////////////////////////////////////////////////////////
66
inline BamEnums::BamEndian BamReader::get_file_endian(void) const;

1058 24 get_file_stdfloat_double 0 4 1796 35 BamReader::get_file_stdfloat_double 0 1 163 489
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_stdfloat_double
//       Access: Published
//  Description: Returns true if the file stores all "standard"
//               floats as 64-bit doubles, or false if they are 32-bit
//               floats.  This is determined by the compilation flags
//               of the version of Panda that generated this file.
////////////////////////////////////////////////////////////////////
60
inline bool BamReader::get_file_stdfloat_double(void) const;

1059 21 get_current_major_ver 0 4 1796 32 BamReader::get_current_major_ver 0 1 164 440
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_current_major_ver
//       Access: Published
//  Description: Returns the major version number of Bam files
//               supported by the current code base.  This must match
//               get_file_major_ver() in order to successfully read a
//               file.
////////////////////////////////////////////////////////////////////
56
inline int BamReader::get_current_major_ver(void) const;

1060 21 get_current_minor_ver 0 4 1796 32 BamReader::get_current_minor_ver 0 1 165 450
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_current_minor_ver
//       Access: Published
//  Description: Returns the minor version number of Bam files
//               supported by the current code base.  This must match
//               or exceed get_file_minor_ver() in order to
//               successfully read a file.
////////////////////////////////////////////////////////////////////
56
inline int BamReader::get_current_minor_ver(void) const;

1061 9 BamWriter 0 4 1797 20 BamWriter::BamWriter 0 1 166 221
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
47
BamWriter::BamWriter(DatagramSink *target = 0);

1062 10 ~BamWriter 0 4 1797 21 BamWriter::~BamWriter 0 0 220
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
28
BamWriter::~BamWriter(void);

1063 10 set_target 0 4 1797 21 BamWriter::set_target 0 1 167 394
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::set_target
//       Access: Published
//  Description: Changes the destination of future datagrams written
//               by the BamWriter.  This also implicitly calls init()
//               if it has not already been called.
////////////////////////////////////////////////////////////////////
49
void BamWriter::set_target(DatagramSink *target);

1064 10 get_target 0 4 1797 21 BamWriter::get_target 0 1 168 324
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_target
//       Access: Published
//  Description: Returns the current target of the BamWriter as set by
//               set_target() or the constructor.
////////////////////////////////////////////////////////////////////
49
inline DatagramSink *BamWriter::get_target(void);

1065 4 init 0 4 1797 15 BamWriter::init 0 1 169 483
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::init
//       Access: Published
//  Description: Initializes the BamWriter prior to writing any
//               objects to its output stream.  This includes writing
//               out the Bam header.
//
//               This returns true if the BamWriter successfully
//               initialized, false otherwise.
////////////////////////////////////////////////////////////////////
27
bool BamWriter::init(void);

1066 12 get_filename 0 4 1797 23 BamWriter::get_filename 0 1 170 455
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_filename
//       Access: Published
//  Description: If a BAM is a file, then the BamWriter should
//               contain the name of the file.  This enables the
//               writer to convert pathnames in the BAM to relative
//               to the directory containing the BAM.
////////////////////////////////////////////////////////////////////
59
inline Filename const &BamWriter::get_filename(void) const;

1067 12 write_object 0 4 1797 23 BamWriter::write_object 0 1 171 1153
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::write_object
//       Access: Published
//  Description: Writes a single object to the Bam file, so that the
//               BamReader::read_object() can later correctly restore
//               the object and all its pointers.
//
//               This implicitly also writes any additional objects
//               this object references (if they haven't already been
//               written), so that pointers may be fully resolved.
//
//               This may be called repeatedly to write a sequence of
//               objects to the Bam file, but typically (especially
//               for scene graph files, indicated with the .bam
//               extension), only one object is written directly from
//               the Bam file: the root of the scene graph.  The
//               remaining objects will all be written recursively by
//               the first object.
//
//               Returns true if the object is successfully written,
//               false otherwise.
////////////////////////////////////////////////////////////////////
55
bool BamWriter::write_object(TypedWritable const *obj);

1068 10 has_object 0 4 1797 21 BamWriter::has_object 0 1 172 408
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::has_object
//       Access: Published
//  Description: Returns true if the object has previously been
//               written (or at least requested to be written) to the
//               bam file, or false if we've never heard of it before.
////////////////////////////////////////////////////////////////////
59
bool BamWriter::has_object(TypedWritable const *obj) const;

1069 5 flush 0 4 1797 16 BamWriter::flush 0 1 173 307
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::flush
//       Access: Published
//  Description: Ensures that all data written thus far is manifested
//               on the output stream.
////////////////////////////////////////////////////////////////////
28
void BamWriter::flush(void);

1070 15 get_file_endian 0 4 1797 26 BamWriter::get_file_endian 0 1 174 531
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_file_endian
//       Access: Published
//  Description: Returns the endian preference indicated by the Bam
//               file currently being written.  This does not imply
//               that every number is stored using the indicated
//               convention, but individual objects may choose to
//               respect this flag when recording data.
////////////////////////////////////////////////////////////////////
66
inline BamEnums::BamEndian BamWriter::get_file_endian(void) const;

1071 24 get_file_stdfloat_double 0 4 1797 35 BamWriter::get_file_stdfloat_double 0 1 175 531
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_file_stdfloat_double
//       Access: Published
//  Description: Returns true if the file will store all "standard"
//               floats as 64-bit doubles, or false if they are 32-bit
//               floats.  This isn't runtime settable; it's based on
//               the compilation flags of the version of Panda that
//               generated this file.
////////////////////////////////////////////////////////////////////
60
inline bool BamWriter::get_file_stdfloat_double(void) const;

1072 21 get_file_texture_mode 0 4 1797 32 BamWriter::get_file_texture_mode 0 1 176 462
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_file_texture_mode
//       Access: Published
//  Description: Returns the BamTextureMode preference indicated by
//               the Bam file currently being written.  Texture
//               objects written to this Bam file will be encoded
//               according to the specified mode.
////////////////////////////////////////////////////////////////////
77
inline BamEnums::BamTextureMode BamWriter::get_file_texture_mode(void) const;

1073 21 set_file_texture_mode 0 4 1797 32 BamWriter::set_file_texture_mode 0 1 177 453
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::set_file_texture_mode
//       Access: Published
//  Description: Changes the BamTextureMode preference for
//               the Bam file currently being written.  Texture
//               objects written to this Bam file will be encoded
//               according to the specified mode.
////////////////////////////////////////////////////////////////////
89
inline void BamWriter::set_file_texture_mode(BamEnums::BamTextureMode file_texture_mode);

1074 7 BitMask 0 4 1798 33 BitMask< PN_uint16, 16 >::BitMask 0 3 178 179 180 0
191
inline BitMask< PN_uint16, 16 >::BitMask(void);
inline BitMask< PN_uint16, 16 >::BitMask(PN_uint16 init_value);
inline BitMask< PN_uint16, 16 >::BitMask(BitMask< PN_uint16, 16 > const &copy);

1075 10 operator = 0 4 1798 36 BitMask< PN_uint16, 16 >::operator = 0 1 181 0
108
inline BitMask< PN_uint16, 16 > &BitMask< PN_uint16, 16 >::operator =(BitMask< PN_uint16, 16 > const &copy);

1076 6 all_on 0 4 1798 32 BitMask< PN_uint16, 16 >::all_on 0 1 182 0
78
static inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::all_on(void);

1077 7 all_off 0 4 1798 33 BitMask< PN_uint16, 16 >::all_off 0 1 183 0
79
static inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::all_off(void);

1078 8 lower_on 0 4 1798 34 BitMask< PN_uint16, 16 >::lower_on 0 1 184 0
87
static inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::lower_on(int on_bits);

1079 3 bit 0 4 1798 29 BitMask< PN_uint16, 16 >::bit 0 1 185 0
80
static inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::bit(int index);

1080 5 range 0 4 1798 31 BitMask< PN_uint16, 16 >::range 0 1 186 0
94
static inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::range(int low_bit, int size);

1081 8 ~BitMask 0 4 1798 34 BitMask< PN_uint16, 16 >::~BitMask 0 0 0
48
inline BitMask< PN_uint16, 16 >::~BitMask(void);

1082 16 has_max_num_bits 0 4 1798 42 BitMask< PN_uint16, 16 >::has_max_num_bits 0 1 187 0
61
static bool BitMask< PN_uint16, 16 >::has_max_num_bits(void);

1083 16 get_max_num_bits 0 4 1798 42 BitMask< PN_uint16, 16 >::get_max_num_bits 0 1 188 0
60
static int BitMask< PN_uint16, 16 >::get_max_num_bits(void);

1084 12 get_num_bits 0 4 1798 38 BitMask< PN_uint16, 16 >::get_num_bits 0 1 189 0
56
static int BitMask< PN_uint16, 16 >::get_num_bits(void);

1085 7 get_bit 0 4 1798 33 BitMask< PN_uint16, 16 >::get_bit 0 1 190 0
63
inline bool BitMask< PN_uint16, 16 >::get_bit(int index) const;

1086 7 set_bit 0 4 1798 33 BitMask< PN_uint16, 16 >::set_bit 0 1 191 0
57
inline void BitMask< PN_uint16, 16 >::set_bit(int index);

1087 9 clear_bit 0 4 1798 35 BitMask< PN_uint16, 16 >::clear_bit 0 1 192 0
59
inline void BitMask< PN_uint16, 16 >::clear_bit(int index);

1088 10 set_bit_to 0 4 1798 36 BitMask< PN_uint16, 16 >::set_bit_to 0 1 193 0
72
inline void BitMask< PN_uint16, 16 >::set_bit_to(int index, bool value);

1089 7 is_zero 0 4 1798 33 BitMask< PN_uint16, 16 >::is_zero 0 1 194 0
58
inline bool BitMask< PN_uint16, 16 >::is_zero(void) const;

1090 9 is_all_on 0 4 1798 35 BitMask< PN_uint16, 16 >::is_all_on 0 1 195 0
60
inline bool BitMask< PN_uint16, 16 >::is_all_on(void) const;

1091 7 extract 0 4 1798 33 BitMask< PN_uint16, 16 >::extract 0 1 196 0
80
inline PN_uint16 BitMask< PN_uint16, 16 >::extract(int low_bit, int size) const;

1092 5 store 0 4 1798 31 BitMask< PN_uint16, 16 >::store 0 1 197 0
84
inline void BitMask< PN_uint16, 16 >::store(PN_uint16 value, int low_bit, int size);

1093 10 has_any_of 0 4 1798 36 BitMask< PN_uint16, 16 >::has_any_of 0 1 198 0
78
inline bool BitMask< PN_uint16, 16 >::has_any_of(int low_bit, int size) const;

1094 10 has_all_of 0 4 1798 36 BitMask< PN_uint16, 16 >::has_all_of 0 1 199 0
78
inline bool BitMask< PN_uint16, 16 >::has_all_of(int low_bit, int size) const;

1095 9 set_range 0 4 1798 35 BitMask< PN_uint16, 16 >::set_range 0 1 200 0
71
inline void BitMask< PN_uint16, 16 >::set_range(int low_bit, int size);

1096 11 clear_range 0 4 1798 37 BitMask< PN_uint16, 16 >::clear_range 0 1 201 0
73
inline void BitMask< PN_uint16, 16 >::clear_range(int low_bit, int size);

1097 12 set_range_to 0 4 1798 38 BitMask< PN_uint16, 16 >::set_range_to 0 1 202 0
86
inline void BitMask< PN_uint16, 16 >::set_range_to(bool value, int low_bit, int size);

1098 8 get_word 0 4 1798 34 BitMask< PN_uint16, 16 >::get_word 0 1 203 0
64
inline PN_uint16 BitMask< PN_uint16, 16 >::get_word(void) const;

1099 8 set_word 0 4 1798 34 BitMask< PN_uint16, 16 >::set_word 0 1 204 0
64
inline void BitMask< PN_uint16, 16 >::set_word(PN_uint16 value);

1100 15 get_num_on_bits 0 4 1798 41 BitMask< PN_uint16, 16 >::get_num_on_bits 0 1 205 0
65
inline int BitMask< PN_uint16, 16 >::get_num_on_bits(void) const;

1101 16 get_num_off_bits 0 4 1798 42 BitMask< PN_uint16, 16 >::get_num_off_bits 0 1 206 0
66
inline int BitMask< PN_uint16, 16 >::get_num_off_bits(void) const;

1102 17 get_lowest_on_bit 0 4 1798 43 BitMask< PN_uint16, 16 >::get_lowest_on_bit 0 1 207 0
67
inline int BitMask< PN_uint16, 16 >::get_lowest_on_bit(void) const;

1103 18 get_lowest_off_bit 0 4 1798 44 BitMask< PN_uint16, 16 >::get_lowest_off_bit 0 1 208 0
68
inline int BitMask< PN_uint16, 16 >::get_lowest_off_bit(void) const;

1104 18 get_highest_on_bit 0 4 1798 44 BitMask< PN_uint16, 16 >::get_highest_on_bit 0 1 209 0
68
inline int BitMask< PN_uint16, 16 >::get_highest_on_bit(void) const;

1105 19 get_highest_off_bit 0 4 1798 45 BitMask< PN_uint16, 16 >::get_highest_off_bit 0 1 210 0
69
inline int BitMask< PN_uint16, 16 >::get_highest_off_bit(void) const;

1106 29 get_next_higher_different_bit 0 4 1798 55 BitMask< PN_uint16, 16 >::get_next_higher_different_bit 0 1 211 0
86
inline int BitMask< PN_uint16, 16 >::get_next_higher_different_bit(int low_bit) const;

1107 15 invert_in_place 0 4 1798 41 BitMask< PN_uint16, 16 >::invert_in_place 0 1 212 0
60
inline void BitMask< PN_uint16, 16 >::invert_in_place(void);

1108 18 has_bits_in_common 0 4 1798 44 BitMask< PN_uint16, 16 >::has_bits_in_common 0 1 213 0
102
inline bool BitMask< PN_uint16, 16 >::has_bits_in_common(BitMask< PN_uint16, 16 > const &other) const;

1109 5 clear 0 4 1798 31 BitMask< PN_uint16, 16 >::clear 0 1 214 0
50
inline void BitMask< PN_uint16, 16 >::clear(void);

1110 6 output 0 4 1798 32 BitMask< PN_uint16, 16 >::output 0 1 215 0
58
void BitMask< PN_uint16, 16 >::output(ostream &out) const;

1111 13 output_binary 0 4 1798 39 BitMask< PN_uint16, 16 >::output_binary 0 1 216 0
87
void BitMask< PN_uint16, 16 >::output_binary(ostream &out, int spaces_every = 4) const;

1112 10 output_hex 0 4 1798 36 BitMask< PN_uint16, 16 >::output_hex 0 1 217 0
84
void BitMask< PN_uint16, 16 >::output_hex(ostream &out, int spaces_every = 4) const;

1113 5 write 0 4 1798 31 BitMask< PN_uint16, 16 >::write 0 1 218 0
79
void BitMask< PN_uint16, 16 >::write(ostream &out, int indent_level = 0) const;

1114 11 operator == 0 4 1798 37 BitMask< PN_uint16, 16 >::operator == 0 1 219 0
95
inline bool BitMask< PN_uint16, 16 >::operator ==(BitMask< PN_uint16, 16 > const &other) const;

1115 11 operator != 0 4 1798 37 BitMask< PN_uint16, 16 >::operator != 0 1 220 0
95
inline bool BitMask< PN_uint16, 16 >::operator !=(BitMask< PN_uint16, 16 > const &other) const;

1116 10 operator < 0 4 1798 36 BitMask< PN_uint16, 16 >::operator < 0 1 221 0
94
inline bool BitMask< PN_uint16, 16 >::operator <(BitMask< PN_uint16, 16 > const &other) const;

1117 10 compare_to 0 4 1798 36 BitMask< PN_uint16, 16 >::compare_to 0 1 222 0
93
inline int BitMask< PN_uint16, 16 >::compare_to(BitMask< PN_uint16, 16 > const &other) const;

1118 10 operator & 0 4 1798 36 BitMask< PN_uint16, 16 >::operator & 0 1 223 0
114
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::operator &(BitMask< PN_uint16, 16 > const &other) const;

1119 10 operator | 0 4 1798 36 BitMask< PN_uint16, 16 >::operator | 0 1 224 0
114
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::operator |(BitMask< PN_uint16, 16 > const &other) const;

1120 10 operator ^ 0 4 1798 36 BitMask< PN_uint16, 16 >::operator ^ 0 1 225 0
114
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::operator ^(BitMask< PN_uint16, 16 > const &other) const;

1121 10 operator ~ 0 68 1798 36 BitMask< PN_uint16, 16 >::operator ~ 0 1 226 0
81
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::operator ~(void) const;

1122 11 operator << 0 4 1798 37 BitMask< PN_uint16, 16 >::operator << 0 1 227 0
87
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::operator <<(int shift) const;

1123 11 operator >> 0 4 1798 37 BitMask< PN_uint16, 16 >::operator >> 0 1 228 0
87
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::operator >>(int shift) const;

1124 11 operator &= 0 4 1798 37 BitMask< PN_uint16, 16 >::operator &= 0 1 229 0
89
inline void BitMask< PN_uint16, 16 >::operator &=(BitMask< PN_uint16, 16 > const &other);

1125 11 operator |= 0 4 1798 37 BitMask< PN_uint16, 16 >::operator |= 0 1 230 0
89
inline void BitMask< PN_uint16, 16 >::operator |=(BitMask< PN_uint16, 16 > const &other);

1126 11 operator ^= 0 4 1798 37 BitMask< PN_uint16, 16 >::operator ^= 0 1 231 0
89
inline void BitMask< PN_uint16, 16 >::operator ^=(BitMask< PN_uint16, 16 > const &other);

1127 12 operator <<= 0 4 1798 38 BitMask< PN_uint16, 16 >::operator <<= 0 1 232 0
62
inline void BitMask< PN_uint16, 16 >::operator <<=(int shift);

1128 12 operator >>= 0 4 1798 38 BitMask< PN_uint16, 16 >::operator >>= 0 1 233 0
62
inline void BitMask< PN_uint16, 16 >::operator >>=(int shift);

1129 19 flood_down_in_place 0 4 1798 45 BitMask< PN_uint16, 16 >::flood_down_in_place 0 1 234 0
64
inline void BitMask< PN_uint16, 16 >::flood_down_in_place(void);

1130 17 flood_up_in_place 0 4 1798 43 BitMask< PN_uint16, 16 >::flood_up_in_place 0 1 235 0
62
inline void BitMask< PN_uint16, 16 >::flood_up_in_place(void);

1131 15 flood_bits_down 0 4 1798 41 BitMask< PN_uint16, 16 >::flood_bits_down 0 1 236 0
86
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::flood_bits_down(void) const;

1132 13 flood_bits_up 0 4 1798 39 BitMask< PN_uint16, 16 >::flood_bits_up 0 1 237 0
84
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::flood_bits_up(void) const;

1133 21 keep_next_highest_bit 0 4 1798 47 BitMask< PN_uint16, 16 >::keep_next_highest_bit 0 3 238 239 240 0
316
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::keep_next_highest_bit(void) const;
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::keep_next_highest_bit(int index) const;
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::keep_next_highest_bit(BitMask< PN_uint16, 16 > const &other) const;

1134 20 keep_next_lowest_bit 0 4 1798 46 BitMask< PN_uint16, 16 >::keep_next_lowest_bit 0 3 241 242 243 0
313
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::keep_next_lowest_bit(void) const;
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::keep_next_lowest_bit(int index) const;
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::keep_next_lowest_bit(BitMask< PN_uint16, 16 > const &other) const;

1135 7 get_key 0 4 1798 33 BitMask< PN_uint16, 16 >::get_key 0 1 244 0
57
inline int BitMask< PN_uint16, 16 >::get_key(void) const;

1136 11 __nonzero__ 0 4 1798 37 BitMask< PN_uint16, 16 >::__nonzero__ 0 1 245 0
62
inline bool BitMask< PN_uint16, 16 >::__nonzero__(void) const;

1137 14 get_class_type 0 4 1798 40 BitMask< PN_uint16, 16 >::get_class_type 0 1 246 0
65
static TypeHandle BitMask< PN_uint16, 16 >::get_class_type(void);

1138 7 BitMask 0 4 1800 33 BitMask< PN_uint32, 32 >::BitMask 0 3 247 248 249 0
191
inline BitMask< PN_uint32, 32 >::BitMask(void);
inline BitMask< PN_uint32, 32 >::BitMask(PN_uint32 init_value);
inline BitMask< PN_uint32, 32 >::BitMask(BitMask< PN_uint32, 32 > const &copy);

1139 10 operator = 0 4 1800 36 BitMask< PN_uint32, 32 >::operator = 0 1 250 0
108
inline BitMask< PN_uint32, 32 > &BitMask< PN_uint32, 32 >::operator =(BitMask< PN_uint32, 32 > const &copy);

1140 6 all_on 0 4 1800 32 BitMask< PN_uint32, 32 >::all_on 0 1 251 0
78
static inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::all_on(void);

1141 7 all_off 0 4 1800 33 BitMask< PN_uint32, 32 >::all_off 0 1 252 0
79
static inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::all_off(void);

1142 8 lower_on 0 4 1800 34 BitMask< PN_uint32, 32 >::lower_on 0 1 253 0
87
static inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::lower_on(int on_bits);

1143 3 bit 0 4 1800 29 BitMask< PN_uint32, 32 >::bit 0 1 254 0
80
static inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::bit(int index);

1144 5 range 0 4 1800 31 BitMask< PN_uint32, 32 >::range 0 1 255 0
94
static inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::range(int low_bit, int size);

1145 8 ~BitMask 0 4 1800 34 BitMask< PN_uint32, 32 >::~BitMask 0 0 0
48
inline BitMask< PN_uint32, 32 >::~BitMask(void);

1146 16 has_max_num_bits 0 4 1800 42 BitMask< PN_uint32, 32 >::has_max_num_bits 0 1 256 0
61
static bool BitMask< PN_uint32, 32 >::has_max_num_bits(void);

1147 16 get_max_num_bits 0 4 1800 42 BitMask< PN_uint32, 32 >::get_max_num_bits 0 1 257 0
60
static int BitMask< PN_uint32, 32 >::get_max_num_bits(void);

1148 12 get_num_bits 0 4 1800 38 BitMask< PN_uint32, 32 >::get_num_bits 0 1 258 0
56
static int BitMask< PN_uint32, 32 >::get_num_bits(void);

1149 7 get_bit 0 4 1800 33 BitMask< PN_uint32, 32 >::get_bit 0 1 259 0
63
inline bool BitMask< PN_uint32, 32 >::get_bit(int index) const;

1150 7 set_bit 0 4 1800 33 BitMask< PN_uint32, 32 >::set_bit 0 1 260 0
57
inline void BitMask< PN_uint32, 32 >::set_bit(int index);

1151 9 clear_bit 0 4 1800 35 BitMask< PN_uint32, 32 >::clear_bit 0 1 261 0
59
inline void BitMask< PN_uint32, 32 >::clear_bit(int index);

1152 10 set_bit_to 0 4 1800 36 BitMask< PN_uint32, 32 >::set_bit_to 0 1 262 0
72
inline void BitMask< PN_uint32, 32 >::set_bit_to(int index, bool value);

1153 7 is_zero 0 4 1800 33 BitMask< PN_uint32, 32 >::is_zero 0 1 263 0
58
inline bool BitMask< PN_uint32, 32 >::is_zero(void) const;

1154 9 is_all_on 0 4 1800 35 BitMask< PN_uint32, 32 >::is_all_on 0 1 264 0
60
inline bool BitMask< PN_uint32, 32 >::is_all_on(void) const;

1155 7 extract 0 4 1800 33 BitMask< PN_uint32, 32 >::extract 0 1 265 0
80
inline PN_uint32 BitMask< PN_uint32, 32 >::extract(int low_bit, int size) const;

1156 5 store 0 4 1800 31 BitMask< PN_uint32, 32 >::store 0 1 266 0
84
inline void BitMask< PN_uint32, 32 >::store(PN_uint32 value, int low_bit, int size);

1157 10 has_any_of 0 4 1800 36 BitMask< PN_uint32, 32 >::has_any_of 0 1 267 0
78
inline bool BitMask< PN_uint32, 32 >::has_any_of(int low_bit, int size) const;

1158 10 has_all_of 0 4 1800 36 BitMask< PN_uint32, 32 >::has_all_of 0 1 268 0
78
inline bool BitMask< PN_uint32, 32 >::has_all_of(int low_bit, int size) const;

1159 9 set_range 0 4 1800 35 BitMask< PN_uint32, 32 >::set_range 0 1 269 0
71
inline void BitMask< PN_uint32, 32 >::set_range(int low_bit, int size);

1160 11 clear_range 0 4 1800 37 BitMask< PN_uint32, 32 >::clear_range 0 1 270 0
73
inline void BitMask< PN_uint32, 32 >::clear_range(int low_bit, int size);

1161 12 set_range_to 0 4 1800 38 BitMask< PN_uint32, 32 >::set_range_to 0 1 271 0
86
inline void BitMask< PN_uint32, 32 >::set_range_to(bool value, int low_bit, int size);

1162 8 get_word 0 4 1800 34 BitMask< PN_uint32, 32 >::get_word 0 1 272 0
64
inline PN_uint32 BitMask< PN_uint32, 32 >::get_word(void) const;

1163 8 set_word 0 4 1800 34 BitMask< PN_uint32, 32 >::set_word 0 1 273 0
64
inline void BitMask< PN_uint32, 32 >::set_word(PN_uint32 value);

1164 15 get_num_on_bits 0 4 1800 41 BitMask< PN_uint32, 32 >::get_num_on_bits 0 1 274 0
65
inline int BitMask< PN_uint32, 32 >::get_num_on_bits(void) const;

1165 16 get_num_off_bits 0 4 1800 42 BitMask< PN_uint32, 32 >::get_num_off_bits 0 1 275 0
66
inline int BitMask< PN_uint32, 32 >::get_num_off_bits(void) const;

1166 17 get_lowest_on_bit 0 4 1800 43 BitMask< PN_uint32, 32 >::get_lowest_on_bit 0 1 276 0
67
inline int BitMask< PN_uint32, 32 >::get_lowest_on_bit(void) const;

1167 18 get_lowest_off_bit 0 4 1800 44 BitMask< PN_uint32, 32 >::get_lowest_off_bit 0 1 277 0
68
inline int BitMask< PN_uint32, 32 >::get_lowest_off_bit(void) const;

1168 18 get_highest_on_bit 0 4 1800 44 BitMask< PN_uint32, 32 >::get_highest_on_bit 0 1 278 0
68
inline int BitMask< PN_uint32, 32 >::get_highest_on_bit(void) const;

1169 19 get_highest_off_bit 0 4 1800 45 BitMask< PN_uint32, 32 >::get_highest_off_bit 0 1 279 0
69
inline int BitMask< PN_uint32, 32 >::get_highest_off_bit(void) const;

1170 29 get_next_higher_different_bit 0 4 1800 55 BitMask< PN_uint32, 32 >::get_next_higher_different_bit 0 1 280 0
86
inline int BitMask< PN_uint32, 32 >::get_next_higher_different_bit(int low_bit) const;

1171 15 invert_in_place 0 4 1800 41 BitMask< PN_uint32, 32 >::invert_in_place 0 1 281 0
60
inline void BitMask< PN_uint32, 32 >::invert_in_place(void);

1172 18 has_bits_in_common 0 4 1800 44 BitMask< PN_uint32, 32 >::has_bits_in_common 0 1 282 0
102
inline bool BitMask< PN_uint32, 32 >::has_bits_in_common(BitMask< PN_uint32, 32 > const &other) const;

1173 5 clear 0 4 1800 31 BitMask< PN_uint32, 32 >::clear 0 1 283 0
50
inline void BitMask< PN_uint32, 32 >::clear(void);

1174 6 output 0 4 1800 32 BitMask< PN_uint32, 32 >::output 0 1 284 0
58
void BitMask< PN_uint32, 32 >::output(ostream &out) const;

1175 13 output_binary 0 4 1800 39 BitMask< PN_uint32, 32 >::output_binary 0 1 285 0
87
void BitMask< PN_uint32, 32 >::output_binary(ostream &out, int spaces_every = 4) const;

1176 10 output_hex 0 4 1800 36 BitMask< PN_uint32, 32 >::output_hex 0 1 286 0
84
void BitMask< PN_uint32, 32 >::output_hex(ostream &out, int spaces_every = 4) const;

1177 5 write 0 4 1800 31 BitMask< PN_uint32, 32 >::write 0 1 287 0
79
void BitMask< PN_uint32, 32 >::write(ostream &out, int indent_level = 0) const;

1178 11 operator == 0 4 1800 37 BitMask< PN_uint32, 32 >::operator == 0 1 288 0
95
inline bool BitMask< PN_uint32, 32 >::operator ==(BitMask< PN_uint32, 32 > const &other) const;

1179 11 operator != 0 4 1800 37 BitMask< PN_uint32, 32 >::operator != 0 1 289 0
95
inline bool BitMask< PN_uint32, 32 >::operator !=(BitMask< PN_uint32, 32 > const &other) const;

1180 10 operator < 0 4 1800 36 BitMask< PN_uint32, 32 >::operator < 0 1 290 0
94
inline bool BitMask< PN_uint32, 32 >::operator <(BitMask< PN_uint32, 32 > const &other) const;

1181 10 compare_to 0 4 1800 36 BitMask< PN_uint32, 32 >::compare_to 0 1 291 0
93
inline int BitMask< PN_uint32, 32 >::compare_to(BitMask< PN_uint32, 32 > const &other) const;

1182 10 operator & 0 4 1800 36 BitMask< PN_uint32, 32 >::operator & 0 1 292 0
114
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::operator &(BitMask< PN_uint32, 32 > const &other) const;

1183 10 operator | 0 4 1800 36 BitMask< PN_uint32, 32 >::operator | 0 1 293 0
114
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::operator |(BitMask< PN_uint32, 32 > const &other) const;

1184 10 operator ^ 0 4 1800 36 BitMask< PN_uint32, 32 >::operator ^ 0 1 294 0
114
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::operator ^(BitMask< PN_uint32, 32 > const &other) const;

1185 10 operator ~ 0 68 1800 36 BitMask< PN_uint32, 32 >::operator ~ 0 1 295 0
81
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::operator ~(void) const;

1186 11 operator << 0 4 1800 37 BitMask< PN_uint32, 32 >::operator << 0 1 296 0
87
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::operator <<(int shift) const;

1187 11 operator >> 0 4 1800 37 BitMask< PN_uint32, 32 >::operator >> 0 1 297 0
87
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::operator >>(int shift) const;

1188 11 operator &= 0 4 1800 37 BitMask< PN_uint32, 32 >::operator &= 0 1 298 0
89
inline void BitMask< PN_uint32, 32 >::operator &=(BitMask< PN_uint32, 32 > const &other);

1189 11 operator |= 0 4 1800 37 BitMask< PN_uint32, 32 >::operator |= 0 1 299 0
89
inline void BitMask< PN_uint32, 32 >::operator |=(BitMask< PN_uint32, 32 > const &other);

1190 11 operator ^= 0 4 1800 37 BitMask< PN_uint32, 32 >::operator ^= 0 1 300 0
89
inline void BitMask< PN_uint32, 32 >::operator ^=(BitMask< PN_uint32, 32 > const &other);

1191 12 operator <<= 0 4 1800 38 BitMask< PN_uint32, 32 >::operator <<= 0 1 301 0
62
inline void BitMask< PN_uint32, 32 >::operator <<=(int shift);

1192 12 operator >>= 0 4 1800 38 BitMask< PN_uint32, 32 >::operator >>= 0 1 302 0
62
inline void BitMask< PN_uint32, 32 >::operator >>=(int shift);

1193 19 flood_down_in_place 0 4 1800 45 BitMask< PN_uint32, 32 >::flood_down_in_place 0 1 303 0
64
inline void BitMask< PN_uint32, 32 >::flood_down_in_place(void);

1194 17 flood_up_in_place 0 4 1800 43 BitMask< PN_uint32, 32 >::flood_up_in_place 0 1 304 0
62
inline void BitMask< PN_uint32, 32 >::flood_up_in_place(void);

1195 15 flood_bits_down 0 4 1800 41 BitMask< PN_uint32, 32 >::flood_bits_down 0 1 305 0
86
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::flood_bits_down(void) const;

1196 13 flood_bits_up 0 4 1800 39 BitMask< PN_uint32, 32 >::flood_bits_up 0 1 306 0
84
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::flood_bits_up(void) const;

1197 21 keep_next_highest_bit 0 4 1800 47 BitMask< PN_uint32, 32 >::keep_next_highest_bit 0 3 307 308 309 0
316
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::keep_next_highest_bit(void) const;
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::keep_next_highest_bit(int index) const;
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::keep_next_highest_bit(BitMask< PN_uint32, 32 > const &other) const;

1198 20 keep_next_lowest_bit 0 4 1800 46 BitMask< PN_uint32, 32 >::keep_next_lowest_bit 0 3 310 311 312 0
313
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::keep_next_lowest_bit(void) const;
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::keep_next_lowest_bit(int index) const;
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::keep_next_lowest_bit(BitMask< PN_uint32, 32 > const &other) const;

1199 7 get_key 0 4 1800 33 BitMask< PN_uint32, 32 >::get_key 0 1 313 0
57
inline int BitMask< PN_uint32, 32 >::get_key(void) const;

1200 11 __nonzero__ 0 4 1800 37 BitMask< PN_uint32, 32 >::__nonzero__ 0 1 314 0
62
inline bool BitMask< PN_uint32, 32 >::__nonzero__(void) const;

1201 14 get_class_type 0 4 1800 40 BitMask< PN_uint32, 32 >::get_class_type 0 1 315 0
65
static TypeHandle BitMask< PN_uint32, 32 >::get_class_type(void);

1202 7 BitMask 0 4 1802 33 BitMask< PN_uint64, 64 >::BitMask 0 3 316 317 318 0
191
inline BitMask< PN_uint64, 64 >::BitMask(void);
inline BitMask< PN_uint64, 64 >::BitMask(PN_uint64 init_value);
inline BitMask< PN_uint64, 64 >::BitMask(BitMask< PN_uint64, 64 > const &copy);

1203 10 operator = 0 4 1802 36 BitMask< PN_uint64, 64 >::operator = 0 1 319 0
108
inline BitMask< PN_uint64, 64 > &BitMask< PN_uint64, 64 >::operator =(BitMask< PN_uint64, 64 > const &copy);

1204 6 all_on 0 4 1802 32 BitMask< PN_uint64, 64 >::all_on 0 1 320 0
78
static inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::all_on(void);

1205 7 all_off 0 4 1802 33 BitMask< PN_uint64, 64 >::all_off 0 1 321 0
79
static inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::all_off(void);

1206 8 lower_on 0 4 1802 34 BitMask< PN_uint64, 64 >::lower_on 0 1 322 0
87
static inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::lower_on(int on_bits);

1207 3 bit 0 4 1802 29 BitMask< PN_uint64, 64 >::bit 0 1 323 0
80
static inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::bit(int index);

1208 5 range 0 4 1802 31 BitMask< PN_uint64, 64 >::range 0 1 324 0
94
static inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::range(int low_bit, int size);

1209 8 ~BitMask 0 4 1802 34 BitMask< PN_uint64, 64 >::~BitMask 0 0 0
48
inline BitMask< PN_uint64, 64 >::~BitMask(void);

1210 16 has_max_num_bits 0 4 1802 42 BitMask< PN_uint64, 64 >::has_max_num_bits 0 1 325 0
61
static bool BitMask< PN_uint64, 64 >::has_max_num_bits(void);

1211 16 get_max_num_bits 0 4 1802 42 BitMask< PN_uint64, 64 >::get_max_num_bits 0 1 326 0
60
static int BitMask< PN_uint64, 64 >::get_max_num_bits(void);

1212 12 get_num_bits 0 4 1802 38 BitMask< PN_uint64, 64 >::get_num_bits 0 1 327 0
56
static int BitMask< PN_uint64, 64 >::get_num_bits(void);

1213 7 get_bit 0 4 1802 33 BitMask< PN_uint64, 64 >::get_bit 0 1 328 0
63
inline bool BitMask< PN_uint64, 64 >::get_bit(int index) const;

1214 7 set_bit 0 4 1802 33 BitMask< PN_uint64, 64 >::set_bit 0 1 329 0
57
inline void BitMask< PN_uint64, 64 >::set_bit(int index);

1215 9 clear_bit 0 4 1802 35 BitMask< PN_uint64, 64 >::clear_bit 0 1 330 0
59
inline void BitMask< PN_uint64, 64 >::clear_bit(int index);

1216 10 set_bit_to 0 4 1802 36 BitMask< PN_uint64, 64 >::set_bit_to 0 1 331 0
72
inline void BitMask< PN_uint64, 64 >::set_bit_to(int index, bool value);

1217 7 is_zero 0 4 1802 33 BitMask< PN_uint64, 64 >::is_zero 0 1 332 0
58
inline bool BitMask< PN_uint64, 64 >::is_zero(void) const;

1218 9 is_all_on 0 4 1802 35 BitMask< PN_uint64, 64 >::is_all_on 0 1 333 0
60
inline bool BitMask< PN_uint64, 64 >::is_all_on(void) const;

1219 7 extract 0 4 1802 33 BitMask< PN_uint64, 64 >::extract 0 1 334 0
80
inline PN_uint64 BitMask< PN_uint64, 64 >::extract(int low_bit, int size) const;

1220 5 store 0 4 1802 31 BitMask< PN_uint64, 64 >::store 0 1 335 0
84
inline void BitMask< PN_uint64, 64 >::store(PN_uint64 value, int low_bit, int size);

1221 10 has_any_of 0 4 1802 36 BitMask< PN_uint64, 64 >::has_any_of 0 1 336 0
78
inline bool BitMask< PN_uint64, 64 >::has_any_of(int low_bit, int size) const;

1222 10 has_all_of 0 4 1802 36 BitMask< PN_uint64, 64 >::has_all_of 0 1 337 0
78
inline bool BitMask< PN_uint64, 64 >::has_all_of(int low_bit, int size) const;

1223 9 set_range 0 4 1802 35 BitMask< PN_uint64, 64 >::set_range 0 1 338 0
71
inline void BitMask< PN_uint64, 64 >::set_range(int low_bit, int size);

1224 11 clear_range 0 4 1802 37 BitMask< PN_uint64, 64 >::clear_range 0 1 339 0
73
inline void BitMask< PN_uint64, 64 >::clear_range(int low_bit, int size);

1225 12 set_range_to 0 4 1802 38 BitMask< PN_uint64, 64 >::set_range_to 0 1 340 0
86
inline void BitMask< PN_uint64, 64 >::set_range_to(bool value, int low_bit, int size);

1226 8 get_word 0 4 1802 34 BitMask< PN_uint64, 64 >::get_word 0 1 341 0
64
inline PN_uint64 BitMask< PN_uint64, 64 >::get_word(void) const;

1227 8 set_word 0 4 1802 34 BitMask< PN_uint64, 64 >::set_word 0 1 342 0
64
inline void BitMask< PN_uint64, 64 >::set_word(PN_uint64 value);

1228 15 get_num_on_bits 0 4 1802 41 BitMask< PN_uint64, 64 >::get_num_on_bits 0 1 343 0
65
inline int BitMask< PN_uint64, 64 >::get_num_on_bits(void) const;

1229 16 get_num_off_bits 0 4 1802 42 BitMask< PN_uint64, 64 >::get_num_off_bits 0 1 344 0
66
inline int BitMask< PN_uint64, 64 >::get_num_off_bits(void) const;

1230 17 get_lowest_on_bit 0 4 1802 43 BitMask< PN_uint64, 64 >::get_lowest_on_bit 0 1 345 0
67
inline int BitMask< PN_uint64, 64 >::get_lowest_on_bit(void) const;

1231 18 get_lowest_off_bit 0 4 1802 44 BitMask< PN_uint64, 64 >::get_lowest_off_bit 0 1 346 0
68
inline int BitMask< PN_uint64, 64 >::get_lowest_off_bit(void) const;

1232 18 get_highest_on_bit 0 4 1802 44 BitMask< PN_uint64, 64 >::get_highest_on_bit 0 1 347 0
68
inline int BitMask< PN_uint64, 64 >::get_highest_on_bit(void) const;

1233 19 get_highest_off_bit 0 4 1802 45 BitMask< PN_uint64, 64 >::get_highest_off_bit 0 1 348 0
69
inline int BitMask< PN_uint64, 64 >::get_highest_off_bit(void) const;

1234 29 get_next_higher_different_bit 0 4 1802 55 BitMask< PN_uint64, 64 >::get_next_higher_different_bit 0 1 349 0
86
inline int BitMask< PN_uint64, 64 >::get_next_higher_different_bit(int low_bit) const;

1235 15 invert_in_place 0 4 1802 41 BitMask< PN_uint64, 64 >::invert_in_place 0 1 350 0
60
inline void BitMask< PN_uint64, 64 >::invert_in_place(void);

1236 18 has_bits_in_common 0 4 1802 44 BitMask< PN_uint64, 64 >::has_bits_in_common 0 1 351 0
102
inline bool BitMask< PN_uint64, 64 >::has_bits_in_common(BitMask< PN_uint64, 64 > const &other) const;

1237 5 clear 0 4 1802 31 BitMask< PN_uint64, 64 >::clear 0 1 352 0
50
inline void BitMask< PN_uint64, 64 >::clear(void);

1238 6 output 0 4 1802 32 BitMask< PN_uint64, 64 >::output 0 1 353 0
58
void BitMask< PN_uint64, 64 >::output(ostream &out) const;

1239 13 output_binary 0 4 1802 39 BitMask< PN_uint64, 64 >::output_binary 0 1 354 0
87
void BitMask< PN_uint64, 64 >::output_binary(ostream &out, int spaces_every = 4) const;

1240 10 output_hex 0 4 1802 36 BitMask< PN_uint64, 64 >::output_hex 0 1 355 0
84
void BitMask< PN_uint64, 64 >::output_hex(ostream &out, int spaces_every = 4) const;

1241 5 write 0 4 1802 31 BitMask< PN_uint64, 64 >::write 0 1 356 0
79
void BitMask< PN_uint64, 64 >::write(ostream &out, int indent_level = 0) const;

1242 11 operator == 0 4 1802 37 BitMask< PN_uint64, 64 >::operator == 0 1 357 0
95
inline bool BitMask< PN_uint64, 64 >::operator ==(BitMask< PN_uint64, 64 > const &other) const;

1243 11 operator != 0 4 1802 37 BitMask< PN_uint64, 64 >::operator != 0 1 358 0
95
inline bool BitMask< PN_uint64, 64 >::operator !=(BitMask< PN_uint64, 64 > const &other) const;

1244 10 operator < 0 4 1802 36 BitMask< PN_uint64, 64 >::operator < 0 1 359 0
94
inline bool BitMask< PN_uint64, 64 >::operator <(BitMask< PN_uint64, 64 > const &other) const;

1245 10 compare_to 0 4 1802 36 BitMask< PN_uint64, 64 >::compare_to 0 1 360 0
93
inline int BitMask< PN_uint64, 64 >::compare_to(BitMask< PN_uint64, 64 > const &other) const;

1246 10 operator & 0 4 1802 36 BitMask< PN_uint64, 64 >::operator & 0 1 361 0
114
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::operator &(BitMask< PN_uint64, 64 > const &other) const;

1247 10 operator | 0 4 1802 36 BitMask< PN_uint64, 64 >::operator | 0 1 362 0
114
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::operator |(BitMask< PN_uint64, 64 > const &other) const;

1248 10 operator ^ 0 4 1802 36 BitMask< PN_uint64, 64 >::operator ^ 0 1 363 0
114
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::operator ^(BitMask< PN_uint64, 64 > const &other) const;

1249 10 operator ~ 0 68 1802 36 BitMask< PN_uint64, 64 >::operator ~ 0 1 364 0
81
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::operator ~(void) const;

1250 11 operator << 0 4 1802 37 BitMask< PN_uint64, 64 >::operator << 0 1 365 0
87
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::operator <<(int shift) const;

1251 11 operator >> 0 4 1802 37 BitMask< PN_uint64, 64 >::operator >> 0 1 366 0
87
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::operator >>(int shift) const;

1252 11 operator &= 0 4 1802 37 BitMask< PN_uint64, 64 >::operator &= 0 1 367 0
89
inline void BitMask< PN_uint64, 64 >::operator &=(BitMask< PN_uint64, 64 > const &other);

1253 11 operator |= 0 4 1802 37 BitMask< PN_uint64, 64 >::operator |= 0 1 368 0
89
inline void BitMask< PN_uint64, 64 >::operator |=(BitMask< PN_uint64, 64 > const &other);

1254 11 operator ^= 0 4 1802 37 BitMask< PN_uint64, 64 >::operator ^= 0 1 369 0
89
inline void BitMask< PN_uint64, 64 >::operator ^=(BitMask< PN_uint64, 64 > const &other);

1255 12 operator <<= 0 4 1802 38 BitMask< PN_uint64, 64 >::operator <<= 0 1 370 0
62
inline void BitMask< PN_uint64, 64 >::operator <<=(int shift);

1256 12 operator >>= 0 4 1802 38 BitMask< PN_uint64, 64 >::operator >>= 0 1 371 0
62
inline void BitMask< PN_uint64, 64 >::operator >>=(int shift);

1257 19 flood_down_in_place 0 4 1802 45 BitMask< PN_uint64, 64 >::flood_down_in_place 0 1 372 0
64
inline void BitMask< PN_uint64, 64 >::flood_down_in_place(void);

1258 17 flood_up_in_place 0 4 1802 43 BitMask< PN_uint64, 64 >::flood_up_in_place 0 1 373 0
62
inline void BitMask< PN_uint64, 64 >::flood_up_in_place(void);

1259 15 flood_bits_down 0 4 1802 41 BitMask< PN_uint64, 64 >::flood_bits_down 0 1 374 0
86
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::flood_bits_down(void) const;

1260 13 flood_bits_up 0 4 1802 39 BitMask< PN_uint64, 64 >::flood_bits_up 0 1 375 0
84
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::flood_bits_up(void) const;

1261 21 keep_next_highest_bit 0 4 1802 47 BitMask< PN_uint64, 64 >::keep_next_highest_bit 0 3 376 377 378 0
316
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::keep_next_highest_bit(void) const;
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::keep_next_highest_bit(int index) const;
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::keep_next_highest_bit(BitMask< PN_uint64, 64 > const &other) const;

1262 20 keep_next_lowest_bit 0 4 1802 46 BitMask< PN_uint64, 64 >::keep_next_lowest_bit 0 3 379 380 381 0
313
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::keep_next_lowest_bit(void) const;
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::keep_next_lowest_bit(int index) const;
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::keep_next_lowest_bit(BitMask< PN_uint64, 64 > const &other) const;

1263 7 get_key 0 4 1802 33 BitMask< PN_uint64, 64 >::get_key 0 1 382 0
57
inline int BitMask< PN_uint64, 64 >::get_key(void) const;

1264 11 __nonzero__ 0 4 1802 37 BitMask< PN_uint64, 64 >::__nonzero__ 0 1 383 0
62
inline bool BitMask< PN_uint64, 64 >::__nonzero__(void) const;

1265 14 get_class_type 0 4 1802 40 BitMask< PN_uint64, 64 >::get_class_type 0 1 384 0
65
static TypeHandle BitMask< PN_uint64, 64 >::get_class_type(void);

1266 8 BitArray 0 4 1805 18 BitArray::BitArray 0 4 385 386 387 388 910
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: BitArray::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: BitArray::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: BitArray::Constructor (from SparseArray)
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
184
inline BitArray::BitArray(void);
inline BitArray::BitArray(BitArray::WordType init_value);
inline BitArray::BitArray(BitArray const &copy);
BitArray::BitArray(SparseArray const &from);

1267 10 operator = 0 4 1805 20 BitArray::operator = 0 1 389 233
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Copy Assignment Operator
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
60
inline BitArray &BitArray::operator =(BitArray const &copy);

1268 6 all_on 0 4 1805 16 BitArray::all_on 0 1 390 317
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a BitArray with an infinite array of bits,
//               all on.
////////////////////////////////////////////////////////////////////
46
static inline BitArray BitArray::all_on(void);

1269 7 all_off 0 4 1805 17 BitArray::all_off 0 1 391 284
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a BitArray whose bits are all off.
////////////////////////////////////////////////////////////////////
47
static inline BitArray BitArray::all_off(void);

1270 8 lower_on 0 4 1805 18 BitArray::lower_on 0 1 392 295
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named lower_on constructor
//       Access: Published, Static
//  Description: Returns a BitArray whose lower on_bits bits are on.
////////////////////////////////////////////////////////////////////
55
static inline BitArray BitArray::lower_on(int on_bits);

1271 3 bit 0 4 1805 13 BitArray::bit 0 1 393 289
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named bit constructor
//       Access: Published, Static
//  Description: Returns a BitArray with only the indicated bit on.
////////////////////////////////////////////////////////////////////
48
static inline BitArray BitArray::bit(int index);

1272 5 range 0 4 1805 15 BitArray::range 0 1 394 323
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named range constructor
//       Access: Published, Static
//  Description: Returns a BitArray whose size bits, beginning at
//               low_bit, are on.
////////////////////////////////////////////////////////////////////
62
static inline BitArray BitArray::range(int low_bit, int size);

1273 9 ~BitArray 0 4 1805 19 BitArray::~BitArray 0 0 219
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
33
inline BitArray::~BitArray(void);

1274 16 has_max_num_bits 0 4 1805 26 BitArray::has_max_num_bits 0 1 395 714
////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_max_num_bits
//       Access: Published, Static
//  Description: Returns true if there is a maximum number of bits
//               that may be stored in this structure, false
//               otherwise.  If this returns true, the number may be
//               queried in get_max_num_bits().
//
//               This method always returns false.  The BitArray has
//               no maximum number of bits.  This method is defined so
//               generic programming algorithms can use BitMask or
//               BitArray interchangeably.
////////////////////////////////////////////////////////////////////
45
static bool BitArray::has_max_num_bits(void);

1275 16 get_max_num_bits 0 4 1805 26 BitArray::get_max_num_bits 0 1 396 749
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_max_num_bits
//       Access: Published, Static
//  Description: If get_max_num_bits() returned true, this method may
//               be called to return the maximum number of bits that
//               may be stored in this structure.  It is an error to
//               call this if get_max_num_bits() return false.
//
//               It is always an error to call this method.  The
//               BitArray has no maximum number of bits.  This method
//               is defined so generic programming algorithms can use
//               BitMask or BitArray interchangeably.
////////////////////////////////////////////////////////////////////
44
static int BitArray::get_max_num_bits(void);

1276 21 get_num_bits_per_word 0 4 1805 31 BitArray::get_num_bits_per_word 0 1 397 476
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_bits_per_word
//       Access: Published, Static
//  Description: Returns the number of bits stored per word
//               internally.  This is of interest only in that it
//               limits the maximum number of bits that may be queried
//               or set at once by extract() and store().
////////////////////////////////////////////////////////////////////
49
static int BitArray::get_num_bits_per_word(void);

1277 12 get_num_bits 0 4 1805 22 BitArray::get_num_bits 0 1 398 604
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_bits
//       Access: Published
//  Description: Returns the current number of possibly different bits
//               in this array.  There are actually an infinite number
//               of bits, but every bit higher than this bit will have
//               the same value, either 0 or 1 (see
//               get_highest_bits()).
//
//               This number may grow and/or shrink automatically as
//               needed.
////////////////////////////////////////////////////////////////////
46
inline int BitArray::get_num_bits(void) const;

1278 7 get_bit 0 4 1805 17 BitArray::get_bit 0 1 399 442
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_bit
//       Access: Published
//  Description: Returns true if the nth bit is set, false if it is
//               cleared.  It is valid for n to increase beyond
//               get_num_bits(), but the return value get_num_bits()
//               will always be the same.
////////////////////////////////////////////////////////////////////
47
inline bool BitArray::get_bit(int index) const;

1279 7 set_bit 0 4 1805 17 BitArray::set_bit 0 1 400 317
////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_bit
//       Access: Published
//  Description: Sets the nth bit on.  If n >= get_num_bits(), this
//               automatically extends the array.
////////////////////////////////////////////////////////////////////
41
inline void BitArray::set_bit(int index);

1280 9 clear_bit 0 4 1805 19 BitArray::clear_bit 0 1 401 320
////////////////////////////////////////////////////////////////////
//     Function: BitArray::clear_bit
//       Access: Published
//  Description: Sets the nth bit off.  If n >= get_num_bits(), this
//               automatically extends the array.
////////////////////////////////////////////////////////////////////
43
inline void BitArray::clear_bit(int index);

1281 10 set_bit_to 0 4 1805 20 BitArray::set_bit_to 0 1 402 310
////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_bit_to
//       Access: Published
//  Description: Sets the nth bit either on or off, according to the
//               indicated bool value.
////////////////////////////////////////////////////////////////////
56
inline void BitArray::set_bit_to(int index, bool value);

1282 16 get_highest_bits 0 4 1805 26 BitArray::get_highest_bits 0 1 403 364
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_highest_bits
//       Access: Published
//  Description: Returns true if the infinite set of bits beyond
//               get_num_bits() are all on, or false of they are all
//               off.
////////////////////////////////////////////////////////////////////
51
inline bool BitArray::get_highest_bits(void) const;

1283 7 is_zero 0 4 1805 17 BitArray::is_zero 0 1 404 294
////////////////////////////////////////////////////////////////////
//     Function: BitArray::is_zero
//       Access: Published
//  Description: Returns true if the entire bitmask is zero, false
//               otherwise.
////////////////////////////////////////////////////////////////////
35
bool BitArray::is_zero(void) const;

1284 9 is_all_on 0 4 1805 19 BitArray::is_all_on 0 1 405 295
////////////////////////////////////////////////////////////////////
//     Function: BitArray::is_all_on
//       Access: Published
//  Description: Returns true if the entire bitmask is one, false
//               otherwise.
////////////////////////////////////////////////////////////////////
37
bool BitArray::is_all_on(void) const;

1285 7 extract 0 4 1805 17 BitArray::extract 0 1 406 438
////////////////////////////////////////////////////////////////////
//     Function: BitArray::extract
//       Access: Published
//  Description: Returns a word that represents only the indicated
//               range of bits within this BitArray, shifted to the
//               least-significant position.  size must be <=
//               get_num_bits_per_word().
////////////////////////////////////////////////////////////////////
73
inline BitArray::WordType BitArray::extract(int low_bit, int size) const;

1286 5 store 0 4 1805 15 BitArray::store 0 1 407 310
////////////////////////////////////////////////////////////////////
//     Function: BitArray::store
//       Access: Published
//  Description: Stores the indicated word into the indicated range of
//               bits with this BitArray.
////////////////////////////////////////////////////////////////////
77
inline void BitArray::store(BitArray::WordType value, int low_bit, int size);

1287 10 has_any_of 0 4 1805 20 BitArray::has_any_of 0 1 408 308
////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_any_of
//       Access: Published
//  Description: Returns true if any bit in the indicated range is
//               set, false otherwise.
////////////////////////////////////////////////////////////////////
55
bool BitArray::has_any_of(int low_bit, int size) const;

1288 10 has_all_of 0 4 1805 20 BitArray::has_all_of 0 1 409 310
////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_all_of
//       Access: Published
//  Description: Returns true if all bits in the indicated range are
//               set, false otherwise.
////////////////////////////////////////////////////////////////////
55
bool BitArray::has_all_of(int low_bit, int size) const;

1289 9 set_range 0 4 1805 19 BitArray::set_range 0 1 410 255
////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_range
//       Access: Published
//  Description: Sets the indicated range of bits on.
////////////////////////////////////////////////////////////////////
48
void BitArray::set_range(int low_bit, int size);

1290 11 clear_range 0 4 1805 21 BitArray::clear_range 0 1 411 258
////////////////////////////////////////////////////////////////////
//     Function: BitArray::clear_range
//       Access: Published
//  Description: Sets the indicated range of bits off.
////////////////////////////////////////////////////////////////////
50
void BitArray::clear_range(int low_bit, int size);

1291 12 set_range_to 0 4 1805 22 BitArray::set_range_to 0 1 412 275
////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_range_to
//       Access: Published
//  Description: Sets the indicated range of bits to either on or off.
////////////////////////////////////////////////////////////////////
70
inline void BitArray::set_range_to(bool value, int low_bit, int size);

1292 15 get_num_on_bits 0 4 1805 25 BitArray::get_num_on_bits 0 1 413 372
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_on_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 1 in the
//               array.  Returns -1 if there are an infinite number of
//               1 bits.
////////////////////////////////////////////////////////////////////
42
int BitArray::get_num_on_bits(void) const;

1293 16 get_num_off_bits 0 4 1805 26 BitArray::get_num_off_bits 0 1 414 373
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_off_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 0 in the
//               array.  Returns -1 if there are an infinite number of
//               0 bits.
////////////////////////////////////////////////////////////////////
43
int BitArray::get_num_off_bits(void) const;

1294 17 get_lowest_on_bit 0 4 1805 27 BitArray::get_lowest_on_bit 0 1 415 330
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_lowest_on_bit
//       Access: Published
//  Description: Returns the index of the lowest 1 bit in the array.
//               Returns -1 if there are no 1 bits.
////////////////////////////////////////////////////////////////////
44
int BitArray::get_lowest_on_bit(void) const;

1295 18 get_lowest_off_bit 0 4 1805 28 BitArray::get_lowest_off_bit 0 1 416 331
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_lowest_off_bit
//       Access: Published
//  Description: Returns the index of the lowest 0 bit in the array.
//               Returns -1 if there are no 0 bits.
////////////////////////////////////////////////////////////////////
45
int BitArray::get_lowest_off_bit(void) const;

1296 18 get_highest_on_bit 0 4 1805 28 BitArray::get_highest_on_bit 0 1 417 390
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_highest_on_bit
//       Access: Published
//  Description: Returns the index of the highest 1 bit in the array.
//               Returns -1 if there are no 1 bits or if there an
//               infinite number of 1 bits.
////////////////////////////////////////////////////////////////////
45
int BitArray::get_highest_on_bit(void) const;

1297 19 get_highest_off_bit 0 4 1805 29 BitArray::get_highest_off_bit 0 1 418 391
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_highest_off_bit
//       Access: Published
//  Description: Returns the index of the highest 0 bit in the array.
//               Returns -1 if there are no 0 bits or if there an
//               infinite number of 1 bits.
////////////////////////////////////////////////////////////////////
46
int BitArray::get_highest_off_bit(void) const;

1298 29 get_next_higher_different_bit 0 4 1805 39 BitArray::get_next_higher_different_bit 0 1 419 591
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_next_higher_different_bit
//       Access: Published
//  Description: Returns the index of the next bit in the array, above
//               low_bit, whose value is different that the value of
//               low_bit.  Returns low_bit again if all bits higher
//               than low_bit have the same value.
//
//               This can be used to quickly iterate through all of
//               the bits in the array.
////////////////////////////////////////////////////////////////////
63
int BitArray::get_next_higher_different_bit(int low_bit) const;

1299 13 get_num_words 0 4 1805 23 BitArray::get_num_words 0 1 420 304
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_words
//       Access: Published
//  Description: Returns the number of possibly-unique words stored in
//               the array.
////////////////////////////////////////////////////////////////////
47
inline int BitArray::get_num_words(void) const;

1300 8 get_word 0 4 1805 18 BitArray::get_word 0 1 421 410
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_word
//       Access: Published
//  Description: Returns the nth word in the array.  It is valid for n
//               to be greater than get_num_words(), but the return
//               value beyond get_num_words() will always be the same.
////////////////////////////////////////////////////////////////////
58
inline BitArray::MaskType BitArray::get_word(int n) const;

1301 8 set_word 0 4 1805 18 BitArray::set_word 0 1 422 351
////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_word
//       Access: Published
//  Description: Replaces the nth word in the array.  If n >=
//               get_num_words(), this automatically extends the
//               array.
////////////////////////////////////////////////////////////////////
64
inline void BitArray::set_word(int n, BitArray::WordType value);

1302 15 invert_in_place 0 4 1805 25 BitArray::invert_in_place 0 1 423 318
////////////////////////////////////////////////////////////////////
//     Function: BitArray::invert_in_place
//       Access: Published
//  Description: Inverts all the bits in the BitArray.  This is
//               equivalent to array = ~array.
////////////////////////////////////////////////////////////////////
37
void BitArray::invert_in_place(void);

1303 18 has_bits_in_common 0 4 1805 28 BitArray::has_bits_in_common 0 1 424 440
////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_bits_in_common
//       Access: Published
//  Description: Returns true if this BitArray has any "one" bits in
//               common with the other one, false otherwise.
//
//               This is equivalent to (array & other) != 0, but may
//               be faster.
////////////////////////////////////////////////////////////////////
63
bool BitArray::has_bits_in_common(BitArray const &other) const;

1304 5 clear 0 4 1805 15 BitArray::clear 0 1 425 253
////////////////////////////////////////////////////////////////////
//     Function: BitArray::clear
//       Access: Published
//  Description: Sets all the bits in the BitArray off.
////////////////////////////////////////////////////////////////////
34
inline void BitArray::clear(void);

1305 6 output 0 4 1805 16 BitArray::output 0 1 426 443
////////////////////////////////////////////////////////////////////
//     Function: BitArray::output
//       Access: Published
//  Description: Writes the BitArray out as a hex number.  For a
//               BitArray, this is always the same as output_hex();
//               it's too confusing for the output format to change
//               back and forth at runtime.
////////////////////////////////////////////////////////////////////
42
void BitArray::output(ostream &out) const;

1306 13 output_binary 0 4 1805 23 BitArray::output_binary 0 1 427 312
////////////////////////////////////////////////////////////////////
//     Function: BitArray::output_binary
//       Access: Published
//  Description: Writes the BitArray out as a binary number, with
//               spaces every four bits.
////////////////////////////////////////////////////////////////////
71
void BitArray::output_binary(ostream &out, int spaces_every = 4) const;

1307 10 output_hex 0 4 1805 20 BitArray::output_hex 0 1 428 316
////////////////////////////////////////////////////////////////////
//     Function: BitArray::output_hex
//       Access: Published
//  Description: Writes the BitArray out as a hexadecimal number, with
//               spaces every four digits.
////////////////////////////////////////////////////////////////////
68
void BitArray::output_hex(ostream &out, int spaces_every = 4) const;

1308 5 write 0 4 1805 15 BitArray::write 0 1 429 317
////////////////////////////////////////////////////////////////////
//     Function: BitArray::write
//       Access: Published
//  Description: Writes the BitArray out as a binary or a hex number,
//               according to the number of bits.
////////////////////////////////////////////////////////////////////
63
void BitArray::write(ostream &out, int indent_level = 0) const;

1309 11 operator == 0 4 1805 21 BitArray::operator == 0 1 430 0
63
inline bool BitArray::operator ==(BitArray const &other) const;

1310 11 operator != 0 4 1805 21 BitArray::operator != 0 1 431 0
63
inline bool BitArray::operator !=(BitArray const &other) const;

1311 10 operator < 0 4 1805 20 BitArray::operator < 0 1 432 0
62
inline bool BitArray::operator <(BitArray const &other) const;

1312 10 compare_to 0 4 1805 20 BitArray::compare_to 0 1 433 487
////////////////////////////////////////////////////////////////////
//     Function: BitArray::compare_to
//       Access: Published
//  Description: Returns a number less than zero if this BitArray sorts
//               before the indicated other BitArray, greater than zero
//               if it sorts after, or 0 if they are equivalent.  This
//               is based on the same ordering defined by operator <.
////////////////////////////////////////////////////////////////////
54
int BitArray::compare_to(BitArray const &other) const;

1313 10 operator & 0 4 1805 20 BitArray::operator & 0 1 434 0
66
inline BitArray BitArray::operator &(BitArray const &other) const;

1314 10 operator | 0 4 1805 20 BitArray::operator | 0 1 435 0
66
inline BitArray BitArray::operator |(BitArray const &other) const;

1315 10 operator ^ 0 4 1805 20 BitArray::operator ^ 0 1 436 0
66
inline BitArray BitArray::operator ^(BitArray const &other) const;

1316 10 operator ~ 0 68 1805 20 BitArray::operator ~ 0 1 437 0
49
inline BitArray BitArray::operator ~(void) const;

1317 11 operator << 0 4 1805 21 BitArray::operator << 0 1 438 0
55
inline BitArray BitArray::operator <<(int shift) const;

1318 11 operator >> 0 4 1805 21 BitArray::operator >> 0 1 439 0
55
inline BitArray BitArray::operator >>(int shift) const;

1319 11 operator &= 0 4 1805 21 BitArray::operator &= 0 1 440 0
50
void BitArray::operator &=(BitArray const &other);

1320 11 operator |= 0 4 1805 21 BitArray::operator |= 0 1 441 0
50
void BitArray::operator |=(BitArray const &other);

1321 11 operator ^= 0 4 1805 21 BitArray::operator ^= 0 1 442 0
50
void BitArray::operator ^=(BitArray const &other);

1322 12 operator <<= 0 4 1805 22 BitArray::operator <<= 0 1 443 0
39
void BitArray::operator <<=(int shift);

1323 12 operator >>= 0 4 1805 22 BitArray::operator >>= 0 1 444 0
39
void BitArray::operator >>=(int shift);

1324 14 get_class_type 0 4 1805 24 BitArray::get_class_type 0 1 445 0
49
static TypeHandle BitArray::get_class_type(void);

1325 12 ButtonHandle 0 4 1807 26 ButtonHandle::ButtonHandle 0 4 446 447 448 449 1817
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Constructor
//       Access: Published
//  Description: The default constructor must do nothing, because we
//               can't guarantee ordering of static initializers.  If
//               the constructor tried to initialize its value, it
//               might happen after the value had already been set
//               previously by another static initializer!
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Constructor
//       Access: Published
//  Description: Constructs a ButtonHandle with the corresponding
//               index number, which may have been returned by an
//               earlier call to ButtonHandle::get_index().
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Constructor
//       Access: Published
//  Description: Constructs a ButtonHandle with the corresponding
//               name, which is looked up in the ButtonRegistry.
//               This exists for the purpose of being able to
//               automatically coerce a string into a ButtonHandle;
//               for most purposes, you should use either the static
//               KeyboardButton/MouseButton getters or
//               ButtonRegistry::register_button().
////////////////////////////////////////////////////////////////////
195
inline ButtonHandle::ButtonHandle(void);
inline ButtonHandle::ButtonHandle(int index);
inline ButtonHandle::ButtonHandle(ButtonHandle const &copy);
ButtonHandle::ButtonHandle(string const &name);

1326 11 operator == 0 4 1807 25 ButtonHandle::operator == 0 1 450 0
71
inline bool ButtonHandle::operator ==(ButtonHandle const &other) const;

1327 11 operator != 0 4 1807 25 ButtonHandle::operator != 0 1 451 0
71
inline bool ButtonHandle::operator !=(ButtonHandle const &other) const;

1328 10 operator < 0 4 1807 24 ButtonHandle::operator < 0 1 452 0
70
inline bool ButtonHandle::operator <(ButtonHandle const &other) const;

1329 11 operator <= 0 4 1807 25 ButtonHandle::operator <= 0 1 453 0
71
inline bool ButtonHandle::operator <=(ButtonHandle const &other) const;

1330 10 operator > 0 4 1807 24 ButtonHandle::operator > 0 1 454 0
70
inline bool ButtonHandle::operator >(ButtonHandle const &other) const;

1331 11 operator >= 0 4 1807 25 ButtonHandle::operator >= 0 1 455 0
71
inline bool ButtonHandle::operator >=(ButtonHandle const &other) const;

1332 10 compare_to 0 4 1807 24 ButtonHandle::compare_to 0 1 456 467
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::compare_to
//       Access: Published
//  Description: Sorts ButtonHandles arbitrarily (according to <, >,
//               etc.).  Returns a number less than 0 if this type
//               sorts before the other one, greater than zero if it
//               sorts after, 0 if they are equivalent.
////////////////////////////////////////////////////////////////////
69
inline int ButtonHandle::compare_to(ButtonHandle const &other) const;

1333 8 get_hash 0 4 1807 22 ButtonHandle::get_hash 0 1 457 265
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_hash
//       Access: Published
//  Description: Returns a hash code suitable for phash_map.
////////////////////////////////////////////////////////////////////
49
inline size_t ButtonHandle::get_hash(void) const;

1334 8 get_name 0 4 1807 22 ButtonHandle::get_name 0 1 458 250
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_name
//       Access: Public
//  Description: Returns the name of the button.
////////////////////////////////////////////////////////////////////
42
string ButtonHandle::get_name(void) const;

1335 20 has_ascii_equivalent 0 4 1807 34 ButtonHandle::has_ascii_equivalent 0 1 459 375
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::has_ascii_equivalent
//       Access: Published
//  Description: Returns true if the button was created with an ASCII
//               equivalent code (e.g. for a standard keyboard
//               button).
////////////////////////////////////////////////////////////////////
59
inline bool ButtonHandle::has_ascii_equivalent(void) const;

1336 20 get_ascii_equivalent 0 4 1807 34 ButtonHandle::get_ascii_equivalent 0 1 460 346
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_ascii_equivalent
//       Access: Published
//  Description: Returns the character code associated with the
//               button, or '\0' if no ASCII code was associated.
////////////////////////////////////////////////////////////////////
59
inline char ButtonHandle::get_ascii_equivalent(void) const;

1337 9 get_alias 0 4 1807 23 ButtonHandle::get_alias 0 1 461 692
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_alias
//       Access: Published
//  Description: Returns the alias (alternate name) associated with
//               the button, if any, or ButtonHandle::none() if the
//               button has no alias.
//
//               Each button is allowed to have one alias, and
//               multiple different buttons can refer to the same
//               alias.  The alias should be the more general name for
//               the button, for instance, shift is an alias for
//               lshift, but not vice-versa.
////////////////////////////////////////////////////////////////////
49
ButtonHandle ButtonHandle::get_alias(void) const;

1338 7 matches 0 4 1807 21 ButtonHandle::matches 0 1 462 532
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::matches
//       Access: Published
//  Description: Returns true if this ButtonHandle is the same as the
//               other one, or if the other one is an alias for this
//               one.  (Does not return true if this button is an
//               alias for the other one, however.)
//
//               This is a more general comparison than operator ==.
////////////////////////////////////////////////////////////////////
67
inline bool ButtonHandle::matches(ButtonHandle const &other) const;

1339 9 get_index 0 4 1807 23 ButtonHandle::get_index 0 1 463 664
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_index
//       Access: Published
//  Description: Returns the integer index associated with this
//               ButtonHandle. Each different ButtonHandle will have a
//               different index.  However, you probably shouldn't be
//               using this method; you should just treat the
//               ButtonHandles as opaque classes.  This is provided
//               for the convenience of non-C++ scripting languages to
//               build a hashtable of ButtonHandles.
////////////////////////////////////////////////////////////////////
47
inline int ButtonHandle::get_index(void) const;

1340 6 output 0 4 1807 20 ButtonHandle::output 0 1 464 219
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::output
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
53
inline void ButtonHandle::output(ostream &out) const;

1341 4 none 0 4 1807 18 ButtonHandle::none 0 1 465 321
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::none
//       Access: Published, Static
//  Description: Returns a special zero-valued ButtonHandle that is
//               used to indicate no button.
////////////////////////////////////////////////////////////////////
52
static inline ButtonHandle ButtonHandle::none(void);

1342 22 operator typecast bool 0 132 1807 36 ButtonHandle::operator typecast bool 0 1 467 0
61
inline bool ButtonHandle::operator typecast bool(void) const;

1343 14 get_class_type 0 4 1807 28 ButtonHandle::get_class_type 0 1 466 0
53
static TypeHandle ButtonHandle::get_class_type(void);

1344 13 ~ButtonHandle 0 4 1807 27 ButtonHandle::~ButtonHandle 0 0 0
34
ButtonHandle::~ButtonHandle(void);

1345 10 get_button 0 4 1808 26 ButtonRegistry::get_button 0 1 468 396
////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::get_button
//       Access: Published
//  Description: Finds a ButtonHandle in the registry matching the
//               indicated name.  If there is no such ButtonHandle,
//               registers a new one and returns it.
////////////////////////////////////////////////////////////////////
60
ButtonHandle ButtonRegistry::get_button(string const &name);

1346 11 find_button 0 4 1808 27 ButtonRegistry::find_button 0 1 469 391
////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::find_button
//       Access: Published
//  Description: Finds a ButtonHandle in the registry matching the
//               indicated name.  If there is no such ButtonHandle,
//               returns ButtonHandle::none().
////////////////////////////////////////////////////////////////////
61
ButtonHandle ButtonRegistry::find_button(string const &name);

1347 17 find_ascii_button 0 4 1808 33 ButtonRegistry::find_ascii_button 0 1 470 419
////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::find_ascii_button
//       Access: Published
//  Description: Finds a ButtonHandle in the registry matching the
//               indicated ASCII equivalent character.  If there is no
//               such ButtonHandle, returns ButtonHandle::none().
////////////////////////////////////////////////////////////////////
76
ButtonHandle ButtonRegistry::find_ascii_button(char ascii_equivalent) const;

1348 5 write 0 4 1808 21 ButtonRegistry::write 0 1 471 220
////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::write
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
47
void ButtonRegistry::write(ostream &out) const;

1349 3 ptr 0 4 1808 19 ButtonRegistry::ptr 0 1 472 367
// ptr() returns the pointer to the global ButtonRegistry object.

////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::ptr
//       Access: Published, Static
//  Description: Returns the pointer to the global ButtonRegistry
//               object.
////////////////////////////////////////////////////////////////////
56
static inline ButtonRegistry *ButtonRegistry::ptr(void);

1350 15 ~ButtonRegistry 0 4 1808 31 ButtonRegistry::~ButtonRegistry 0 0 0
38
ButtonRegistry::~ButtonRegistry(void);

1351 15 get_num_buttons 0 4 1809 26 ButtonMap::get_num_buttons 0 1 473 308
////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_num_buttons
//       Access: Published
//  Description: Returns the number of buttons that this button
//               mapping specifies.
////////////////////////////////////////////////////////////////////
50
inline int ButtonMap::get_num_buttons(void) const;

1352 14 get_raw_button 0 4 1809 25 ButtonMap::get_raw_button 0 1 474 307
////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_raw_button
//       Access: Published
//  Description: Returns the underlying raw button associated with
//               the nth button.
////////////////////////////////////////////////////////////////////
59
inline ButtonHandle ButtonMap::get_raw_button(int i) const;

1353 17 get_mapped_button 0 4 1809 28 ButtonMap::get_mapped_button 0 3 475 476 477 1158
////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button
//       Access: Published
//  Description: Returns the nth mapped button, meaning the button
//               that the nth raw button is mapped to.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button
//       Access: Published
//  Description: Returns the button that the given button is mapped
//               to, or ButtonHandle::none() if this map does not
//               specify a mapped button for the given raw button.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button
//       Access: Published
//  Description: Returns the button that the given button is mapped
//               to, or ButtonHandle::none() if this map does not
//               specify a mapped button for the given raw button.
////////////////////////////////////////////////////////////////////
216
inline ButtonHandle ButtonMap::get_mapped_button(int i) const;
inline ButtonHandle ButtonMap::get_mapped_button(ButtonHandle raw) const;
inline ButtonHandle ButtonMap::get_mapped_button(string const &raw_name) const;

1354 23 get_mapped_button_label 0 4 1809 34 ButtonMap::get_mapped_button_label 0 3 478 479 480 1713
////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button_label
//       Access: Published
//  Description: Returns the label associated with the nth mapped
//               button, meaning the button that the nth raw
//               button is mapped to.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ButtoMap::get_mapped_button_label
//       Access: Published
//  Description: If the button map specifies a special name for the
//               button (eg. if the operating system or keyboard
//               device has a localized name describing the key),
//               returns it, or the empty string otherwise.
//
//               Note that this is not the same as
//               get_mapped_button().get_name(), which returns the
//               name of the Panda event associated with the button.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ButtoMap::get_mapped_button_label
//       Access: Published
//  Description: If the button map specifies a special name for the
//               button (eg. if the operating system or keyboard
//               device has a localized name describing the key),
//               returns it, or the empty string otherwise.
//
//               Note that this is not the same as
//               get_mapped_button().get_name(), which returns the
//               name of the Panda event associated with the button.
////////////////////////////////////////////////////////////////////
237
inline string const &ButtonMap::get_mapped_button_label(int i) const;
inline string const &ButtonMap::get_mapped_button_label(ButtonHandle raw) const;
inline string const &ButtonMap::get_mapped_button_label(string const &raw_name) const;

1355 6 output 0 4 1809 17 ButtonMap::output 0 1 481 217
////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
43
void ButtonMap::output(ostream &out) const;

1356 5 write 0 4 1809 16 ButtonMap::write 0 1 482 216
////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::write
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
64
void ButtonMap::write(ostream &out, int indent_level = 0) const;

1357 14 get_class_type 0 4 1809 25 ButtonMap::get_class_type 0 1 483 0
50
static TypeHandle ButtonMap::get_class_type(void);

1358 10 ~ButtonMap 0 4 1809 21 ButtonMap::~ButtonMap 0 0 0
28
ButtonMap::~ButtonMap(void);

1359 6 output 0 6 1811 22 CallbackObject::output 0 1 484 230
////////////////////////////////////////////////////////////////////
//     Function: CallbackObject::output
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
56
virtual void CallbackObject::output(ostream &out) const;

1360 4 make 0 4 1811 20 CallbackObject::make 0 1 485 0
76
static PointerTo< CallbackObject > CallbackObject::make(PyObject *function);

1361 14 get_class_type 0 4 1811 30 CallbackObject::get_class_type 0 1 486 0
55
static TypeHandle CallbackObject::get_class_type(void);

1362 15 ~CallbackObject 0 4 1811 31 CallbackObject::~CallbackObject 0 0 0
38
CallbackObject::~CallbackObject(void);

1363 19 get_cache_ref_count 0 4 1812 54 CachedTypedWritableReferenceCount::get_cache_ref_count 0 1 487 290
////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::get_cache_ref_count
//       Access: Published
//  Description: Returns the current reference count.
////////////////////////////////////////////////////////////////////
78
inline int CachedTypedWritableReferenceCount::get_cache_ref_count(void) const;

1364 9 cache_ref 0 4 1812 44 CachedTypedWritableReferenceCount::cache_ref 0 1 488 355
////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::cache_ref
//       Access: Published
//  Description: Explicitly increments the cache reference count and
//               the normal reference count simultaneously.
////////////////////////////////////////////////////////////////////
69
inline void CachedTypedWritableReferenceCount::cache_ref(void) const;

1365 11 cache_unref 0 4 1812 46 CachedTypedWritableReferenceCount::cache_unref 0 1 489 479
////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::cache_unref
//       Access: Published
//  Description: Explicitly decrements the cache reference count and
//               the normal reference count simultaneously.
//
//               The return value is true if the new reference count
//               is nonzero, false if it is zero.
////////////////////////////////////////////////////////////////////
71
inline bool CachedTypedWritableReferenceCount::cache_unref(void) const;

1366 24 test_ref_count_integrity 0 4 1812 59 CachedTypedWritableReferenceCount::test_ref_count_integrity 0 1 490 359
////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::test_ref_count_integrity
//       Access: Published
//  Description: Does some easy checks to make sure that the reference
//               count isn't completely bogus.
////////////////////////////////////////////////////////////////////
84
inline bool CachedTypedWritableReferenceCount::test_ref_count_integrity(void) const;

1367 14 get_class_type 0 4 1812 49 CachedTypedWritableReferenceCount::get_class_type 0 1 491 0
74
static TypeHandle CachedTypedWritableReferenceCount::get_class_type(void);

1368 6 output 0 6 1813 20 CallbackData::output 0 1 492 228
////////////////////////////////////////////////////////////////////
//     Function: CallbackData::output
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
54
virtual void CallbackData::output(ostream &out) const;

1369 6 upcall 0 6 1813 20 CallbackData::upcall 0 1 493 408
////////////////////////////////////////////////////////////////////
//     Function: CallbackData::upcall
//       Access: Published, Virtual
//  Description: You should make this call during the callback if you
//               want to continue the normal function that would have
//               been done in the absence of a callback.
////////////////////////////////////////////////////////////////////
40
virtual void CallbackData::upcall(void);

1370 14 get_class_type 0 4 1813 28 CallbackData::get_class_type 0 1 494 0
53
static TypeHandle CallbackData::get_class_type(void);

1371 13 ~CallbackData 0 4 1813 27 CallbackData::~CallbackData 0 0 0
34
CallbackData::~CallbackData(void);

1372 20 PythonCallbackObject 0 4 1814 42 PythonCallbackObject::PythonCallbackObject 0 1 495 0
86
PythonCallbackObject::PythonCallbackObject(PyObject *function = (& ::_Py_NoneStruct));

1373 12 operator new 0 4 1814 34 PythonCallbackObject::operator new 0 1 496 0
134
inline void *PythonCallbackObject::operator new(size_t size);
inline void *PythonCallbackObject::operator new(size_t size, void *ptr);

1374 15 operator delete 0 4 1814 37 PythonCallbackObject::operator delete 0 0 0
128
inline void PythonCallbackObject::operator delete(void *ptr);
inline void PythonCallbackObject::operator delete(void *, void *);

1375 12 validate_ptr 0 4 1814 34 PythonCallbackObject::validate_ptr 0 0 0
71
static inline bool PythonCallbackObject::validate_ptr(void const *ptr);

1376 12 set_function 0 4 1814 34 PythonCallbackObject::set_function 0 1 497 0
60
void PythonCallbackObject::set_function(PyObject *function);

1377 12 get_function 0 4 1814 34 PythonCallbackObject::get_function 0 1 498 0
51
PyObject *PythonCallbackObject::get_function(void);

1378 14 get_class_type 0 4 1814 36 PythonCallbackObject::get_class_type 0 1 499 0
61
static TypeHandle PythonCallbackObject::get_class_type(void);

1379 7 TimeVal 0 4 1815 16 TimeVal::TimeVal 0 1 500 218
////////////////////////////////////////////////////////////////////
//     Function: TimeVal::contructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
30
inline TimeVal::TimeVal(void);

1380 7 get_sec 0 4 1815 16 TimeVal::get_sec 0 1 501 215
////////////////////////////////////////////////////////////////////
//     Function: TimeVal::get_sec
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
42
inline ulong TimeVal::get_sec(void) const;

1381 8 get_usec 0 4 1815 17 TimeVal::get_usec 0 1 502 216
////////////////////////////////////////////////////////////////////
//     Function: TimeVal::get_usec
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
43
inline ulong TimeVal::get_usec(void) const;

1382 6 get_tv 0 20 1815 15 TimeVal::get_tv 0 1 504 32
getter for ulong TimeVal::tv[2];
37
ulong TimeVal::get_tv(void)[2] const;

1383 6 set_tv 0 36 1815 15 TimeVal::set_tv 0 1 503 32
setter for ulong TimeVal::tv[2];
37
void TimeVal::set_tv(ulong value[2]);

1384 8 ~TimeVal 0 4 1815 17 TimeVal::~TimeVal 0 0 0
24
TimeVal::~TimeVal(void);

1385 11 ClockObject 0 4 1819 24 ClockObject::ClockObject 0 2 505 506 454
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ClockObject::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
82
ClockObject::ClockObject(void);
ClockObject::ClockObject(ClockObject const &copy);

1386 8 set_mode 0 4 1819 21 ClockObject::set_mode 0 1 507 2596
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_mode
//       Access: Published
//  Description: Changes the mode of the clock.  Normally, the clock
//               is in mode M_normal. In this mode, each call to
//               tick() will set the value returned by
//               get_frame_time() to the current real time; thus, the
//               clock simply reports time advancing.
//
//               Other possible modes:
//
//               M_non_real_time - the clock ignores real time
//               completely; at each call to tick(), it pretends that
//               exactly dt seconds have elapsed since the last call
//               to tick().  You may set the value of dt with
//               set_dt() or set_frame_rate().
//
//               M_limited - the clock will run as fast as it can, as
//               in M_normal, but will not run faster than the rate
//               specified by set_frame_rate().  If the application
//               would run faster than this rate, the clock will slow
//               down the application.
//
//               M_integer - the clock will run as fast as it can, but
//               the rate will be constrained to be an integer
//               multiple or divisor of the rate specified by
//               set_frame_rate().  The clock will slow down the
//               application a bit to guarantee this.
//
//               M_integer_limited - a combination of M_limited and
//               M_integer; the clock will not run faster than
//               set_frame_rate(), and if it runs slower, it will run
//               at a integer divisor of that rate.
//
//               M_forced - the clock forces the application to run at
//               the rate specified by set_frame_rate().  If the
//               application would run faster than this rate, the
//               clock will slow down the application; if the
//               application would run slower than this rate, the
//               clock slows down time so that the application
//               believes it is running at the given rate.
//
//               M_degrade - the clock runs at real time, but the
//               application is slowed down by a set factor of its
//               frame rate, specified by set_degrade_factor().
//
//               M_slave - the clock does not advance, but relies on
//               the user to call set_frame_time() and/or
//               set_frame_count() each frame.
////////////////////////////////////////////////////////////////////
51
void ClockObject::set_mode(ClockObject::Mode mode);

1387 8 get_mode 0 4 1819 21 ClockObject::get_mode 0 1 508 293
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_mode
//       Access: Published
//  Description: Returns the current mode of the clock.  See
//               set_mode().
////////////////////////////////////////////////////////////////////
59
inline ClockObject::Mode ClockObject::get_mode(void) const;

1388 14 get_frame_time 0 4 1819 27 ClockObject::get_frame_time 0 1 509 656
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_frame_time
//       Access: Published
//  Description: Returns the time in seconds as of the last time
//               tick() was called (typically, this will be as of the
//               start of the current frame).
//
//               This is generally the kind of time you want to ask
//               for in most rendering and animation contexts, since
//               it's important that all of the animation for a given
//               frame remains in sync with each other.
////////////////////////////////////////////////////////////////////
97
inline double ClockObject::get_frame_time(Thread *current_thread = (get_current_thread())) const;

1389 13 get_real_time 0 4 1819 26 ClockObject::get_real_time 0 1 510 769
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_real_time
//       Access: Published
//  Description: Returns the actual number of seconds elapsed since
//               the ClockObject was created, or since it was last
//               reset.  This is useful for doing real timing
//               measurements, e.g. for performance statistics.
//
//               This returns the most precise timer we have for short
//               time intervals, but it may tend to drift over the
//               long haul.  If more accurate timekeeping is needed
//               over a long period of time, use get_long_time()
//               instead.
////////////////////////////////////////////////////////////////////
53
inline double ClockObject::get_real_time(void) const;

1390 13 get_long_time 0 4 1819 26 ClockObject::get_long_time 0 1 511 773
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_long_time
//       Access: Published
//  Description: Returns the actual number of seconds elapsed since
//               the ClockObject was created, or since it was last
//               reset.
//
//               This is similar to get_real_time(), except that it
//               uses the most accurate counter we have over a long
//               period of time, and so it is less likely to drift.
//               However, it may not be very precise for measuring
//               short intervals.  On Windows, for instace, this is
//               only accurate to within about 55 milliseconds.
////////////////////////////////////////////////////////////////////
53
inline double ClockObject::get_long_time(void) const;

1391 5 reset 0 4 1819 18 ClockObject::reset 0 1 512 299
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::reset
//       Access: Published
//  Description: Simultaneously resets both the time and the frame
//               count to zero.
////////////////////////////////////////////////////////////////////
37
inline void ClockObject::reset(void);

1392 13 set_real_time 0 4 1819 26 ClockObject::set_real_time 0 1 513 607
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_real_time
//       Access: Published
//  Description: Resets the clock to the indicated time.  This
//               changes only the real time of the clock as reported
//               by get_real_time(), but does not immediately change
//               the time reported by get_frame_time()--that will
//               change after the next call to tick().  Also see
//               reset(), set_frame_time(), and set_frame_count().
////////////////////////////////////////////////////////////////////
45
void ClockObject::set_real_time(double time);

1393 14 set_frame_time 0 4 1819 27 ClockObject::set_frame_time 0 1 514 477
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_frame_time
//       Access: Published
//  Description: Changes the time as reported for the current frame to
//               the indicated time.  Normally, the way to adjust the
//               frame time is via tick(); this function is provided
//               only for occasional special adjustments.
////////////////////////////////////////////////////////////////////
95
void ClockObject::set_frame_time(double time, Thread *current_thread = (get_current_thread()));

1394 15 set_frame_count 0 4 1819 28 ClockObject::set_frame_count 0 1 515 380
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_frame_count
//       Access: Published
//  Description: Resets the number of frames counted to the indicated
//               number.  Also see reset(), set_real_time(), and
//               set_frame_time().
////////////////////////////////////////////////////////////////////
100
void ClockObject::set_frame_count(int frame_count, Thread *current_thread = (get_current_thread()));

1395 15 get_frame_count 0 4 1819 28 ClockObject::get_frame_count 0 1 516 457
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_frame_count
//       Access: Published
//  Description: Returns the number of times tick() has been called
//               since the ClockObject was created, or since it was
//               last reset.  This is generally the number of frames
//               that have been rendered.
////////////////////////////////////////////////////////////////////
95
inline int ClockObject::get_frame_count(Thread *current_thread = (get_current_thread())) const;

1396 18 get_net_frame_rate 0 4 1819 31 ClockObject::get_net_frame_rate 0 1 517 523
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_net_frame_rate
//       Access: Published
//  Description: Returns the average frame rate since the last reset.
//               This is simply the total number of frames divided by
//               the total elapsed time.  This reports the virtual
//               frame rate if the clock is in (or has been in)
//               M_non_real_time mode.
////////////////////////////////////////////////////////////////////
101
inline double ClockObject::get_net_frame_rate(Thread *current_thread = (get_current_thread())) const;

1397 6 get_dt 0 4 1819 19 ClockObject::get_dt 0 1 518 369
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_dt
//       Access: Published
//  Description: Returns the elapsed time for the previous frame: the
//               number of seconds elapsed between the last two calls
//               to tick().
////////////////////////////////////////////////////////////////////
89
inline double ClockObject::get_dt(Thread *current_thread = (get_current_thread())) const;

1398 6 set_dt 0 4 1819 19 ClockObject::set_dt 0 1 519 575
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_dt
//       Access: Published
//  Description: In non-real-time mode, sets the number of seconds
//               that should appear to elapse between frames.  In
//               forced mode or limited mode, sets our target dt.  In
//               normal mode, this has no effect.  
//
//               Also see set_frame_rate(), which is a different way
//               to specify the same quantity.
////////////////////////////////////////////////////////////////////
36
void ClockObject::set_dt(double dt);

1399 14 set_frame_rate 0 4 1819 27 ClockObject::set_frame_rate 0 1 520 583
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_frame_rate
//       Access: Published
//  Description: In non-real-time mode, sets the number of frames per
//               second that we should appear to be running.  In forced
//               mode or limited mode, sets our target frame rate.  In
//               normal mode, this has no effect.
//
//               Also see set_dt(), which is a different way to
//               specify the same quantity.
////////////////////////////////////////////////////////////////////
52
void ClockObject::set_frame_rate(double frame_rate);

1400 10 get_max_dt 0 4 1819 23 ClockObject::get_max_dt 0 1 521 333
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_max_dt
//       Access: Published
//  Description: Returns the current maximum allowable time elapsed
//               between any two frames.  See set_max_dt().
////////////////////////////////////////////////////////////////////
50
inline double ClockObject::get_max_dt(void) const;

1401 10 set_max_dt 0 4 1819 23 ClockObject::set_max_dt 0 1 522 872
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_max_dt
//       Access: Published
//  Description: Sets a limit on the value returned by get_dt().  If
//               this value is less than zero, no limit is imposed;
//               otherwise, this is the maximum value that will ever
//               be returned by get_dt(), regardless of how much time
//               has actually elapsed between frames.
//
//               This limit is only imposed in real-time mode; in
//               non-real-time mode, the dt is fixed anyway and max_dt
//               is ignored.
//
//               This is generally used to guarantee reasonable
//               behavior even in the presence of a very slow or
//               chuggy frame rame.
////////////////////////////////////////////////////////////////////
51
inline void ClockObject::set_max_dt(double max_dt);

1402 18 get_degrade_factor 0 4 1819 31 ClockObject::get_degrade_factor 0 1 523 544
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_degrade_factor
//       Access: Published
//  Description: In degrade mode, returns the ratio by which the
//               performance is degraded.  A value of 2.0 causes the
//               clock to be slowed down by a factor of two (reducing
//               performance to 1/2 what would be otherwise).
//
//               This has no effect if mode is not M_degrade.
////////////////////////////////////////////////////////////////////
58
inline double ClockObject::get_degrade_factor(void) const;

1403 18 set_degrade_factor 0 4 1819 31 ClockObject::set_degrade_factor 0 1 524 541
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_degrade_factor
//       Access: Published
//  Description: In degrade mode, sets the ratio by which the
//               performance is degraded.  A value of 2.0 causes the
//               clock to be slowed down by a factor of two (reducing
//               performance to 1/2 what would be otherwise).
//
//               This has no effect if mode is not M_degrade.
////////////////////////////////////////////////////////////////////
67
inline void ClockObject::set_degrade_factor(double degrade_factor);

1404 31 set_average_frame_rate_interval 0 4 1819 44 ClockObject::set_average_frame_rate_interval 0 1 525 729
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_average_frame_rate_interval
//       Access: Published
//  Description: Specifies the interval of time (in seconds) over
//               which get_average_frame_rate() averages the number of
//               frames per second to compute the frame rate.
//               Changing this does not necessarily immediately change
//               the result of get_average_frame_rate(), until this
//               interval of time has elapsed again.
//
//               Setting this to zero disables the computation of
//               get_average_frame_rate().
////////////////////////////////////////////////////////////////////
70
inline void ClockObject::set_average_frame_rate_interval(double time);

1405 31 get_average_frame_rate_interval 0 4 1819 44 ClockObject::get_average_frame_rate_interval 0 1 526 423
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_average_frame_rate_interval
//       Access: Published
//  Description: Returns the interval of time (in seconds) over
//               which get_average_frame_rate() averages the number of frames
//               per second to compute the frame rate.
////////////////////////////////////////////////////////////////////
71
inline double ClockObject::get_average_frame_rate_interval(void) const;

1406 22 get_average_frame_rate 0 4 1819 35 ClockObject::get_average_frame_rate 0 1 527 500
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_average_frame_rate
//       Access: Published
//  Description: Returns the average frame rate in number of frames
//               per second over the last
//               get_average_frame_rate_interval() seconds.  This
//               measures the virtual frame rate if the clock is in
//               M_non_real_time mode.
////////////////////////////////////////////////////////////////////
98
double ClockObject::get_average_frame_rate(Thread *current_thread = (get_current_thread())) const;

1407 22 get_max_frame_duration 0 4 1819 35 ClockObject::get_max_frame_duration 0 1 528 343
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_max_frame_duration
//       Access: Published
//  Description: Returns the maximum frame duration over the last
//               get_average_frame_rate_interval() seconds.
////////////////////////////////////////////////////////////////////
98
double ClockObject::get_max_frame_duration(Thread *current_thread = (get_current_thread())) const;

1408 25 calc_frame_rate_deviation 0 4 1819 38 ClockObject::calc_frame_rate_deviation 0 1 529 915
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::calc_frame_time_deviation
//       Access: Published
//  Description: Returns the standard deviation of the frame times of
//               the frames rendered over the past
//               get_average_frame_rate_interval() seconds.  This
//               number gives an estimate of the chugginess of the
//               frame rate; if it is large, there is a large
//               variation in the frame rate; if is small, all of the
//               frames are consistent in length.
//
//               A large value might also represent just a recent
//               change in frame rate, for instance, because the
//               camera has just rotated from looking at a simple
//               scene to looking at a more complex scene.
////////////////////////////////////////////////////////////////////
101
double ClockObject::calc_frame_rate_deviation(Thread *current_thread = (get_current_thread())) const;

1409 4 tick 0 4 1819 17 ClockObject::tick 0 1 530 566
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::tick
//       Access: Published
//  Description: Instructs the clock that a new frame has just begun.
//               In normal, real-time mode, get_frame_time() will
//               henceforth report the time as of this instant as the
//               current start-of-frame time.  In non-real-time mode,
//               get_frame_time() will be incremented by the value of
//               dt.
////////////////////////////////////////////////////////////////////
72
void ClockObject::tick(Thread *current_thread = (get_current_thread()));

1410 15 sync_frame_time 0 4 1819 28 ClockObject::sync_frame_time 0 1 531 756
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::sync_frame_time
//       Access: Published
//  Description: Resets the frame time to the current real time.  This
//               is similar to tick(), except that it does not advance
//               the frame counter and does not affect dt.  This is
//               intended to be used in the middle of a particularly
//               long frame to compensate for the time that has
//               already elapsed.
//
//               In non-real-time mode, this function has no effect
//               (because in this mode all frames take the same length
//               of time).
////////////////////////////////////////////////////////////////////
83
void ClockObject::sync_frame_time(Thread *current_thread = (get_current_thread()));

1411 12 check_errors 0 4 1819 25 ClockObject::check_errors 0 1 532 609
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::check_errors
//       Access: Published
//  Description: Returns true if a clock error was detected since the
//               last time check_errors() was called.  A clock error
//               means that something happened, an OS or BIOS bug, for
//               instance, that makes the current value of the clock
//               somewhat suspect, and an application may wish to
//               resynchronize with any external clocks.
////////////////////////////////////////////////////////////////////
62
inline bool ClockObject::check_errors(Thread *current_thread);

1412 16 get_global_clock 0 4 1819 29 ClockObject::get_global_clock 0 1 533 408
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_global_clock
//       Access: Published
//  Description: Returns a pointer to the global ClockObject.  This is
//               the ClockObject that most code should use for
//               handling scene graph rendering and animation.
////////////////////////////////////////////////////////////////////
63
static inline ClockObject *ClockObject::get_global_clock(void);

1413 14 get_class_type 0 4 1819 27 ClockObject::get_class_type 0 1 534 0
52
static TypeHandle ClockObject::get_class_type(void);

1414 24 parse_color_space_string 0 1 0 24 parse_color_space_string 0 1 883 0
55
ColorSpace parse_color_space_string(string const &str);

1415 18 format_color_space 0 1 0 18 format_color_space 0 1 884 0
41
string format_color_space(ColorSpace cs);

1416 14 get_model_path 0 1 0 14 get_model_path 0 1 885 0
47
ConfigVariableSearchPath &get_model_path(void);

1417 15 get_plugin_path 0 1 0 15 get_plugin_path 0 1 886 0
48
ConfigVariableSearchPath &get_plugin_path(void);

1418 9 cache_ref 0 4 1823 28 CopyOnWriteObject::cache_ref 0 1 535 279
////////////////////////////////////////////////////////////////////
//     Function: CopyOnWriteObject::cache_ref
//       Access: Published
//  Description: See CachedTypedWritableReferenceCount::cache_ref().
////////////////////////////////////////////////////////////////////
53
inline void CopyOnWriteObject::cache_ref(void) const;

1419 14 get_class_type 0 4 1823 33 CopyOnWriteObject::get_class_type 0 1 536 0
58
static TypeHandle CopyOnWriteObject::get_class_type(void);

1420 18 ~CopyOnWriteObject 0 4 1823 37 CopyOnWriteObject::~CopyOnWriteObject 0 0 0
44
CopyOnWriteObject::~CopyOnWriteObject(void);

1421 17 DatagramInputFile 0 4 1824 36 DatagramInputFile::DatagramInputFile 0 1 537 229
////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
50
inline DatagramInputFile::DatagramInputFile(void);

1422 4 open 0 4 1824 23 DatagramInputFile::open 0 3 538 539 540 1158
////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::open
//       Access: Published
//  Description: Opens the indicated filename for reading.  Returns
//               true on success, false on failure.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::open
//       Access: Published
//  Description: Opens the indicated filename for reading.  Returns
//               true on success, false on failure.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::open
//       Access: Published
//  Description: Starts reading from the indicated stream.  Returns
//               true on success, false on failure.  The
//               DatagramInputFile does not take ownership of the
//               stream; you are responsible for closing or deleting
//               it when you are done.
////////////////////////////////////////////////////////////////////
201
bool DatagramInputFile::open(FileReference const *file);
inline bool DatagramInputFile::open(Filename const &filename);
bool DatagramInputFile::open(istream &in, Filename const &filename = Filename());

1423 10 get_stream 0 4 1824 29 DatagramInputFile::get_stream 0 1 541 279
////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::get_stream
//       Access: Published
//  Description: Returns the istream represented by the input file.
////////////////////////////////////////////////////////////////////
52
inline istream &DatagramInputFile::get_stream(void);

1424 5 close 0 4 1824 24 DatagramInputFile::close 0 1 542 325
////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::close
//       Access: Published
//  Description: Closes the file.  This is also implicitly done when
//               the DatagramInputFile destructs.
////////////////////////////////////////////////////////////////////
36
void DatagramInputFile::close(void);

1425 11 read_header 0 4 1824 30 DatagramInputFile::read_header 0 1 543 535
////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::read_header
//       Access: Published
//  Description: Reads a sequence of bytes from the beginning of the
//               datagram file.  This may be called any number of
//               times after the file has been opened and before the
//               first datagram is read.  It may not be called once
//               the first datagram has been read.
////////////////////////////////////////////////////////////////////
70
bool DatagramInputFile::read_header(string &header, size_t num_bytes);

1426 13 DoubleBitMask 0 4 1826 45 DoubleBitMask< BitMaskNative >::DoubleBitMask 0 2 544 545 0
157
inline DoubleBitMask< BitMaskNative >::DoubleBitMask(void);
inline DoubleBitMask< BitMaskNative >::DoubleBitMask(DoubleBitMask< BitMaskNative > const &copy);

1427 10 operator = 0 4 1826 42 DoubleBitMask< BitMaskNative >::operator = 0 1 546 0
126
inline DoubleBitMask< BitMaskNative > &DoubleBitMask< BitMaskNative >::operator =(DoubleBitMask< BitMaskNative > const &copy);

1428 6 all_on 0 4 1826 38 DoubleBitMask< BitMaskNative >::all_on 0 1 547 0
90
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_on(void);

1429 7 all_off 0 4 1826 39 DoubleBitMask< BitMaskNative >::all_off 0 1 548 0
91
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_off(void);

1430 8 lower_on 0 4 1826 40 DoubleBitMask< BitMaskNative >::lower_on 0 1 549 0
99
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::lower_on(int on_bits);

1431 3 bit 0 4 1826 35 DoubleBitMask< BitMaskNative >::bit 0 1 550 0
92
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::bit(int index);

1432 5 range 0 4 1826 37 DoubleBitMask< BitMaskNative >::range 0 1 551 0
106
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::range(int low_bit, int size);

1433 14 ~DoubleBitMask 0 4 1826 46 DoubleBitMask< BitMaskNative >::~DoubleBitMask 0 0 0
60
inline DoubleBitMask< BitMaskNative >::~DoubleBitMask(void);

1434 16 has_max_num_bits 0 4 1826 48 DoubleBitMask< BitMaskNative >::has_max_num_bits 0 1 552 0
67
static bool DoubleBitMask< BitMaskNative >::has_max_num_bits(void);

1435 16 get_max_num_bits 0 4 1826 48 DoubleBitMask< BitMaskNative >::get_max_num_bits 0 1 553 0
66
static int DoubleBitMask< BitMaskNative >::get_max_num_bits(void);

1436 12 get_num_bits 0 4 1826 44 DoubleBitMask< BitMaskNative >::get_num_bits 0 1 554 0
62
static int DoubleBitMask< BitMaskNative >::get_num_bits(void);

1437 7 get_bit 0 4 1826 39 DoubleBitMask< BitMaskNative >::get_bit 0 1 555 0
69
inline bool DoubleBitMask< BitMaskNative >::get_bit(int index) const;

1438 7 set_bit 0 4 1826 39 DoubleBitMask< BitMaskNative >::set_bit 0 1 556 0
63
inline void DoubleBitMask< BitMaskNative >::set_bit(int index);

1439 9 clear_bit 0 4 1826 41 DoubleBitMask< BitMaskNative >::clear_bit 0 1 557 0
65
inline void DoubleBitMask< BitMaskNative >::clear_bit(int index);

1440 10 set_bit_to 0 4 1826 42 DoubleBitMask< BitMaskNative >::set_bit_to 0 1 558 0
78
inline void DoubleBitMask< BitMaskNative >::set_bit_to(int index, bool value);

1441 7 is_zero 0 4 1826 39 DoubleBitMask< BitMaskNative >::is_zero 0 1 559 0
64
inline bool DoubleBitMask< BitMaskNative >::is_zero(void) const;

1442 9 is_all_on 0 4 1826 41 DoubleBitMask< BitMaskNative >::is_all_on 0 1 560 0
66
inline bool DoubleBitMask< BitMaskNative >::is_all_on(void) const;

1443 7 extract 0 4 1826 39 DoubleBitMask< BitMaskNative >::extract 0 1 561 0
86
inline PN_uint64 DoubleBitMask< BitMaskNative >::extract(int low_bit, int size) const;

1444 5 store 0 4 1826 37 DoubleBitMask< BitMaskNative >::store 0 1 562 0
90
inline void DoubleBitMask< BitMaskNative >::store(PN_uint64 value, int low_bit, int size);

1445 10 has_any_of 0 4 1826 42 DoubleBitMask< BitMaskNative >::has_any_of 0 1 563 0
84
inline bool DoubleBitMask< BitMaskNative >::has_any_of(int low_bit, int size) const;

1446 10 has_all_of 0 4 1826 42 DoubleBitMask< BitMaskNative >::has_all_of 0 1 564 0
84
inline bool DoubleBitMask< BitMaskNative >::has_all_of(int low_bit, int size) const;

1447 9 set_range 0 4 1826 41 DoubleBitMask< BitMaskNative >::set_range 0 1 565 0
77
inline void DoubleBitMask< BitMaskNative >::set_range(int low_bit, int size);

1448 11 clear_range 0 4 1826 43 DoubleBitMask< BitMaskNative >::clear_range 0 1 566 0
79
inline void DoubleBitMask< BitMaskNative >::clear_range(int low_bit, int size);

1449 12 set_range_to 0 4 1826 44 DoubleBitMask< BitMaskNative >::set_range_to 0 1 567 0
92
inline void DoubleBitMask< BitMaskNative >::set_range_to(bool value, int low_bit, int size);

1450 15 get_num_on_bits 0 4 1826 47 DoubleBitMask< BitMaskNative >::get_num_on_bits 0 1 568 0
71
inline int DoubleBitMask< BitMaskNative >::get_num_on_bits(void) const;

1451 16 get_num_off_bits 0 4 1826 48 DoubleBitMask< BitMaskNative >::get_num_off_bits 0 1 569 0
72
inline int DoubleBitMask< BitMaskNative >::get_num_off_bits(void) const;

1452 17 get_lowest_on_bit 0 4 1826 49 DoubleBitMask< BitMaskNative >::get_lowest_on_bit 0 1 570 0
73
inline int DoubleBitMask< BitMaskNative >::get_lowest_on_bit(void) const;

1453 18 get_lowest_off_bit 0 4 1826 50 DoubleBitMask< BitMaskNative >::get_lowest_off_bit 0 1 571 0
74
inline int DoubleBitMask< BitMaskNative >::get_lowest_off_bit(void) const;

1454 18 get_highest_on_bit 0 4 1826 50 DoubleBitMask< BitMaskNative >::get_highest_on_bit 0 1 572 0
74
inline int DoubleBitMask< BitMaskNative >::get_highest_on_bit(void) const;

1455 19 get_highest_off_bit 0 4 1826 51 DoubleBitMask< BitMaskNative >::get_highest_off_bit 0 1 573 0
75
inline int DoubleBitMask< BitMaskNative >::get_highest_off_bit(void) const;

1456 29 get_next_higher_different_bit 0 4 1826 61 DoubleBitMask< BitMaskNative >::get_next_higher_different_bit 0 1 574 0
92
inline int DoubleBitMask< BitMaskNative >::get_next_higher_different_bit(int low_bit) const;

1457 15 invert_in_place 0 4 1826 47 DoubleBitMask< BitMaskNative >::invert_in_place 0 1 575 0
66
inline void DoubleBitMask< BitMaskNative >::invert_in_place(void);

1458 18 has_bits_in_common 0 4 1826 50 DoubleBitMask< BitMaskNative >::has_bits_in_common 0 1 576 0
114
inline bool DoubleBitMask< BitMaskNative >::has_bits_in_common(DoubleBitMask< BitMaskNative > const &other) const;

1459 5 clear 0 4 1826 37 DoubleBitMask< BitMaskNative >::clear 0 1 577 0
56
inline void DoubleBitMask< BitMaskNative >::clear(void);

1460 6 output 0 4 1826 38 DoubleBitMask< BitMaskNative >::output 0 1 578 0
64
void DoubleBitMask< BitMaskNative >::output(ostream &out) const;

1461 13 output_binary 0 4 1826 45 DoubleBitMask< BitMaskNative >::output_binary 0 1 579 0
93
void DoubleBitMask< BitMaskNative >::output_binary(ostream &out, int spaces_every = 4) const;

1462 10 output_hex 0 4 1826 42 DoubleBitMask< BitMaskNative >::output_hex 0 1 580 0
90
void DoubleBitMask< BitMaskNative >::output_hex(ostream &out, int spaces_every = 4) const;

1463 5 write 0 4 1826 37 DoubleBitMask< BitMaskNative >::write 0 1 581 0
85
void DoubleBitMask< BitMaskNative >::write(ostream &out, int indent_level = 0) const;

1464 11 operator == 0 4 1826 43 DoubleBitMask< BitMaskNative >::operator == 0 1 582 0
107
inline bool DoubleBitMask< BitMaskNative >::operator ==(DoubleBitMask< BitMaskNative > const &other) const;

1465 11 operator != 0 4 1826 43 DoubleBitMask< BitMaskNative >::operator != 0 1 583 0
107
inline bool DoubleBitMask< BitMaskNative >::operator !=(DoubleBitMask< BitMaskNative > const &other) const;

1466 10 operator < 0 4 1826 42 DoubleBitMask< BitMaskNative >::operator < 0 1 584 0
106
inline bool DoubleBitMask< BitMaskNative >::operator <(DoubleBitMask< BitMaskNative > const &other) const;

1467 10 compare_to 0 4 1826 42 DoubleBitMask< BitMaskNative >::compare_to 0 1 585 0
105
inline int DoubleBitMask< BitMaskNative >::compare_to(DoubleBitMask< BitMaskNative > const &other) const;

1468 10 operator & 0 4 1826 42 DoubleBitMask< BitMaskNative >::operator & 0 1 586 0
132
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator &(DoubleBitMask< BitMaskNative > const &other) const;

1469 10 operator | 0 4 1826 42 DoubleBitMask< BitMaskNative >::operator | 0 1 587 0
132
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator |(DoubleBitMask< BitMaskNative > const &other) const;

1470 10 operator ^ 0 4 1826 42 DoubleBitMask< BitMaskNative >::operator ^ 0 1 588 0
132
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator ^(DoubleBitMask< BitMaskNative > const &other) const;

1471 10 operator ~ 0 68 1826 42 DoubleBitMask< BitMaskNative >::operator ~ 0 1 589 0
93
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator ~(void) const;

1472 11 operator << 0 4 1826 43 DoubleBitMask< BitMaskNative >::operator << 0 1 590 0
99
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator <<(int shift) const;

1473 11 operator >> 0 4 1826 43 DoubleBitMask< BitMaskNative >::operator >> 0 1 591 0
99
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator >>(int shift) const;

1474 11 operator &= 0 4 1826 43 DoubleBitMask< BitMaskNative >::operator &= 0 1 592 0
101
inline void DoubleBitMask< BitMaskNative >::operator &=(DoubleBitMask< BitMaskNative > const &other);

1475 11 operator |= 0 4 1826 43 DoubleBitMask< BitMaskNative >::operator |= 0 1 593 0
101
inline void DoubleBitMask< BitMaskNative >::operator |=(DoubleBitMask< BitMaskNative > const &other);

1476 11 operator ^= 0 4 1826 43 DoubleBitMask< BitMaskNative >::operator ^= 0 1 594 0
101
inline void DoubleBitMask< BitMaskNative >::operator ^=(DoubleBitMask< BitMaskNative > const &other);

1477 12 operator <<= 0 4 1826 44 DoubleBitMask< BitMaskNative >::operator <<= 0 1 595 0
68
inline void DoubleBitMask< BitMaskNative >::operator <<=(int shift);

1478 12 operator >>= 0 4 1826 44 DoubleBitMask< BitMaskNative >::operator >>= 0 1 596 0
68
inline void DoubleBitMask< BitMaskNative >::operator >>=(int shift);

1479 14 get_class_type 0 4 1826 46 DoubleBitMask< BitMaskNative >::get_class_type 0 1 597 0
71
static TypeHandle DoubleBitMask< BitMaskNative >::get_class_type(void);

1480 13 DoubleBitMask 0 4 1828 51 DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask 0 2 598 599 0
175
inline DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(void);
inline DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(DoubleBitMask< DoubleBitMaskNative > const &copy);

1481 10 operator = 0 4 1828 48 DoubleBitMask< DoubleBitMaskNative >::operator = 0 1 600 0
144
inline DoubleBitMask< DoubleBitMaskNative > &DoubleBitMask< DoubleBitMaskNative >::operator =(DoubleBitMask< DoubleBitMaskNative > const &copy);

1482 6 all_on 0 4 1828 44 DoubleBitMask< DoubleBitMaskNative >::all_on 0 1 601 0
102
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_on(void);

1483 7 all_off 0 4 1828 45 DoubleBitMask< DoubleBitMaskNative >::all_off 0 1 602 0
103
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_off(void);

1484 8 lower_on 0 4 1828 46 DoubleBitMask< DoubleBitMaskNative >::lower_on 0 1 603 0
111
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::lower_on(int on_bits);

1485 3 bit 0 4 1828 41 DoubleBitMask< DoubleBitMaskNative >::bit 0 1 604 0
104
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::bit(int index);

1486 5 range 0 4 1828 43 DoubleBitMask< DoubleBitMaskNative >::range 0 1 605 0
118
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::range(int low_bit, int size);

1487 14 ~DoubleBitMask 0 4 1828 52 DoubleBitMask< DoubleBitMaskNative >::~DoubleBitMask 0 0 0
66
inline DoubleBitMask< DoubleBitMaskNative >::~DoubleBitMask(void);

1488 16 has_max_num_bits 0 4 1828 54 DoubleBitMask< DoubleBitMaskNative >::has_max_num_bits 0 1 606 0
73
static bool DoubleBitMask< DoubleBitMaskNative >::has_max_num_bits(void);

1489 16 get_max_num_bits 0 4 1828 54 DoubleBitMask< DoubleBitMaskNative >::get_max_num_bits 0 1 607 0
72
static int DoubleBitMask< DoubleBitMaskNative >::get_max_num_bits(void);

1490 12 get_num_bits 0 4 1828 50 DoubleBitMask< DoubleBitMaskNative >::get_num_bits 0 1 608 0
68
static int DoubleBitMask< DoubleBitMaskNative >::get_num_bits(void);

1491 7 get_bit 0 4 1828 45 DoubleBitMask< DoubleBitMaskNative >::get_bit 0 1 609 0
75
inline bool DoubleBitMask< DoubleBitMaskNative >::get_bit(int index) const;

1492 7 set_bit 0 4 1828 45 DoubleBitMask< DoubleBitMaskNative >::set_bit 0 1 610 0
69
inline void DoubleBitMask< DoubleBitMaskNative >::set_bit(int index);

1493 9 clear_bit 0 4 1828 47 DoubleBitMask< DoubleBitMaskNative >::clear_bit 0 1 611 0
71
inline void DoubleBitMask< DoubleBitMaskNative >::clear_bit(int index);

1494 10 set_bit_to 0 4 1828 48 DoubleBitMask< DoubleBitMaskNative >::set_bit_to 0 1 612 0
84
inline void DoubleBitMask< DoubleBitMaskNative >::set_bit_to(int index, bool value);

1495 7 is_zero 0 4 1828 45 DoubleBitMask< DoubleBitMaskNative >::is_zero 0 1 613 0
70
inline bool DoubleBitMask< DoubleBitMaskNative >::is_zero(void) const;

1496 9 is_all_on 0 4 1828 47 DoubleBitMask< DoubleBitMaskNative >::is_all_on 0 1 614 0
72
inline bool DoubleBitMask< DoubleBitMaskNative >::is_all_on(void) const;

1497 7 extract 0 4 1828 45 DoubleBitMask< DoubleBitMaskNative >::extract 0 1 615 0
92
inline PN_uint64 DoubleBitMask< DoubleBitMaskNative >::extract(int low_bit, int size) const;

1498 5 store 0 4 1828 43 DoubleBitMask< DoubleBitMaskNative >::store 0 1 616 0
96
inline void DoubleBitMask< DoubleBitMaskNative >::store(PN_uint64 value, int low_bit, int size);

1499 10 has_any_of 0 4 1828 48 DoubleBitMask< DoubleBitMaskNative >::has_any_of 0 1 617 0
90
inline bool DoubleBitMask< DoubleBitMaskNative >::has_any_of(int low_bit, int size) const;

1500 10 has_all_of 0 4 1828 48 DoubleBitMask< DoubleBitMaskNative >::has_all_of 0 1 618 0
90
inline bool DoubleBitMask< DoubleBitMaskNative >::has_all_of(int low_bit, int size) const;

1501 9 set_range 0 4 1828 47 DoubleBitMask< DoubleBitMaskNative >::set_range 0 1 619 0
83
inline void DoubleBitMask< DoubleBitMaskNative >::set_range(int low_bit, int size);

1502 11 clear_range 0 4 1828 49 DoubleBitMask< DoubleBitMaskNative >::clear_range 0 1 620 0
85
inline void DoubleBitMask< DoubleBitMaskNative >::clear_range(int low_bit, int size);

1503 12 set_range_to 0 4 1828 50 DoubleBitMask< DoubleBitMaskNative >::set_range_to 0 1 621 0
98
inline void DoubleBitMask< DoubleBitMaskNative >::set_range_to(bool value, int low_bit, int size);

1504 15 get_num_on_bits 0 4 1828 53 DoubleBitMask< DoubleBitMaskNative >::get_num_on_bits 0 1 622 0
77
inline int DoubleBitMask< DoubleBitMaskNative >::get_num_on_bits(void) const;

1505 16 get_num_off_bits 0 4 1828 54 DoubleBitMask< DoubleBitMaskNative >::get_num_off_bits 0 1 623 0
78
inline int DoubleBitMask< DoubleBitMaskNative >::get_num_off_bits(void) const;

1506 17 get_lowest_on_bit 0 4 1828 55 DoubleBitMask< DoubleBitMaskNative >::get_lowest_on_bit 0 1 624 0
79
inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_on_bit(void) const;

1507 18 get_lowest_off_bit 0 4 1828 56 DoubleBitMask< DoubleBitMaskNative >::get_lowest_off_bit 0 1 625 0
80
inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_off_bit(void) const;

1508 18 get_highest_on_bit 0 4 1828 56 DoubleBitMask< DoubleBitMaskNative >::get_highest_on_bit 0 1 626 0
80
inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_on_bit(void) const;

1509 19 get_highest_off_bit 0 4 1828 57 DoubleBitMask< DoubleBitMaskNative >::get_highest_off_bit 0 1 627 0
81
inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_off_bit(void) const;

1510 29 get_next_higher_different_bit 0 4 1828 67 DoubleBitMask< DoubleBitMaskNative >::get_next_higher_different_bit 0 1 628 0
98
inline int DoubleBitMask< DoubleBitMaskNative >::get_next_higher_different_bit(int low_bit) const;

1511 15 invert_in_place 0 4 1828 53 DoubleBitMask< DoubleBitMaskNative >::invert_in_place 0 1 629 0
72
inline void DoubleBitMask< DoubleBitMaskNative >::invert_in_place(void);

1512 18 has_bits_in_common 0 4 1828 56 DoubleBitMask< DoubleBitMaskNative >::has_bits_in_common 0 1 630 0
126
inline bool DoubleBitMask< DoubleBitMaskNative >::has_bits_in_common(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1513 5 clear 0 4 1828 43 DoubleBitMask< DoubleBitMaskNative >::clear 0 1 631 0
62
inline void DoubleBitMask< DoubleBitMaskNative >::clear(void);

1514 6 output 0 4 1828 44 DoubleBitMask< DoubleBitMaskNative >::output 0 1 632 0
70
void DoubleBitMask< DoubleBitMaskNative >::output(ostream &out) const;

1515 13 output_binary 0 4 1828 51 DoubleBitMask< DoubleBitMaskNative >::output_binary 0 1 633 0
99
void DoubleBitMask< DoubleBitMaskNative >::output_binary(ostream &out, int spaces_every = 4) const;

1516 10 output_hex 0 4 1828 48 DoubleBitMask< DoubleBitMaskNative >::output_hex 0 1 634 0
96
void DoubleBitMask< DoubleBitMaskNative >::output_hex(ostream &out, int spaces_every = 4) const;

1517 5 write 0 4 1828 43 DoubleBitMask< DoubleBitMaskNative >::write 0 1 635 0
91
void DoubleBitMask< DoubleBitMaskNative >::write(ostream &out, int indent_level = 0) const;

1518 11 operator == 0 4 1828 49 DoubleBitMask< DoubleBitMaskNative >::operator == 0 1 636 0
119
inline bool DoubleBitMask< DoubleBitMaskNative >::operator ==(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1519 11 operator != 0 4 1828 49 DoubleBitMask< DoubleBitMaskNative >::operator != 0 1 637 0
119
inline bool DoubleBitMask< DoubleBitMaskNative >::operator !=(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1520 10 operator < 0 4 1828 48 DoubleBitMask< DoubleBitMaskNative >::operator < 0 1 638 0
118
inline bool DoubleBitMask< DoubleBitMaskNative >::operator <(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1521 10 compare_to 0 4 1828 48 DoubleBitMask< DoubleBitMaskNative >::compare_to 0 1 639 0
117
inline int DoubleBitMask< DoubleBitMaskNative >::compare_to(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1522 10 operator & 0 4 1828 48 DoubleBitMask< DoubleBitMaskNative >::operator & 0 1 640 0
150
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator &(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1523 10 operator | 0 4 1828 48 DoubleBitMask< DoubleBitMaskNative >::operator | 0 1 641 0
150
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator |(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1524 10 operator ^ 0 4 1828 48 DoubleBitMask< DoubleBitMaskNative >::operator ^ 0 1 642 0
150
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator ^(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1525 10 operator ~ 0 68 1828 48 DoubleBitMask< DoubleBitMaskNative >::operator ~ 0 1 643 0
105
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator ~(void) const;

1526 11 operator << 0 4 1828 49 DoubleBitMask< DoubleBitMaskNative >::operator << 0 1 644 0
111
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator <<(int shift) const;

1527 11 operator >> 0 4 1828 49 DoubleBitMask< DoubleBitMaskNative >::operator >> 0 1 645 0
111
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator >>(int shift) const;

1528 11 operator &= 0 4 1828 49 DoubleBitMask< DoubleBitMaskNative >::operator &= 0 1 646 0
113
inline void DoubleBitMask< DoubleBitMaskNative >::operator &=(DoubleBitMask< DoubleBitMaskNative > const &other);

1529 11 operator |= 0 4 1828 49 DoubleBitMask< DoubleBitMaskNative >::operator |= 0 1 647 0
113
inline void DoubleBitMask< DoubleBitMaskNative >::operator |=(DoubleBitMask< DoubleBitMaskNative > const &other);

1530 11 operator ^= 0 4 1828 49 DoubleBitMask< DoubleBitMaskNative >::operator ^= 0 1 648 0
113
inline void DoubleBitMask< DoubleBitMaskNative >::operator ^=(DoubleBitMask< DoubleBitMaskNative > const &other);

1531 12 operator <<= 0 4 1828 50 DoubleBitMask< DoubleBitMaskNative >::operator <<= 0 1 649 0
74
inline void DoubleBitMask< DoubleBitMaskNative >::operator <<=(int shift);

1532 12 operator >>= 0 4 1828 50 DoubleBitMask< DoubleBitMaskNative >::operator >>= 0 1 650 0
74
inline void DoubleBitMask< DoubleBitMaskNative >::operator >>=(int shift);

1533 14 get_class_type 0 4 1828 52 DoubleBitMask< DoubleBitMaskNative >::get_class_type 0 1 651 0
77
static TypeHandle DoubleBitMask< DoubleBitMaskNative >::get_class_type(void);

1534 9 ascii_key 0 4 1831 25 KeyboardButton::ascii_key 0 1 652 394
////////////////////////////////////////////////////////////////////
//     Function: KeyboardButton::ascii_key
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               particular ASCII character, if there is one, or
//               ButtonHandle::none() if there is not.
////////////////////////////////////////////////////////////////////
69
static ButtonHandle KeyboardButton::ascii_key(char ascii_equivalent);

1535 5 space 0 4 1831 21 KeyboardButton::space 0 1 653 0
48
static ButtonHandle KeyboardButton::space(void);

1536 9 backspace 0 4 1831 25 KeyboardButton::backspace 0 1 654 0
52
static ButtonHandle KeyboardButton::backspace(void);

1537 3 tab 0 4 1831 19 KeyboardButton::tab 0 1 655 0
46
static ButtonHandle KeyboardButton::tab(void);

1538 5 enter 0 4 1831 21 KeyboardButton::enter 0 1 656 0
48
static ButtonHandle KeyboardButton::enter(void);

1539 6 escape 0 4 1831 22 KeyboardButton::escape 0 1 657 0
49
static ButtonHandle KeyboardButton::escape(void);

1540 2 f1 0 4 1831 18 KeyboardButton::f1 0 1 658 0
45
static ButtonHandle KeyboardButton::f1(void);

1541 2 f2 0 4 1831 18 KeyboardButton::f2 0 1 659 0
45
static ButtonHandle KeyboardButton::f2(void);

1542 2 f3 0 4 1831 18 KeyboardButton::f3 0 1 660 0
45
static ButtonHandle KeyboardButton::f3(void);

1543 2 f4 0 4 1831 18 KeyboardButton::f4 0 1 661 0
45
static ButtonHandle KeyboardButton::f4(void);

1544 2 f5 0 4 1831 18 KeyboardButton::f5 0 1 662 0
45
static ButtonHandle KeyboardButton::f5(void);

1545 2 f6 0 4 1831 18 KeyboardButton::f6 0 1 663 0
45
static ButtonHandle KeyboardButton::f6(void);

1546 2 f7 0 4 1831 18 KeyboardButton::f7 0 1 664 0
45
static ButtonHandle KeyboardButton::f7(void);

1547 2 f8 0 4 1831 18 KeyboardButton::f8 0 1 665 0
45
static ButtonHandle KeyboardButton::f8(void);

1548 2 f9 0 4 1831 18 KeyboardButton::f9 0 1 666 0
45
static ButtonHandle KeyboardButton::f9(void);

1549 3 f10 0 4 1831 19 KeyboardButton::f10 0 1 667 0
46
static ButtonHandle KeyboardButton::f10(void);

1550 3 f11 0 4 1831 19 KeyboardButton::f11 0 1 668 0
46
static ButtonHandle KeyboardButton::f11(void);

1551 3 f12 0 4 1831 19 KeyboardButton::f12 0 1 669 0
46
static ButtonHandle KeyboardButton::f12(void);

1552 3 f13 0 4 1831 19 KeyboardButton::f13 0 1 670 59
// PC keyboards don't have these four buttons, but Macs do.
46
static ButtonHandle KeyboardButton::f13(void);

1553 3 f14 0 4 1831 19 KeyboardButton::f14 0 1 671 0
46
static ButtonHandle KeyboardButton::f14(void);

1554 3 f15 0 4 1831 19 KeyboardButton::f15 0 1 672 0
46
static ButtonHandle KeyboardButton::f15(void);

1555 3 f16 0 4 1831 19 KeyboardButton::f16 0 1 673 0
46
static ButtonHandle KeyboardButton::f16(void);

1556 4 left 0 4 1831 20 KeyboardButton::left 0 1 674 0
47
static ButtonHandle KeyboardButton::left(void);

1557 5 right 0 4 1831 21 KeyboardButton::right 0 1 675 0
48
static ButtonHandle KeyboardButton::right(void);

1558 2 up 0 4 1831 18 KeyboardButton::up 0 1 676 0
45
static ButtonHandle KeyboardButton::up(void);

1559 4 down 0 4 1831 20 KeyboardButton::down 0 1 677 0
47
static ButtonHandle KeyboardButton::down(void);

1560 7 page_up 0 4 1831 23 KeyboardButton::page_up 0 1 678 0
50
static ButtonHandle KeyboardButton::page_up(void);

1561 9 page_down 0 4 1831 25 KeyboardButton::page_down 0 1 679 0
52
static ButtonHandle KeyboardButton::page_down(void);

1562 4 home 0 4 1831 20 KeyboardButton::home 0 1 680 0
47
static ButtonHandle KeyboardButton::home(void);

1563 3 end 0 4 1831 19 KeyboardButton::end 0 1 681 0
46
static ButtonHandle KeyboardButton::end(void);

1564 6 insert 0 4 1831 22 KeyboardButton::insert 0 1 682 0
49
static ButtonHandle KeyboardButton::insert(void);

1565 3 del 0 4 1831 19 KeyboardButton::del 0 1 683 27
// delete is a C++ keyword.
46
static ButtonHandle KeyboardButton::del(void);

1566 4 help 0 4 1831 20 KeyboardButton::help 0 1 684 27
// delete is a C++ keyword.
47
static ButtonHandle KeyboardButton::help(void);

1567 4 menu 0 4 1831 20 KeyboardButton::menu 0 1 685 0
47
static ButtonHandle KeyboardButton::menu(void);

1568 5 shift 0 4 1831 21 KeyboardButton::shift 0 1 686 0
48
static ButtonHandle KeyboardButton::shift(void);

1569 7 control 0 4 1831 23 KeyboardButton::control 0 1 687 0
50
static ButtonHandle KeyboardButton::control(void);

1570 3 alt 0 4 1831 19 KeyboardButton::alt 0 1 688 0
46
static ButtonHandle KeyboardButton::alt(void);

1571 4 meta 0 4 1831 20 KeyboardButton::meta 0 1 689 0
47
static ButtonHandle KeyboardButton::meta(void);

1572 9 caps_lock 0 4 1831 25 KeyboardButton::caps_lock 0 1 690 0
52
static ButtonHandle KeyboardButton::caps_lock(void);

1573 10 shift_lock 0 4 1831 26 KeyboardButton::shift_lock 0 1 691 0
53
static ButtonHandle KeyboardButton::shift_lock(void);

1574 8 num_lock 0 4 1831 24 KeyboardButton::num_lock 0 1 692 0
51
static ButtonHandle KeyboardButton::num_lock(void);

1575 11 scroll_lock 0 4 1831 27 KeyboardButton::scroll_lock 0 1 693 0
54
static ButtonHandle KeyboardButton::scroll_lock(void);

1576 12 print_screen 0 4 1831 28 KeyboardButton::print_screen 0 1 694 0
55
static ButtonHandle KeyboardButton::print_screen(void);

1577 5 pause 0 4 1831 21 KeyboardButton::pause 0 1 695 0
48
static ButtonHandle KeyboardButton::pause(void);

1578 6 lshift 0 4 1831 22 KeyboardButton::lshift 0 1 696 0
49
static ButtonHandle KeyboardButton::lshift(void);

1579 6 rshift 0 4 1831 22 KeyboardButton::rshift 0 1 697 0
49
static ButtonHandle KeyboardButton::rshift(void);

1580 8 lcontrol 0 4 1831 24 KeyboardButton::lcontrol 0 1 698 0
51
static ButtonHandle KeyboardButton::lcontrol(void);

1581 8 rcontrol 0 4 1831 24 KeyboardButton::rcontrol 0 1 699 0
51
static ButtonHandle KeyboardButton::rcontrol(void);

1582 4 lalt 0 4 1831 20 KeyboardButton::lalt 0 1 700 0
47
static ButtonHandle KeyboardButton::lalt(void);

1583 4 ralt 0 4 1831 20 KeyboardButton::ralt 0 1 701 0
47
static ButtonHandle KeyboardButton::ralt(void);

1584 5 lmeta 0 4 1831 21 KeyboardButton::lmeta 0 1 702 0
48
static ButtonHandle KeyboardButton::lmeta(void);

1585 5 rmeta 0 4 1831 21 KeyboardButton::rmeta 0 1 703 0
48
static ButtonHandle KeyboardButton::rmeta(void);

1586 15 ~KeyboardButton 0 4 1831 31 KeyboardButton::~KeyboardButton 0 0 0
38
KeyboardButton::~KeyboardButton(void);

1587 13 load_prc_file 0 1 0 13 load_prc_file 0 1 887 1916
////////////////////////////////////////////////////////////////////
//     Function: load_prc_file
//  Description: A convenience function for loading explicit prc files
//               from a disk file or from within a multifile (via the
//               virtual file system).  Save the return value and pass
//               it to unload_prc_file() if you ever want to unload
//               this file later.
//
//               The filename is first searched along the default prc
//               search path, and then also along the model path, for
//               convenience.
//
//               This function is defined in putil instead of in dtool
//               with the read of the prc stuff, so that it can take
//               advantage of the virtual file system (which is
//               defined in express), and the model path (which is in
//               putil).
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: load_prc_file
//  Description: A convenience function for loading explicit prc files
//               from a disk file or from within a multifile (via the
//               virtual file system).  Save the return value and pass
//               it to unload_prc_file() if you ever want to unload
//               this file later.
//
//               The filename is first searched along the default prc
//               search path, and then also along the model path, for
//               convenience.
//
//               This function is defined in putil instead of in dtool
//               with the read of the prc stuff, so that it can take
//               advantage of the virtual file system (which is
//               defined in express), and the model path (which is in
//               putil).
////////////////////////////////////////////////////////////////////
52
ConfigPage *load_prc_file(Filename const &filename);

1588 18 load_prc_file_data 0 1 0 18 load_prc_file_data 0 1 888 1362
////////////////////////////////////////////////////////////////////
//     Function: load_prc_file_data
//  Description: Another convenience function to load a prc file from
//               an explicit string, which represents the contents of
//               the prc file.
//
//               The first parameter is an arbitrary name to assign to
//               this in-memory prc file.  Supply a filename if the
//               data was read from a file, or use any other name that
//               is meaningful to you.  The name is only used when the
//               set of loaded prc files is listed.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: load_prc_file_data
//  Description: Another convenience function to load a prc file from
//               an explicit string, which represents the contents of
//               the prc file.
//
//               The first parameter is an arbitrary name to assign to
//               this in-memory prc file.  Supply a filename if the
//               data was read from a file, or use any other name that
//               is meaningful to you.  The name is only used when the
//               set of loaded prc files is listed.
////////////////////////////////////////////////////////////////////
71
ConfigPage *load_prc_file_data(string const &name, string const &data);

1589 15 unload_prc_file 0 1 0 15 unload_prc_file 0 1 889 0
39
bool unload_prc_file(ConfigPage *page);

1590 18 hash_prc_variables 0 1 0 18 hash_prc_variables 0 1 890 0
39
void hash_prc_variables(HashVal &hash);

1591 15 ModifierButtons 0 4 1832 32 ModifierButtons::ModifierButtons 0 2 704 705 461
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
102
ModifierButtons::ModifierButtons(void);
ModifierButtons::ModifierButtons(ModifierButtons const &copy);

1592 16 ~ModifierButtons 0 4 1832 33 ModifierButtons::~ModifierButtons 0 0 226
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
40
ModifierButtons::~ModifierButtons(void);

1593 10 operator = 0 4 1832 27 ModifierButtons::operator = 0 1 706 0
69
inline void ModifierButtons::operator =(ModifierButtons const &copy);

1594 11 operator == 0 4 1832 28 ModifierButtons::operator == 0 1 707 0
77
inline bool ModifierButtons::operator ==(ModifierButtons const &other) const;

1595 11 operator != 0 4 1832 28 ModifierButtons::operator != 0 1 708 0
77
inline bool ModifierButtons::operator !=(ModifierButtons const &other) const;

1596 10 operator < 0 4 1832 27 ModifierButtons::operator < 0 1 709 0
76
inline bool ModifierButtons::operator <(ModifierButtons const &other) const;

1597 10 operator & 0 4 1832 27 ModifierButtons::operator & 0 1 710 0
87
inline ModifierButtons ModifierButtons::operator &(ModifierButtons const &other) const;

1598 10 operator | 0 4 1832 27 ModifierButtons::operator | 0 1 711 0
87
inline ModifierButtons ModifierButtons::operator |(ModifierButtons const &other) const;

1599 11 operator &= 0 4 1832 28 ModifierButtons::operator &= 0 1 712 0
64
void ModifierButtons::operator &=(ModifierButtons const &other);

1600 11 operator |= 0 4 1832 28 ModifierButtons::operator |= 0 1 713 0
64
void ModifierButtons::operator |=(ModifierButtons const &other);

1601 15 set_button_list 0 4 1832 32 ModifierButtons::set_button_list 0 1 714 698
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::set_button_list
//       Access: Published
//  Description: Sets the list of buttons to watch to be the same as
//               that of the other ModifierButtons object.  This makes
//               the lists pointer equivalent (until one or the other
//               is later modified).
//
//               This will preserve the state of any button that was
//               on the original list and is also on the new lists.
//               Any other buttons will get reset to the default state
//               of "up".
////////////////////////////////////////////////////////////////////
68
void ModifierButtons::set_button_list(ModifierButtons const &other);

1602 7 matches 0 4 1832 24 ModifierButtons::matches 0 1 715 504
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::matches
//       Access: Published
//  Description: Returns true if the set of buttons indicated as down
//               by this ModifierButtons object is the same set of
//               buttons indicated as down by the other
//               ModifierButtons object.  The buttons indicated as up
//               are not relevant.
////////////////////////////////////////////////////////////////////
66
bool ModifierButtons::matches(ModifierButtons const &other) const;

1603 10 add_button 0 4 1832 27 ModifierButtons::add_button 0 1 716 523
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::add_button
//       Access: Published
//  Description: Adds the indicated button to the set of buttons that
//               will be monitored for upness and downness.  Returns
//               true if the button was added, false if it was already
//               being monitored or if too many buttons are currently
//               being monitored.
////////////////////////////////////////////////////////////////////
54
bool ModifierButtons::add_button(ButtonHandle button);

1604 10 has_button 0 4 1832 27 ModifierButtons::has_button 0 1 717 339
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::has_button
//       Access: Published
//  Description: Returns true if the indicated button is in the set of
//               buttons being monitored, false otherwise.
////////////////////////////////////////////////////////////////////
60
bool ModifierButtons::has_button(ButtonHandle button) const;

1605 13 remove_button 0 4 1832 30 ModifierButtons::remove_button 0 1 718 623
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::remove_button
//       Access: Published
//  Description: Removes the indicated button from the set of buttons
//               being monitored.  Returns true if the button was
//               removed, false if it was not being monitored in the
//               first place.
//
//               Unlike the other methods, you cannot remove a button
//               by removing its alias; you have to remove exactly the
//               button itself.
////////////////////////////////////////////////////////////////////
57
bool ModifierButtons::remove_button(ButtonHandle button);

1606 15 get_num_buttons 0 4 1832 32 ModifierButtons::get_num_buttons 0 1 719 394
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::get_num_buttons
//       Access: Published
//  Description: Returns the number of buttons that the
//               ModifierButtons object is monitoring (e.g. the number
//               of buttons passed to add_button()).
////////////////////////////////////////////////////////////////////
56
inline int ModifierButtons::get_num_buttons(void) const;

1607 10 get_button 0 4 1832 27 ModifierButtons::get_button 0 1 720 446
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::get_button
//       Access: Published
//  Description: Returns the nth button that the ModifierButtons
//               object is monitoring (the nth button passed to
//               add_button()).  This must be in the range 0 <= index
//               < get_num_buttons().
////////////////////////////////////////////////////////////////////
65
inline ButtonHandle ModifierButtons::get_button(int index) const;

1608 11 button_down 0 4 1832 28 ModifierButtons::button_down 0 1 721 597
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::button_down
//       Access: Published
//  Description: Records that a particular button has been pressed.
//               If the given button is one of the buttons that is
//               currently being monitored, this will update the
//               internal state appropriately; otherwise, it will do
//               nothing.  Returns true if the button is one that was
//               monitored, or false otherwise.
////////////////////////////////////////////////////////////////////
55
bool ModifierButtons::button_down(ButtonHandle button);

1609 9 button_up 0 4 1832 26 ModifierButtons::button_up 0 1 722 596
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::button_up
//       Access: Published
//  Description: Records that a particular button has been released.
//               If the given button is one of the buttons that is
//               currently being monitored, this will update the
//               internal state appropriately; otherwise, it will do
//               nothing.  Returns true if the button is one that was
//               monitored, or false otherwise.
////////////////////////////////////////////////////////////////////
53
bool ModifierButtons::button_up(ButtonHandle button);

1610 14 all_buttons_up 0 4 1832 31 ModifierButtons::all_buttons_up 0 1 723 303
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::all_buttons_up
//       Access: Published
//  Description: Marks all monitored buttons as being in the "up"
//               state.
////////////////////////////////////////////////////////////////////
50
inline void ModifierButtons::all_buttons_up(void);

1611 7 is_down 0 4 1832 24 ModifierButtons::is_down 0 2 724 725 735
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::is_down
//       Access: Published
//  Description: Returns true if the indicated button is known to be
//               down, or false if it is known to be up.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::is_down
//       Access: Published
//  Description: Returns true if the indicated button is known to be
//               down, or false if it is known to be up or if it is
//               not in the set of buttons being tracked.
////////////////////////////////////////////////////////////////////
112
bool ModifierButtons::is_down(ButtonHandle button) const;
inline bool ModifierButtons::is_down(int index) const;

1612 11 is_any_down 0 4 1832 28 ModifierButtons::is_any_down 0 1 726 340
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::is_any_down
//       Access: Published
//  Description: Returns true if any of the tracked button are known
//               to be down, or false if all of them are up.
////////////////////////////////////////////////////////////////////
53
inline bool ModifierButtons::is_any_down(void) const;

1613 10 get_prefix 0 4 1832 27 ModifierButtons::get_prefix 0 1 727 397
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::get_prefix
//       Access: Published
//  Description: Returns a string which can be used to prefix any
//               button name or event name with the unique set of
//               modifier buttons currently being held.
////////////////////////////////////////////////////////////////////
47
string ModifierButtons::get_prefix(void) const;

1614 6 output 0 4 1832 23 ModifierButtons::output 0 1 728 298
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::output
//       Access: Published
//  Description: Writes a one-line summary of the buttons known to be
//               down.
////////////////////////////////////////////////////////////////////
49
void ModifierButtons::output(ostream &out) const;

1615 5 write 0 4 1832 22 ModifierButtons::write 0 1 729 365
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::write
//       Access: Published
//  Description: Writes a multi-line summary including all of the
//               buttons being monitored and which ones are known to
//               be down.
////////////////////////////////////////////////////////////////////
48
void ModifierButtons::write(ostream &out) const;

1616 6 button 0 4 1833 19 MouseButton::button 0 1 730 424
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::button
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               particular numbered mouse button (zero-based), if
//               there is one, or ButtonHandle::none() if there is
//               not.
////////////////////////////////////////////////////////////////////
59
static ButtonHandle MouseButton::button(int button_number);

1617 3 one 0 4 1833 16 MouseButton::one 0 1 731 302
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::one
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               first mouse button.
////////////////////////////////////////////////////////////////////
43
static ButtonHandle MouseButton::one(void);

1618 3 two 0 4 1833 16 MouseButton::two 0 1 732 303
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::two
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               second mouse button.
////////////////////////////////////////////////////////////////////
43
static ButtonHandle MouseButton::two(void);

1619 5 three 0 4 1833 18 MouseButton::three 0 1 733 304
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::three
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               third mouse button.
////////////////////////////////////////////////////////////////////
45
static ButtonHandle MouseButton::three(void);

1620 4 four 0 4 1833 17 MouseButton::four 0 1 734 304
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::four
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               fourth mouse button.
////////////////////////////////////////////////////////////////////
44
static ButtonHandle MouseButton::four(void);

1621 4 five 0 4 1833 17 MouseButton::five 0 1 735 303
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::five
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               fifth mouse button.
////////////////////////////////////////////////////////////////////
44
static ButtonHandle MouseButton::five(void);

1622 8 wheel_up 0 4 1833 21 MouseButton::wheel_up 0 1 736 327
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_up
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               wheel is rolled one notch upwards.
////////////////////////////////////////////////////////////////////
48
static ButtonHandle MouseButton::wheel_up(void);

1623 10 wheel_down 0 4 1833 23 MouseButton::wheel_down 0 1 737 331
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_down
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               wheel is rolled one notch downwards.
////////////////////////////////////////////////////////////////////
50
static ButtonHandle MouseButton::wheel_down(void);

1624 10 wheel_left 0 4 1833 23 MouseButton::wheel_left 0 1 738 396
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_left
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               is scrolled to the left. Usually, you'll only
//               find the horizontal scroll on laptops.
////////////////////////////////////////////////////////////////////
50
static ButtonHandle MouseButton::wheel_left(void);

1625 11 wheel_right 0 4 1833 24 MouseButton::wheel_right 0 1 739 398
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_right
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               is scrolled to the right. Usually, you'll only
//               find the horizontal scroll on laptops.
////////////////////////////////////////////////////////////////////
51
static ButtonHandle MouseButton::wheel_right(void);

1626 15 is_mouse_button 0 4 1833 28 MouseButton::is_mouse_button 0 1 740 353
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::is_mouse_button
//       Access: Public, Static
//  Description: Returns true if the indicated ButtonHandle is a mouse
//               button, false if it is some other kind of button.
////////////////////////////////////////////////////////////////////
62
static bool MouseButton::is_mouse_button(ButtonHandle button);

1627 12 ~MouseButton 0 4 1833 25 MouseButton::~MouseButton 0 0 0
32
MouseButton::~MouseButton(void);

1628 9 MouseData 0 4 1834 20 MouseData::MouseData 0 2 741 742 449
////////////////////////////////////////////////////////////////////
//     Function: MouseData::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: MouseData::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
86
inline MouseData::MouseData(void);
inline MouseData::MouseData(MouseData const &copy);

1629 10 operator = 0 4 1834 21 MouseData::operator = 0 1 743 0
57
inline void MouseData::operator =(MouseData const &copy);

1630 5 get_x 0 4 1834 16 MouseData::get_x 0 1 744 215
////////////////////////////////////////////////////////////////////
//     Function: MouseData::get_x
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
43
inline double MouseData::get_x(void) const;

1631 5 get_y 0 4 1834 16 MouseData::get_y 0 1 745 215
////////////////////////////////////////////////////////////////////
//     Function: MouseData::get_y
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
43
inline double MouseData::get_y(void) const;

1632 13 get_in_window 0 4 1834 24 MouseData::get_in_window 0 1 746 223
////////////////////////////////////////////////////////////////////
//     Function: MouseData::get_in_window
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
49
inline bool MouseData::get_in_window(void) const;

1633 6 output 0 4 1834 17 MouseData::output 0 1 747 216
////////////////////////////////////////////////////////////////////
//     Function: MouseData::output
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
43
void MouseData::output(ostream &out) const;

1634 10 ~MouseData 0 4 1834 21 MouseData::~MouseData 0 0 0
28
MouseData::~MouseData(void);

1635 18 get_node_ref_count 0 4 1835 44 NodeCachedReferenceCount::get_node_ref_count 0 1 748 280
////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::get_node_ref_count
//       Access: Published
//  Description: Returns the current reference count.
////////////////////////////////////////////////////////////////////
68
inline int NodeCachedReferenceCount::get_node_ref_count(void) const;

1636 8 node_ref 0 4 1835 34 NodeCachedReferenceCount::node_ref 0 1 749 662
////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::node_ref
//       Access: Published
//  Description: Explicitly increments the reference count.
//
//               This function is const, even though it changes the
//               object, because generally fiddling with an object's
//               reference count isn't considered part of fiddling
//               with the object.  An object might be const in other
//               ways, but we still need to accurately count the
//               number of references to it.
////////////////////////////////////////////////////////////////////
59
inline void NodeCachedReferenceCount::node_ref(void) const;

1637 10 node_unref 0 4 1835 36 NodeCachedReferenceCount::node_unref 0 1 750 468
////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::node_unref
//       Access: Published
//  Description: Explicitly decrements the node reference count and
//               the normal reference count simultaneously.
//
//               The return value is true if the new reference count
//               is nonzero, false if it is zero.
////////////////////////////////////////////////////////////////////
61
inline bool NodeCachedReferenceCount::node_unref(void) const;

1638 24 test_ref_count_integrity 0 4 1835 50 NodeCachedReferenceCount::test_ref_count_integrity 0 1 751 350
////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::test_ref_count_integrity
//       Access: Published
//  Description: Does some easy checks to make sure that the reference
//               count isn't completely bogus.
////////////////////////////////////////////////////////////////////
75
inline bool NodeCachedReferenceCount::test_ref_count_integrity(void) const;

1639 19 get_referenced_bits 0 4 1835 45 NodeCachedReferenceCount::get_referenced_bits 0 1 752 600
////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::get_referenced_bits
//       Access: Published
//  Description: Returns the union of the values defined in the
//               Referenced enum that represents the various things
//               that appear to be holding a pointer to this object.
//
//               If R_node is included, at least one node is holding a
//               pointer; if R_cache is included, at least one cache
//               element is.
////////////////////////////////////////////////////////////////////
69
inline int NodeCachedReferenceCount::get_referenced_bits(void) const;

1640 14 get_class_type 0 4 1835 40 NodeCachedReferenceCount::get_class_type 0 1 753 0
65
static TypeHandle NodeCachedReferenceCount::get_class_type(void);

1641 11 SparseArray 0 4 1837 24 SparseArray::SparseArray 0 3 754 755 756 694
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Constructor (from BitArray)
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
144
inline SparseArray::SparseArray(void);
inline SparseArray::SparseArray(SparseArray const &copy);
SparseArray::SparseArray(BitArray const &from);

1642 10 operator = 0 4 1837 23 SparseArray::operator = 0 1 757 236
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Copy Assignment Operator
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
69
inline SparseArray &SparseArray::operator =(SparseArray const &copy);

1643 6 all_on 0 4 1837 19 SparseArray::all_on 0 1 758 323
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a SparseArray with an infinite array of bits,
//               all on.
////////////////////////////////////////////////////////////////////
52
static inline SparseArray SparseArray::all_on(void);

1644 7 all_off 0 4 1837 20 SparseArray::all_off 0 1 759 290
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a SparseArray whose bits are all off.
////////////////////////////////////////////////////////////////////
53
static inline SparseArray SparseArray::all_off(void);

1645 8 lower_on 0 4 1837 21 SparseArray::lower_on 0 1 760 301
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named lower_on constructor
//       Access: Published, Static
//  Description: Returns a SparseArray whose lower on_bits bits are on.
////////////////////////////////////////////////////////////////////
61
static inline SparseArray SparseArray::lower_on(int on_bits);

1646 3 bit 0 4 1837 16 SparseArray::bit 0 1 761 295
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named bit constructor
//       Access: Published, Static
//  Description: Returns a SparseArray with only the indicated bit on.
////////////////////////////////////////////////////////////////////
54
static inline SparseArray SparseArray::bit(int index);

1647 5 range 0 4 1837 18 SparseArray::range 0 1 762 329
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named range constructor
//       Access: Published, Static
//  Description: Returns a SparseArray whose size bits, beginning at
//               low_bit, are on.
////////////////////////////////////////////////////////////////////
68
static inline SparseArray SparseArray::range(int low_bit, int size);

1648 12 ~SparseArray 0 4 1837 25 SparseArray::~SparseArray 0 0 222
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
39
inline SparseArray::~SparseArray(void);

1649 16 has_max_num_bits 0 4 1837 29 SparseArray::has_max_num_bits 0 1 763 723
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_max_num_bits
//       Access: Published, Static
//  Description: Returns true if there is a maximum number of bits
//               that may be stored in this structure, false
//               otherwise.  If this returns true, the number may be
//               queried in get_max_num_bits().
//
//               This method always returns false.  The SparseArray has
//               no maximum number of bits.  This method is defined so
//               generic programming algorithms can use BitMask or
//               SparseArray interchangeably.
////////////////////////////////////////////////////////////////////
55
static inline bool SparseArray::has_max_num_bits(void);

1650 16 get_max_num_bits 0 4 1837 29 SparseArray::get_max_num_bits 0 1 764 758
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_max_num_bits
//       Access: Published, Static
//  Description: If get_max_num_bits() returned true, this method may
//               be called to return the maximum number of bits that
//               may be stored in this structure.  It is an error to
//               call this if get_max_num_bits() return false.
//
//               It is always an error to call this method.  The
//               SparseArray has no maximum number of bits.  This method
//               is defined so generic programming algorithms can use
//               BitMask or SparseArray interchangeably.
////////////////////////////////////////////////////////////////////
54
static inline int SparseArray::get_max_num_bits(void);

1651 12 get_num_bits 0 4 1837 25 SparseArray::get_num_bits 0 1 765 607
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_bits
//       Access: Published
//  Description: Returns the current number of possibly different bits
//               in this array.  There are actually an infinite number
//               of bits, but every bit higher than this bit will have
//               the same value, either 0 or 1 (see
//               get_highest_bits()).
//
//               This number may grow and/or shrink automatically as
//               needed.
////////////////////////////////////////////////////////////////////
49
inline int SparseArray::get_num_bits(void) const;

1652 7 get_bit 0 4 1837 20 SparseArray::get_bit 0 1 766 445
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_bit
//       Access: Published
//  Description: Returns true if the nth bit is set, false if it is
//               cleared.  It is valid for n to increase beyond
//               get_num_bits(), but the return value get_num_bits()
//               will always be the same.
////////////////////////////////////////////////////////////////////
50
inline bool SparseArray::get_bit(int index) const;

1653 7 set_bit 0 4 1837 20 SparseArray::set_bit 0 1 767 320
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_bit
//       Access: Published
//  Description: Sets the nth bit on.  If n >= get_num_bits(), this
//               automatically extends the array.
////////////////////////////////////////////////////////////////////
44
inline void SparseArray::set_bit(int index);

1654 9 clear_bit 0 4 1837 22 SparseArray::clear_bit 0 1 768 323
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::clear_bit
//       Access: Published
//  Description: Sets the nth bit off.  If n >= get_num_bits(), this
//               automatically extends the array.
////////////////////////////////////////////////////////////////////
46
inline void SparseArray::clear_bit(int index);

1655 10 set_bit_to 0 4 1837 23 SparseArray::set_bit_to 0 1 769 313
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_bit_to
//       Access: Published
//  Description: Sets the nth bit either on or off, according to the
//               indicated bool value.
////////////////////////////////////////////////////////////////////
59
inline void SparseArray::set_bit_to(int index, bool value);

1656 16 get_highest_bits 0 4 1837 29 SparseArray::get_highest_bits 0 1 770 367
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_highest_bits
//       Access: Published
//  Description: Returns true if the infinite set of bits beyond
//               get_num_bits() are all on, or false of they are all
//               off.
////////////////////////////////////////////////////////////////////
54
inline bool SparseArray::get_highest_bits(void) const;

1657 7 is_zero 0 4 1837 20 SparseArray::is_zero 0 1 771 297
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::is_zero
//       Access: Published
//  Description: Returns true if the entire bitmask is zero, false
//               otherwise.
////////////////////////////////////////////////////////////////////
45
inline bool SparseArray::is_zero(void) const;

1658 9 is_all_on 0 4 1837 22 SparseArray::is_all_on 0 1 772 298
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::is_all_on
//       Access: Published
//  Description: Returns true if the entire bitmask is one, false
//               otherwise.
////////////////////////////////////////////////////////////////////
47
inline bool SparseArray::is_all_on(void) const;

1659 10 has_any_of 0 4 1837 23 SparseArray::has_any_of 0 1 773 311
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_any_of
//       Access: Published
//  Description: Returns true if any bit in the indicated range is
//               set, false otherwise.
////////////////////////////////////////////////////////////////////
65
inline bool SparseArray::has_any_of(int low_bit, int size) const;

1660 10 has_all_of 0 4 1837 23 SparseArray::has_all_of 0 1 774 313
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_all_of
//       Access: Published
//  Description: Returns true if all bits in the indicated range are
//               set, false otherwise.
////////////////////////////////////////////////////////////////////
65
inline bool SparseArray::has_all_of(int low_bit, int size) const;

1661 9 set_range 0 4 1837 22 SparseArray::set_range 0 1 775 258
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_range
//       Access: Published
//  Description: Sets the indicated range of bits on.
////////////////////////////////////////////////////////////////////
58
inline void SparseArray::set_range(int low_bit, int size);

1662 11 clear_range 0 4 1837 24 SparseArray::clear_range 0 1 776 261
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::clear_range
//       Access: Published
//  Description: Sets the indicated range of bits off.
////////////////////////////////////////////////////////////////////
60
inline void SparseArray::clear_range(int low_bit, int size);

1663 12 set_range_to 0 4 1837 25 SparseArray::set_range_to 0 1 777 278
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_range_to
//       Access: Published
//  Description: Sets the indicated range of bits to either on or off.
////////////////////////////////////////////////////////////////////
73
inline void SparseArray::set_range_to(bool value, int low_bit, int size);

1664 15 get_num_on_bits 0 4 1837 28 SparseArray::get_num_on_bits 0 1 778 375
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_on_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 1 in the
//               array.  Returns -1 if there are an infinite number of
//               1 bits.
////////////////////////////////////////////////////////////////////
45
int SparseArray::get_num_on_bits(void) const;

1665 16 get_num_off_bits 0 4 1837 29 SparseArray::get_num_off_bits 0 1 779 376
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_off_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 0 in the
//               array.  Returns -1 if there are an infinite number of
//               0 bits.
////////////////////////////////////////////////////////////////////
46
int SparseArray::get_num_off_bits(void) const;

1666 17 get_lowest_on_bit 0 4 1837 30 SparseArray::get_lowest_on_bit 0 1 780 395
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_lowest_on_bit
//       Access: Published
//  Description: Returns the index of the lowest 1 bit in the array.
//               Returns -1 if there are no 1 bits or if there are an
//               infinite number of 1 bits.
////////////////////////////////////////////////////////////////////
47
int SparseArray::get_lowest_on_bit(void) const;

1667 18 get_lowest_off_bit 0 4 1837 31 SparseArray::get_lowest_off_bit 0 1 781 396
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_lowest_off_bit
//       Access: Published
//  Description: Returns the index of the lowest 0 bit in the array.
//               Returns -1 if there are no 0 bits or if there are an
//               infinite number of 1 bits.
////////////////////////////////////////////////////////////////////
48
int SparseArray::get_lowest_off_bit(void) const;

1668 18 get_highest_on_bit 0 4 1837 31 SparseArray::get_highest_on_bit 0 1 782 393
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_highest_on_bit
//       Access: Published
//  Description: Returns the index of the highest 1 bit in the array.
//               Returns -1 if there are no 1 bits or if there an
//               infinite number of 1 bits.
////////////////////////////////////////////////////////////////////
48
int SparseArray::get_highest_on_bit(void) const;

1669 19 get_highest_off_bit 0 4 1837 32 SparseArray::get_highest_off_bit 0 1 783 394
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_highest_off_bit
//       Access: Published
//  Description: Returns the index of the highest 0 bit in the array.
//               Returns -1 if there are no 0 bits or if there an
//               infinite number of 1 bits.
////////////////////////////////////////////////////////////////////
49
int SparseArray::get_highest_off_bit(void) const;

1670 29 get_next_higher_different_bit 0 4 1837 42 SparseArray::get_next_higher_different_bit 0 1 784 594
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_next_higher_different_bit
//       Access: Published
//  Description: Returns the index of the next bit in the array, above
//               low_bit, whose value is different that the value of
//               low_bit.  Returns low_bit again if all bits higher
//               than low_bit have the same value.
//
//               This can be used to quickly iterate through all of
//               the bits in the array.
////////////////////////////////////////////////////////////////////
66
int SparseArray::get_next_higher_different_bit(int low_bit) const;

1671 15 invert_in_place 0 4 1837 28 SparseArray::invert_in_place 0 1 785 324
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::invert_in_place
//       Access: Published
//  Description: Inverts all the bits in the SparseArray.  This is
//               equivalent to array = ~array.
////////////////////////////////////////////////////////////////////
47
inline void SparseArray::invert_in_place(void);

1672 18 has_bits_in_common 0 4 1837 31 SparseArray::has_bits_in_common 0 1 786 446
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_bits_in_common
//       Access: Published
//  Description: Returns true if this SparseArray has any "one" bits in
//               common with the other one, false otherwise.
//
//               This is equivalent to (array & other) != 0, but may
//               be faster.
////////////////////////////////////////////////////////////////////
69
bool SparseArray::has_bits_in_common(SparseArray const &other) const;

1673 5 clear 0 4 1837 18 SparseArray::clear 0 1 787 259
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::clear
//       Access: Published
//  Description: Sets all the bits in the SparseArray off.
////////////////////////////////////////////////////////////////////
37
inline void SparseArray::clear(void);

1674 6 output 0 4 1837 19 SparseArray::output 0 1 788 219
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
45
void SparseArray::output(ostream &out) const;

1675 11 operator == 0 4 1837 24 SparseArray::operator == 0 1 789 0
69
inline bool SparseArray::operator ==(SparseArray const &other) const;

1676 11 operator != 0 4 1837 24 SparseArray::operator != 0 1 790 0
69
inline bool SparseArray::operator !=(SparseArray const &other) const;

1677 10 operator < 0 4 1837 23 SparseArray::operator < 0 1 791 0
68
inline bool SparseArray::operator <(SparseArray const &other) const;

1678 10 compare_to 0 4 1837 23 SparseArray::compare_to 0 1 792 513
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::compare_to
//       Access: Published
//  Description: Returns a number less than zero if this SparseArray
//               sorts before the indicated other SparseArray, greater
//               than zero if it sorts after, or 0 if they are
//               equivalent.  This is based on the same ordering
//               defined by operator <.
////////////////////////////////////////////////////////////////////
60
int SparseArray::compare_to(SparseArray const &other) const;

1679 10 operator & 0 4 1837 23 SparseArray::operator & 0 1 793 0
75
inline SparseArray SparseArray::operator &(SparseArray const &other) const;

1680 10 operator | 0 4 1837 23 SparseArray::operator | 0 1 794 0
75
inline SparseArray SparseArray::operator |(SparseArray const &other) const;

1681 10 operator ^ 0 4 1837 23 SparseArray::operator ^ 0 1 795 0
75
inline SparseArray SparseArray::operator ^(SparseArray const &other) const;

1682 10 operator ~ 0 68 1837 23 SparseArray::operator ~ 0 1 796 0
55
inline SparseArray SparseArray::operator ~(void) const;

1683 11 operator << 0 4 1837 24 SparseArray::operator << 0 1 797 0
61
inline SparseArray SparseArray::operator <<(int shift) const;

1684 11 operator >> 0 4 1837 24 SparseArray::operator >> 0 1 798 0
61
inline SparseArray SparseArray::operator >>(int shift) const;

1685 11 operator &= 0 4 1837 24 SparseArray::operator &= 0 1 799 0
56
void SparseArray::operator &=(SparseArray const &other);

1686 11 operator |= 0 4 1837 24 SparseArray::operator |= 0 1 800 0
56
void SparseArray::operator |=(SparseArray const &other);

1687 11 operator ^= 0 4 1837 24 SparseArray::operator ^= 0 1 801 0
56
void SparseArray::operator ^=(SparseArray const &other);

1688 12 operator <<= 0 4 1837 25 SparseArray::operator <<= 0 1 802 0
49
inline void SparseArray::operator <<=(int shift);

1689 12 operator >>= 0 4 1837 25 SparseArray::operator >>= 0 1 803 0
49
inline void SparseArray::operator >>=(int shift);

1690 10 is_inverse 0 4 1837 23 SparseArray::is_inverse 0 1 804 614
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::is_inverse
//       Access: Published
//  Description: If this is true, the SparseArray is actually defined
//               as a list of subranges of integers that are *not* in
//               the set.  If this is false (the default), then the
//               subranges define the integers that *are* in the set.
//               This affects the interpretation of the values
//               returned by iterating through get_num_subranges().
////////////////////////////////////////////////////////////////////
48
inline bool SparseArray::is_inverse(void) const;

1691 17 get_num_subranges 0 4 1837 30 SparseArray::get_num_subranges 0 1 805 515
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_subranges
//       Access: Published
//  Description: Returns the number of separate subranges stored in
//               the SparseArray.  You can use this limit to iterate
//               through the subranges, calling get_subrange_begin()
//               and get_subrange_end() for each one.
//
//               Also see is_inverse().
////////////////////////////////////////////////////////////////////
54
inline int SparseArray::get_num_subranges(void) const;

1692 18 get_subrange_begin 0 4 1837 31 SparseArray::get_subrange_begin 0 1 806 345
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_subrange_begin
//       Access: Published
//  Description: Returns the first numeric element in the nth
//               subrange.
//
//               Also see is_inverse().
////////////////////////////////////////////////////////////////////
56
inline int SparseArray::get_subrange_begin(int n) const;

1693 16 get_subrange_end 0 4 1837 29 SparseArray::get_subrange_end 0 1 807 353
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_subrange_end
//       Access: Published
//  Description: Returns the last numeric element, plus one, in the
//               nth subrange.
//
//               Also see is_inverse().
////////////////////////////////////////////////////////////////////
54
inline int SparseArray::get_subrange_end(int n) const;

1694 14 get_class_type 0 4 1837 27 SparseArray::get_class_type 0 1 808 0
52
static TypeHandle SparseArray::get_class_type(void);

1695 14 get_value_type 0 6 1838 30 ParamValueBase::get_value_type 0 1 809 280
////////////////////////////////////////////////////////////////////
//     Function: ParamValueBase::get_value_type
//       Access: Published, Virtual
//  Description: Returns the type of the underlying value.
////////////////////////////////////////////////////////////////////
69
virtual inline TypeHandle ParamValueBase::get_value_type(void) const;

1696 6 output 0 6 1838 22 ParamValueBase::output 0 1 810 0
60
virtual void ParamValueBase::output(ostream &out) const = 0;

1697 14 get_class_type 0 4 1838 30 ParamValueBase::get_class_type 0 1 811 0
55
static TypeHandle ParamValueBase::get_class_type(void);

1698 18 ParamTypedRefCount 0 4 1839 38 ParamTypedRefCount::ParamTypedRefCount 0 1 812 230
////////////////////////////////////////////////////////////////////
//     Function: ParamTypedRefCount::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
80
inline ParamTypedRefCount::ParamTypedRefCount(TypedReferenceCount const *value);

1699 9 get_value 0 4 1839 29 ParamTypedRefCount::get_value 0 1 813 273
////////////////////////////////////////////////////////////////////
//     Function: ParamTypedRefCount::get_value
//       Access: Published
//  Description: Retrieves the value stored in the parameter.
////////////////////////////////////////////////////////////////////
70
inline TypedReferenceCount *ParamTypedRefCount::get_value(void) const;

1700 14 get_class_type 0 4 1839 34 ParamTypedRefCount::get_class_type 0 1 814 0
59
static TypeHandle ParamTypedRefCount::get_class_type(void);

1701 10 ParamValue 0 4 1840 32 ParamValue< string >::ParamValue 0 1 815 0
61
inline ParamValue< string >::ParamValue(string const &value);

1702 9 set_value 0 4 1840 31 ParamValue< string >::set_value 0 1 816 0
65
inline void ParamValue< string >::set_value(string const &value);

1703 9 get_value 0 4 1840 31 ParamValue< string >::get_value 0 1 817 0
65
inline string const &ParamValue< string >::get_value(void) const;

1704 14 get_class_type 0 4 1840 36 ParamValue< string >::get_class_type 0 1 818 0
61
static TypeHandle ParamValue< string >::get_class_type(void);

1705 10 ParamValue 0 4 1842 33 ParamValue< wstring >::ParamValue 0 1 819 0
63
inline ParamValue< wstring >::ParamValue(wstring const &value);

1706 9 set_value 0 4 1842 32 ParamValue< wstring >::set_value 0 1 820 0
67
inline void ParamValue< wstring >::set_value(wstring const &value);

1707 9 get_value 0 4 1842 32 ParamValue< wstring >::get_value 0 1 821 0
67
inline wstring const &ParamValue< wstring >::get_value(void) const;

1708 14 get_class_type 0 4 1842 37 ParamValue< wstring >::get_class_type 0 1 822 0
62
static TypeHandle ParamValue< wstring >::get_class_type(void);

1709 10 ParamValue 0 4 1844 36 ParamValue< LVecBase2d >::ParamValue 0 1 823 0
69
inline ParamValue< LVecBase2d >::ParamValue(LVecBase2d const &value);

1710 9 set_value 0 4 1844 35 ParamValue< LVecBase2d >::set_value 0 1 824 0
73
inline void ParamValue< LVecBase2d >::set_value(LVecBase2d const &value);

1711 9 get_value 0 4 1844 35 ParamValue< LVecBase2d >::get_value 0 1 825 0
73
inline LVecBase2d const &ParamValue< LVecBase2d >::get_value(void) const;

1712 14 get_class_type 0 4 1844 40 ParamValue< LVecBase2d >::get_class_type 0 1 826 0
65
static TypeHandle ParamValue< LVecBase2d >::get_class_type(void);

1713 10 ParamValue 0 4 1846 36 ParamValue< LVecBase2f >::ParamValue 0 1 827 0
69
inline ParamValue< LVecBase2f >::ParamValue(LVecBase2f const &value);

1714 9 set_value 0 4 1846 35 ParamValue< LVecBase2f >::set_value 0 1 828 0
73
inline void ParamValue< LVecBase2f >::set_value(LVecBase2f const &value);

1715 9 get_value 0 4 1846 35 ParamValue< LVecBase2f >::get_value 0 1 829 0
73
inline LVecBase2f const &ParamValue< LVecBase2f >::get_value(void) const;

1716 14 get_class_type 0 4 1846 40 ParamValue< LVecBase2f >::get_class_type 0 1 830 0
65
static TypeHandle ParamValue< LVecBase2f >::get_class_type(void);

1717 10 ParamValue 0 4 1848 36 ParamValue< LVecBase2i >::ParamValue 0 1 831 0
69
inline ParamValue< LVecBase2i >::ParamValue(LVecBase2i const &value);

1718 9 set_value 0 4 1848 35 ParamValue< LVecBase2i >::set_value 0 1 832 0
73
inline void ParamValue< LVecBase2i >::set_value(LVecBase2i const &value);

1719 9 get_value 0 4 1848 35 ParamValue< LVecBase2i >::get_value 0 1 833 0
73
inline LVecBase2i const &ParamValue< LVecBase2i >::get_value(void) const;

1720 14 get_class_type 0 4 1848 40 ParamValue< LVecBase2i >::get_class_type 0 1 834 0
65
static TypeHandle ParamValue< LVecBase2i >::get_class_type(void);

1721 10 ParamValue 0 4 1850 36 ParamValue< LVecBase3d >::ParamValue 0 1 835 0
69
inline ParamValue< LVecBase3d >::ParamValue(LVecBase3d const &value);

1722 9 set_value 0 4 1850 35 ParamValue< LVecBase3d >::set_value 0 1 836 0
73
inline void ParamValue< LVecBase3d >::set_value(LVecBase3d const &value);

1723 9 get_value 0 4 1850 35 ParamValue< LVecBase3d >::get_value 0 1 837 0
73
inline LVecBase3d const &ParamValue< LVecBase3d >::get_value(void) const;

1724 14 get_class_type 0 4 1850 40 ParamValue< LVecBase3d >::get_class_type 0 1 838 0
65
static TypeHandle ParamValue< LVecBase3d >::get_class_type(void);

1725 10 ParamValue 0 4 1852 36 ParamValue< LVecBase3f >::ParamValue 0 1 839 0
69
inline ParamValue< LVecBase3f >::ParamValue(LVecBase3f const &value);

1726 9 set_value 0 4 1852 35 ParamValue< LVecBase3f >::set_value 0 1 840 0
73
inline void ParamValue< LVecBase3f >::set_value(LVecBase3f const &value);

1727 9 get_value 0 4 1852 35 ParamValue< LVecBase3f >::get_value 0 1 841 0
73
inline LVecBase3f const &ParamValue< LVecBase3f >::get_value(void) const;

1728 14 get_class_type 0 4 1852 40 ParamValue< LVecBase3f >::get_class_type 0 1 842 0
65
static TypeHandle ParamValue< LVecBase3f >::get_class_type(void);

1729 10 ParamValue 0 4 1854 36 ParamValue< LVecBase3i >::ParamValue 0 1 843 0
69
inline ParamValue< LVecBase3i >::ParamValue(LVecBase3i const &value);

1730 9 set_value 0 4 1854 35 ParamValue< LVecBase3i >::set_value 0 1 844 0
73
inline void ParamValue< LVecBase3i >::set_value(LVecBase3i const &value);

1731 9 get_value 0 4 1854 35 ParamValue< LVecBase3i >::get_value 0 1 845 0
73
inline LVecBase3i const &ParamValue< LVecBase3i >::get_value(void) const;

1732 14 get_class_type 0 4 1854 40 ParamValue< LVecBase3i >::get_class_type 0 1 846 0
65
static TypeHandle ParamValue< LVecBase3i >::get_class_type(void);

1733 10 ParamValue 0 4 1856 36 ParamValue< LVecBase4d >::ParamValue 0 1 847 0
69
inline ParamValue< LVecBase4d >::ParamValue(LVecBase4d const &value);

1734 9 set_value 0 4 1856 35 ParamValue< LVecBase4d >::set_value 0 1 848 0
73
inline void ParamValue< LVecBase4d >::set_value(LVecBase4d const &value);

1735 9 get_value 0 4 1856 35 ParamValue< LVecBase4d >::get_value 0 1 849 0
73
inline LVecBase4d const &ParamValue< LVecBase4d >::get_value(void) const;

1736 14 get_class_type 0 4 1856 40 ParamValue< LVecBase4d >::get_class_type 0 1 850 0
65
static TypeHandle ParamValue< LVecBase4d >::get_class_type(void);

1737 10 ParamValue 0 4 1858 36 ParamValue< LVecBase4f >::ParamValue 0 1 851 0
69
inline ParamValue< LVecBase4f >::ParamValue(LVecBase4f const &value);

1738 9 set_value 0 4 1858 35 ParamValue< LVecBase4f >::set_value 0 1 852 0
73
inline void ParamValue< LVecBase4f >::set_value(LVecBase4f const &value);

1739 9 get_value 0 4 1858 35 ParamValue< LVecBase4f >::get_value 0 1 853 0
73
inline LVecBase4f const &ParamValue< LVecBase4f >::get_value(void) const;

1740 14 get_class_type 0 4 1858 40 ParamValue< LVecBase4f >::get_class_type 0 1 854 0
65
static TypeHandle ParamValue< LVecBase4f >::get_class_type(void);

1741 10 ParamValue 0 4 1860 36 ParamValue< LVecBase4i >::ParamValue 0 1 855 0
69
inline ParamValue< LVecBase4i >::ParamValue(LVecBase4i const &value);

1742 9 set_value 0 4 1860 35 ParamValue< LVecBase4i >::set_value 0 1 856 0
73
inline void ParamValue< LVecBase4i >::set_value(LVecBase4i const &value);

1743 9 get_value 0 4 1860 35 ParamValue< LVecBase4i >::get_value 0 1 857 0
73
inline LVecBase4i const &ParamValue< LVecBase4i >::get_value(void) const;

1744 14 get_class_type 0 4 1860 40 ParamValue< LVecBase4i >::get_class_type 0 1 858 0
65
static TypeHandle ParamValue< LVecBase4i >::get_class_type(void);

1745 10 ParamValue 0 4 1862 35 ParamValue< LMatrix3d >::ParamValue 0 1 859 0
67
inline ParamValue< LMatrix3d >::ParamValue(LMatrix3d const &value);

1746 9 set_value 0 4 1862 34 ParamValue< LMatrix3d >::set_value 0 1 860 0
71
inline void ParamValue< LMatrix3d >::set_value(LMatrix3d const &value);

1747 9 get_value 0 4 1862 34 ParamValue< LMatrix3d >::get_value 0 1 861 0
71
inline LMatrix3d const &ParamValue< LMatrix3d >::get_value(void) const;

1748 14 get_class_type 0 4 1862 39 ParamValue< LMatrix3d >::get_class_type 0 1 862 0
64
static TypeHandle ParamValue< LMatrix3d >::get_class_type(void);

1749 10 ParamValue 0 4 1864 35 ParamValue< LMatrix3f >::ParamValue 0 1 863 0
67
inline ParamValue< LMatrix3f >::ParamValue(LMatrix3f const &value);

1750 9 set_value 0 4 1864 34 ParamValue< LMatrix3f >::set_value 0 1 864 0
71
inline void ParamValue< LMatrix3f >::set_value(LMatrix3f const &value);

1751 9 get_value 0 4 1864 34 ParamValue< LMatrix3f >::get_value 0 1 865 0
71
inline LMatrix3f const &ParamValue< LMatrix3f >::get_value(void) const;

1752 14 get_class_type 0 4 1864 39 ParamValue< LMatrix3f >::get_class_type 0 1 866 0
64
static TypeHandle ParamValue< LMatrix3f >::get_class_type(void);

1753 10 ParamValue 0 4 1866 35 ParamValue< LMatrix4d >::ParamValue 0 1 867 0
67
inline ParamValue< LMatrix4d >::ParamValue(LMatrix4d const &value);

1754 9 set_value 0 4 1866 34 ParamValue< LMatrix4d >::set_value 0 1 868 0
71
inline void ParamValue< LMatrix4d >::set_value(LMatrix4d const &value);

1755 9 get_value 0 4 1866 34 ParamValue< LMatrix4d >::get_value 0 1 869 0
71
inline LMatrix4d const &ParamValue< LMatrix4d >::get_value(void) const;

1756 14 get_class_type 0 4 1866 39 ParamValue< LMatrix4d >::get_class_type 0 1 870 0
64
static TypeHandle ParamValue< LMatrix4d >::get_class_type(void);

1757 10 ParamValue 0 4 1868 35 ParamValue< LMatrix4f >::ParamValue 0 1 871 0
67
inline ParamValue< LMatrix4f >::ParamValue(LMatrix4f const &value);

1758 9 set_value 0 4 1868 34 ParamValue< LMatrix4f >::set_value 0 1 872 0
71
inline void ParamValue< LMatrix4f >::set_value(LMatrix4f const &value);

1759 9 get_value 0 4 1868 34 ParamValue< LMatrix4f >::get_value 0 1 873 0
71
inline LMatrix4f const &ParamValue< LMatrix4f >::get_value(void) const;

1760 14 get_class_type 0 4 1868 39 ParamValue< LMatrix4f >::get_class_type 0 1 874 0
64
static TypeHandle ParamValue< LMatrix4f >::get_class_type(void);

1761 14 get_class_type 0 4 1875 36 WritableConfigurable::get_class_type 0 1 875 0
61
static TypeHandle WritableConfigurable::get_class_type(void);

1762 21 ~WritableConfigurable 0 4 1875 43 WritableConfigurable::~WritableConfigurable 0 0 0
50
WritableConfigurable::~WritableConfigurable(void);

1763 17 UniqueIdAllocator 0 4 1876 36 UniqueIdAllocator::UniqueIdAllocator 0 1 876 275
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::Constructor
//       Access: Published
//  Description: Create a free id pool in the range [min:max].
////////////////////////////////////////////////////////////////////
76
UniqueIdAllocator::UniqueIdAllocator(PN_uint32 min = 0, PN_uint32 max = 20);

1764 18 ~UniqueIdAllocator 0 4 1876 37 UniqueIdAllocator::~UniqueIdAllocator 0 0 229
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::Destructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
44
UniqueIdAllocator::~UniqueIdAllocator(void);

1765 8 allocate 0 4 1876 27 UniqueIdAllocator::allocate 0 1 877 381
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::allocate
//       Access: Published
//  Description: Returns an id between _min and _max (that were passed
//               to the constructor).
//               IndexEnd is returned if no ids are available.
////////////////////////////////////////////////////////////////////
44
PN_uint32 UniqueIdAllocator::allocate(void);

1766 18 initial_reserve_id 0 4 1876 37 UniqueIdAllocator::initial_reserve_id 0 1 878 893
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::initial_reserve_id
//       Access: Published
//  Description: This may be called to mark a particular id as having
//               already been allocated (for instance, by a prior
//               pass).  The specified id is removed from the
//               available pool.
//
//               Because of the limitations of this algorithm, this is
//               most efficient when it is called before the first
//               call to allocate(), and when all the calls to
//               initial_reserve_id() are made in descending order by
//               id.  However, this is a performance warning only; if
//               performance is not an issue, any id may be reserved
//               at any time.
////////////////////////////////////////////////////////////////////
57
void UniqueIdAllocator::initial_reserve_id(PN_uint32 id);

1767 4 free 0 4 1876 23 UniqueIdAllocator::free 0 1 879 338
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::free
//       Access: Published
//  Description: Free an allocated index (index must be between _min
//               and _max that were passed to the constructor).
////////////////////////////////////////////////////////////////////
46
void UniqueIdAllocator::free(PN_uint32 index);

1768 13 fraction_used 0 4 1876 32 UniqueIdAllocator::fraction_used 0 1 880 350
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::fraction_used
//       Access: Published
//  Description: return the decimal fraction of the pool that is used.
//               The range is 0 to 1.0 (e.g. 75% would be 0.75).
////////////////////////////////////////////////////////////////////
57
PN_stdfloat UniqueIdAllocator::fraction_used(void) const;

1769 6 output 0 4 1876 25 UniqueIdAllocator::output 0 1 881 256
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::output
//       Access: Published
//  Description: ...intended for debugging only.
////////////////////////////////////////////////////////////////////
51
void UniqueIdAllocator::output(ostream &out) const;

1770 5 write 0 4 1876 24 UniqueIdAllocator::write 0 1 882 255
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::write
//       Access: Published
//  Description: ...intended for debugging only.
////////////////////////////////////////////////////////////////////
50
void UniqueIdAllocator::write(ostream &out) const;

1771 39 py_decode_TypedWritable_from_bam_stream 0 1 0 39 py_decode_TypedWritable_from_bam_stream 0 1 891 0
92
PyObject *py_decode_TypedWritable_from_bam_stream(PyObject *this_class, string const &data);

1772 47 py_decode_TypedWritable_from_bam_stream_persist 0 1 0 47 py_decode_TypedWritable_from_bam_stream_persist 0 1 892 0
121
PyObject *py_decode_TypedWritable_from_bam_stream_persist(PyObject *unpickler, PyObject *this_class, string const &data);

892
1 0 0 7 8 1880 906 0 0 1 4 copy 1 1878  
2 0 0 7 8 1880 906 0 0 1 4 copy 1 1881  
3 0 0 7 8 1880 906 0 0 1 6 source 1 1883  
4 0 0 6 9 1886 0 0 0 1 4 this 3 1878  
5 0 0 6 10 1888 0 0 0 2 4 this 3 1878  1 n 1 1886  
6 0 0 6 11 1888 0 0 0 2 4 this 3 1878  1 n 1 1886  
7 0 0 6 12 1890 0 0 0 1 4 this 3 1878  
8 0 0 6 13 1890 0 0 0 3 4 this 3 1878  1 n 1 1886  5 count 1 1886  
9 0 0 6 14 1891 0 0 0 1 4 this 3 1878  
10 0 0 6 15 1891 0 0 0 1 4 this 3 1878  
11 0 0 6 16 1891 0 0 0 3 4 this 3 1878  4 view 1 1892  5 flags 1 1891  
12 0 0 4 17 1894 0 0 0 2 4 this 3 1878  4 view 1 1892  
13 0 0 4 5 1894 0 0 0 1 4 this 3 1895  
14 0 0 4 6 1894 0 0 0 2 4 this 3 1896  3 out 1 1898  
15 0 0 7 20 1900 924 0 0 1 4 copy 1 1881  
16 0 0 7 20 1900 924 0 0 1 6 source 1 1883  
17 0 0 7 20 1900 924 0 0 1 11 type_handle 1 1901  
18 0 0 7 21 1900 924 0 0 2 1 n 1 1886  11 type_handle 1 1901  
19 0 0 6 22 1886 0 0 0 1 4 this 3 1881  
20 0 0 4 23 1894 0 0 0 2 4 this 3 1900  1 x 1 1888  
21 0 0 4 24 1894 0 0 0 1 4 this 3 1900  
22 0 0 6 25 1888 0 0 0 2 4 this 3 1881  1 n 1 1886  
23 0 0 4 26 1894 0 0 0 3 4 this 3 1900  1 n 1 1886  5 value 1 1888  
24 0 0 6 27 1888 0 0 0 2 4 this 3 1881  1 n 1 1886  
25 0 0 4 28 1894 0 0 0 3 4 this 3 1900  1 n 1 1886  5 value 1 1888  
26 0 0 6 29 1890 0 0 0 1 4 this 3 1881  
27 0 0 4 30 1894 0 0 0 2 4 this 3 1900  4 data 1 1890  
28 0 0 6 31 1890 0 0 0 3 4 this 3 1881  1 n 1 1886  5 count 1 1886  
29 0 0 4 32 1894 0 0 0 4 4 this 3 1900  1 n 1 1886  5 count 1 1886  4 data 1 1890  
30 0 0 6 33 1891 0 0 0 1 4 this 3 1881  
31 0 0 6 34 1891 0 0 0 1 4 this 3 1881  
32 0 0 6 35 1891 0 0 0 3 4 this 3 1900  4 view 1 1892  5 flags 1 1891  
33 0 0 4 36 1894 0 0 0 2 4 this 3 1881  4 view 1 1892  
34 0 0 4 41 1894 0 0 294 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::play
//       Access: Published
//  Description: Runs the entire animation from beginning to end and
//               stops.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1903  
35 0 0 4 41 1894 0 0 736 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::play
//       Access: Published
//  Description: Runs the animation from the frame "from" to and
//               including the frame "to", at which point the
//               animation is stopped.  Both "from" and "to" frame
//               numbers may be outside the range (0,
//               get_num_frames()) and the animation will follow the
//               range correctly, reporting numbers modulo
//               get_num_frames().  For instance, play(0,
//               get_num_frames() * 2) will play the animation twice
//               and then stop.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1903  4 from 1 1904  2 to 1 1904  
36 0 0 4 42 1894 0 0 405 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::loop
//       Access: Published
//  Description: Starts the entire animation looping.  If restart is
//               true, the animation is restarted from the beginning;
//               otherwise, it continues from the current frame.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1903  7 restart 1 1905  
37 0 0 4 42 1894 0 0 491 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::loop
//       Access: Published
//  Description: Loops the animation from the frame "from" to and
//               including the frame "to", indefinitely.  If restart
//               is true, the animation is restarted from the
//               beginning; otherwise, it continues from the current
//               frame.
//////////////////////////////////////////////////////////////////// 4 4 this 3 1903  7 restart 1 1905  4 from 1 1904  2 to 1 1904  
38 0 0 4 43 1894 0 0 498 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::pingpong
//       Access: Published
//  Description: Starts the entire animation bouncing back and forth
//               between its first frame and last frame.  If restart
//               is true, the animation is restarted from the
//               beginning; otherwise, it continues from the current
//               frame.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1903  7 restart 1 1905  
39 0 0 4 43 1894 0 0 386 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::pingpong
//       Access: Published
//  Description: Loops the animation from the frame "from" to and
//               including the frame "to", and then back in the
//               opposite direction, indefinitely.
//////////////////////////////////////////////////////////////////// 4 4 this 3 1903  7 restart 1 1905  4 from 1 1904  2 to 1 1904  
40 0 0 4 44 1894 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::stop
//       Access: Published
//  Description: Stops a currently playing or looping animation right
//               where it is.  The animation remains posed at the
//               current frame.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1903  
41 0 0 4 45 1894 0 0 297 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::pose
//       Access: Published
//  Description: Sets the animation to the indicated frame and holds
//               it there.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1903  5 frame 1 1904  
42 0 0 4 46 1894 0 0 519 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::set_play_rate
//       Access: Published
//  Description: Changes the rate at which the animation plays.  1.0
//               is the normal speed, 2.0 is twice normal speed, and
//               0.5 is half normal speed.  0.0 is legal to pause the
//               animation, and a negative value will play the
//               animation backwards.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1903  9 play_rate 1 1904  
43 0 0 6 47 1904 0 0 313 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_play_rate
//       Access: Published
//  Description: Returns the rate at which the animation plays.  See
//               set_play_rate().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1906  
44 0 0 6 48 1904 0 0 514 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_frame_rate
//       Access: Published
//  Description: Returns the native frame rate of the animation.  This
//               is the number of frames per second that will elapse
//               when the play_rate is set to 1.0.  It is a fixed
//               property of the animation and may not be adjusted by
//               the user.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1906  
45 0 0 6 49 1891 0 0 581 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_num_frames
//       Access: Published, Virtual
//  Description: Returns the number of frames in the animation.  This
//               is a property of the animation and may not be
//               directly adjusted by the user (although it may change
//               without warning with certain kinds of animations,
//               since this is a virtual method that may be
//               overridden).
//////////////////////////////////////////////////////////////////// 1 4 this 3 1906  
46 0 0 6 50 1891 0 0 359 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_frame
//       Access: Published
//  Description: Returns the current integer frame number.
//               This number will be in the range 0 <= f <
//               get_num_frames().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1906  
47 0 0 6 51 1891 0 0 638 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_next_frame
//       Access: Published
//  Description: Returns the current integer frame number + 1,
//               constrained to the range 0 <= f < get_num_frames().
//
//               If the play mode is PM_play, this will clamp to the
//               same value as get_frame() at the end of the
//               animation.  If the play mode is any other value, this
//               will wrap around to frame 0 at the end of the
//               animation.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1906  
48 0 0 6 52 1904 0 0 598 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_frac
//       Access: Published
//  Description: Returns the fractional part of the current frame.
//               Normally, this is in the range 0.0 <= f < 1.0, but in
//               the one special case of an animation playing to its
//               end frame and stopping, it might exactly equal 1.0.
//
//               It will always be true that get_full_frame() +
//               get_frac() == get_full_fframe().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1906  
49 0 0 6 53 1891 0 0 693 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_full_frame
//       Access: Published
//  Description: Returns the current integer frame number.
//
//               Unlike the value returned by get_frame(), this frame
//               number may extend beyond the range of
//               get_num_frames() if the frame range passed to play(),
//               loop(), etc. did.
//
//               Unlike the value returned by get_full_fframe(), this
//               return value will never exceed the value passed to
//               to_frame in the play() method.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1906  
50 0 0 6 54 1904 0 0 841 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_full_fframe
//       Access: Published
//  Description: Returns the current floating-point frame number.
//
//               Unlike the value returned by get_frame(), this frame
//               number may extend beyond the range of
//               get_num_frames() if the frame range passed to play(),
//               loop(), etc. did.
//
//               Unlike the value returned by get_full_frame(), this
//               return value may equal (to_frame + 1.0), when the
//               animation has played to its natural end.  However, in
//               this case the return value of get_full_frame() will
//               be to_frame, not (to_frame + 1).
//////////////////////////////////////////////////////////////////// 1 4 this 3 1906  
51 0 0 6 55 1905 0 0 466 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::is_playing
//       Access: Published
//  Description: Returns true if the animation is currently playing,
//               false if it is stopped (e.g. because stop() or pose()
//               was called, or because it reached the end of the
//               animation after play() was called).
//////////////////////////////////////////////////////////////////// 1 4 this 3 1906  
52 0 0 4 56 1894 0 0 230 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::output
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 1906  3 out 1 1898  
53 0 0 7 57 1901 0 0 0 0 
54 0 0 7 60 1908 963 0 274 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::Default Constructor
//       Access: Published
//  Description: Creates an UpdateSeq in the 'initial' state.
//////////////////////////////////////////////////////////////////// 0 
55 0 0 7 60 1908 963 0 226 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 1909  
56 0 0 7 61 1908 963 0 290 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::initial (named constructor)
//       Access: Published, Static
//  Description: Returns an UpdateSeq in the 'initial' state.
//////////////////////////////////////////////////////////////////// 0 
57 0 0 7 62 1908 963 0 282 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::old (named constructor)
//       Access: Published, Static
//  Description: Returns an UpdateSeq in the 'old' state.
//////////////////////////////////////////////////////////////////// 0 
58 0 0 7 63 1908 963 0 286 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::fresh (named constructor)
//       Access: Published, Static
//  Description: Returns an UpdateSeq in the 'fresh' state.
//////////////////////////////////////////////////////////////////// 0 
59 0 0 6 64 1908 0 0 234 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::Copy Assignment operator
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1908  4 copy 1 1909  
60 0 0 4 65 1894 0 0 260 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::clear
//       Access: Published
//  Description: Resets the UpdateSeq to the 'initial' state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1908  
61 0 0 6 66 1905 0 0 294 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_initial
//       Access: Published
//  Description: Returns true if the UpdateSeq is in the 'initial'
//               state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1909  
62 0 0 6 67 1905 0 0 269 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_old
//       Access: Published
//  Description: Returns true if the UpdateSeq is in the 'old' state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1909  
63 0 0 6 68 1905 0 0 290 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_fresh
//       Access: Published
//  Description: Returns true if the UpdateSeq is in the 'fresh'
//               state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1909  
64 0 0 6 69 1905 0 0 328 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_special
//       Access: Published
//  Description: Returns true if the UpdateSeq is in any special
//               states, i.e. 'initial', 'old', or 'fresh'.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1909  
65 0 0 6 70 1905 0 0 0 2 4 this 3 1909  5 other 1 1909  
66 0 0 6 71 1905 0 0 0 2 4 this 3 1909  5 other 1 1909  
67 0 0 6 72 1905 0 0 0 2 4 this 3 1909  5 other 1 1909  
68 0 0 6 73 1905 0 0 0 2 4 this 3 1909  5 other 1 1909  
69 0 0 6 74 1905 0 0 0 2 4 this 3 1909  5 other 1 1909  
70 0 0 6 75 1905 0 0 0 2 4 this 3 1909  5 other 1 1909  
71 0 0 7 76 1908 963 0 0 1 4 this 3 1908  
72 0 0 7 77 1908 963 0 0 2 4 this 3 1908  6 param0 0 1891  
73 0 0 6 78 1911 0 0 328 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::get_seq
//       Access: Published
//  Description: Returns the internal integer value associated with
//               the UpdateSeq.  Useful for debugging only.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1909  
74 0 0 4 79 1894 0 0 216 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::output
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1909  3 out 1 1898  
75 0 0 4 83 1894 0 0 653 ////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::mark_bam_modified
//       Access: Public
//  Description: Increments the bam_modified counter, so that this
//               object will be invalidated and retransmitted on any
//               open bam streams.  This should normally not need to
//               be called by user code; it should be called
//               internally when the object has been changed in a way
//               that legitimately requires its retransmission to any
//               connected clients.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1914  
76 0 0 7 84 1908 963 0 388 ////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::get_bam_modified
//       Access: Public
//  Description: Returns the current bam_modified counter.  This
//               counter is normally incremented automatically
//               whenever the object is modified.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1915  
77 0 0 6 85 1883 0 0 0 1 4 this 3 1915  
78 0 0 6 86 1883 0 0 0 2 4 this 3 1915  7 pickler 1 1883  
79 0 0 6 87 1890 0 0 756 ////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::encode_to_bam_stream
//       Access: Published
//  Description: Converts the TypedWritable object into a single
//               stream of data using a BamWriter, and returns that
//               data as a string string.  Returns empty string on
//               failure.
//
//               This is a convenience method particularly useful for
//               cases when you are only serializing a single object.
//               If you have many objects to process, it is more
//               efficient to use the same BamWriter to serialize all
//               of them together.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1915  
80 0 0 6 87 1905 0 0 770 ////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::encode_to_bam_stream
//       Access: Published
//  Description: Converts the TypedWritable object into a single
//               stream of data using a BamWriter, and stores that
//               data in the indicated string.  Returns true on
//               success, false on failure.
//
//               This is a convenience method particularly useful for
//               cases when you are only serializing a single object.
//               If you have many objects to process, it is more
//               efficient to use the same BamWriter to serialize all
//               of them together.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1915  4 data 1 1917  6 writer 1 1919  
81 0 0 7 89 1901 0 0 0 0 
82 0 0 7 96 1921 977 0 872 ////////////////////////////////////////////////////////////////////
//     Function: TypedWritableReferenceCount::decode_from_bam_stream
//       Access: Published, Static
//  Description: Reads the string created by a previous call to
//               encode_to_bam_stream(), and extracts and returns the
//               single object on that string.  Returns NULL on error.
//
//               This method is intended to replace
//               decode_raw_from_bam_stream() when you know the stream
//               in question returns an object of type
//               TypedWritableReferenceCount, allowing for easier
//               reference count management.  Note that the caller is
//               still responsible for maintaining the reference count
//               on the return value.
//////////////////////////////////////////////////////////////////// 2 4 data 1 1890  6 reader 1 1920  
83 0 0 7 97 1901 0 0 0 0 
84 0 0 6 91 1914 0 0 0 1 4 this 3 1921  
85 0 0 7 92 1921 977 0 0 1 4 this 3 1914  
86 0 0 7 94 1922 0 0 0 1 4 this 3 1921  
87 0 0 7 95 1921 977 0 0 1 4 this 3 1922  
88 0 0 7 106 1925 982 0 438 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::make_copy
//       Access: Published
//  Description: Returns a duplicate of the BamCacheRecord.  The
//               duplicate will not have a data pointer set, even
//               though one may have been assigned to the original via
//               set_data().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1923  
89 0 0 6 107 1905 0 0 0 2 4 this 3 1923  5 other 1 1923  
90 0 0 6 108 1926 0 0 523 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_source_pathname
//       Access: Published
//  Description: Returns the full pathname to the source file that
//               originally generated this cache request.  In some
//               cases, for instance in the case of a of a multipage
//               texture like "cube_#.png", this may not not a true
//               filename on disk.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1923  
91 0 0 6 109 1926 0 0 516 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_cache_filename
//       Access: Published
//  Description: Returns the name of the cache file as hashed from the
//               source_pathname.  This will be relative to the root
//               of the cache directory, and it will not include any
//               suffixes that may be appended to resolve hash
//               conflicts.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1923  
92 0 0 6 110 1929 0 0 473 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_source_timestamp
//       Access: Published
//  Description: Returns the file timestamp of the original source
//               file that generated this cache record, if available.
//               In some cases the original file timestamp is not
//               available, and this will return 0.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1923  
93 0 0 6 111 1929 0 0 323 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_recorded_time
//       Access: Published
//  Description: Returns the time at which this particular record was
//               recorded or updated.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1923  
94 0 0 6 112 1891 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_num_dependent_files
//       Access: Published
//  Description: Returns the number of source files that contribute to
//               the cache.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1923  
95 0 0 6 113 1926 0 0 335 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_dependent_pathname
//       Access: Published
//  Description: Returns the full pathname of the nth source files
//               that contributes to the cache.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1923  1 n 1 1891  
96 0 0 6 114 1905 0 0 380 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::dependents_unchanged
//       Access: Published
//  Description: Returns true if all of the dependent files are still
//               the same as when the cache was recorded, false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1923  
97 0 0 4 115 1894 0 0 323 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::clear_dependent_files
//       Access: Published
//  Description: Empties the list of files that contribute to the data
//               in this record.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1925  
98 0 0 4 116 1894 0 0 509 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::add_dependent_file
//       Access: Published
//  Description: Adds the indicated file to the list of files that
//               will be loaded to generate the data in this record.
//               This should be called once for the primary source
//               file, and again for each secondary source file, if
//               any.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1925  8 pathname 1 1926  
99 0 0 6 117 1905 0 0 373 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::has_data
//       Access: Published
//  Description: Returns true if this cache record has an in-memory
//               data object associated--that is, the object stored in
//               the cache.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1923  
100 0 0 4 118 1894 0 0 394 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::clear_data
//       Access: Published
//  Description: Removes the in-memory data object associated with
//               this record, if any.  This does not affect the
//               on-disk representation of the record.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1925  
101 0 0 6 119 1914 0 0 383 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_data
//       Access: Published
//  Description: Returns a pointer to the data stored in the
//               record, or NULL if there is no data.  The pointer is
//               not removed from the record.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1923  
102 0 0 4 121 1894 0 0 935 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::set_data
//       Access: Published
//  Description: Stores a new data object on the record.  You should
//               pass the same pointer twice, to both parameters; this
//               allows the C++ typecasting to automatically convert
//               the pointer into both a TypedWritable and a
//               ReferenceCount pointer, so that the BamCacheRecord
//               object can reliably manage the reference counts.
//
//               You may pass 0 or NULL as the second parameter.  If
//               you do this, the BamCacheRecord will not manage the
//               object's reference count; it will be up to you to
//               ensure the object is not deleted during the lifetime
//               of the BamCacheRecord object.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1925  3 ptr 1 1914  7 ref_ptr 1 1922  
103 0 0 4 121 1894 0 0 342 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::set_data
//       Access: Published
//  Description: This variant on set_data() is provided just to allow
//               Python code to pass a 0 as the second parameter.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1925  3 ptr 1 1914  5 dummy 1 1891  
104 0 0 4 122 1894 0 0 222 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 1923  3 out 1 1898  
105 0 0 4 123 1894 0 0 221 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::write
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 1923  3 out 1 1898  12 indent_level 1 1891  
106 0 0 7 124 1901 0 0 0 0 
107 0 0 7 100 1921 977 0 0 1 4 this 3 1925  
108 0 0 7 101 1925 982 0 0 1 4 this 3 1921  
109 0 0 7 126 1930 1003 0 220 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
110 0 0 4 128 1894 0 0 646 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_active
//       Access: Published
//  Description: Changes the state of the active flag.  "active" means
//               that the cache should be consulted automatically on
//               loads, "not active" means that objects should be
//               loaded directly without consulting the cache.
//
//               This represents the global flag.  Also see the
//               individual cache_models, cache_textures,
//               cache_compressed_textures flags.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1930  4 flag 1 1905  
111 0 0 6 129 1905 0 0 695 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_active
//       Access: Published
//  Description: Returns true if the BamCache is currently active,
//               false if it is not.  "active" means that the cache
//               should be consulted automatically on loads, "not
//               active" means that objects should be loaded directly
//               without consulting the cache.
//
//               This represents the global flag.  Also see the
//               individual cache_models, cache_textures,
//               cache_compressed_textures flags.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1931  
112 0 0 4 130 1894 0 0 346 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_models
//       Access: Published
//  Description: Indicates whether model files (e.g. egg files and bam
//               files) will be stored in the cache, as bam files.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1930  4 flag 1 1905  
113 0 0 6 131 1905 0 0 414 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_models
//       Access: Published
//  Description: Returns whether model files (e.g. egg files and bam
//               files) will be stored in the cache, as bam files.
//
//               This also returns false if get_active() is false.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1931  
114 0 0 4 132 1894 0 0 332 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_textures
//       Access: Published
//  Description: Indicates whether texture files will be stored in the
//               cache, as uncompressed txo files.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1930  4 flag 1 1905  
115 0 0 6 133 1905 0 0 418 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_textures
//       Access: Published
//  Description: Returns whether texture files (e.g. egg files and bam
//               files) will be stored in the cache, as txo files.
//
//               This also returns false if get_active() is false.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1931  
116 0 0 4 134 1894 0 0 1143 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_compressed_textures
//       Access: Published
//  Description: Indicates whether compressed texture files will be
//               stored in the cache, as compressed txo files.  The
//               compressed data may either be generated in-CPU, via
//               the squish library, or it may be extracted from the
//               GSG after the texture has been loaded.
//
//               This may be set in conjunction with
//               set_cache_textures(), or independently of it.  If
//               set_cache_textures() is true and this is false, all
//               textures will be cached in their uncompressed form.
//               If set_cache_textures() is false and this is true,
//               only compressed textures will be cached, and they
//               will be cached in their compressed form.  If both are
//               true, all textures will be cached, in their
//               uncompressed or compressed form appropriately.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1930  4 flag 1 1905  
117 0 0 6 135 1905 0 0 475 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_compressed_textures
//       Access: Published
//  Description: Returns whether compressed texture files will be
//               stored in the cache, as compressed txo files.  See
//               set_cache_compressed_textures().
//
//               This also returns false if get_active() is false.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1931  
118 0 0 4 136 1894 0 0 665 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_root
//       Access: Published
//  Description: Changes the current root pathname of the cache.  This
//               specifies where the cache files are stored on disk.
//               This should name a directory that is on a disk local
//               to the machine (not on a network-mounted disk), for
//               instance, /tmp/panda-cache or /c/panda-cache.
//
//               If the directory does not already exist, it will be
//               created as a result of this call.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1930  4 root 1 1926  
119 0 0 7 137 1933 0 0 299 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_root
//       Access: Published
//  Description: Returns the current root pathname of the cache.  See
//               set_root().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1931  
120 0 0 4 138 1894 0 0 316 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_flush_time
//       Access: Published
//  Description: Specifies the time in seconds between automatic
//               flushes of the cache index.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1930  10 flush_time 1 1891  
121 0 0 6 139 1891 0 0 314 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_flush_time
//       Access: Published
//  Description: Returns the time in seconds between automatic
//               flushes of the cache index.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1931  
122 0 0 4 140 1894 0 0 767 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_max_kbytes
//       Access: Published
//  Description: Specifies the maximum size, in kilobytes, which the
//               cache is allowed to grow to.  If a newly cached file
//               would exceed this size, an older file is removed from
//               the cache.
//
//               Note that in the case of multiple different processes
//               simultaneously operating on the same cache directory,
//               the actual cache size may slightly exceed this value
//               from time to time due to latency in checking between
//               the processes.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1930  10 max_kbytes 1 1891  
123 0 0 6 141 1891 0 0 371 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_max_kbytes
//       Access: Published
//  Description: Returns the maximum size, in kilobytes, which the
//               cache is allowed to grow to.  See
//               set_cache_max_kbytes().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1931  
124 0 0 4 142 1894 0 0 523 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_read_only
//       Access: Published
//  Description: Can be used to put the cache in read-only mode,
//               or take it out of read-only mode.  Note that if you
//               put it into read-write mode, and it discovers that
//               it does not have write access, it will put itself
//               right back into read-only mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1930  2 ro 1 1905  
125 0 0 6 143 1905 0 0 503 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_read_only
//       Access: Published
//  Description: Returns true if the cache is in read-only mode.
//               Normally, the cache starts in read-write mode.  It
//               can put itself into read-only mode automatically if
//               it discovers that it does not have write access to
//               the cache.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1931  
126 0 0 7 144 1925 982 0 1209 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::lookup
//       Access: Published
//  Description: Looks up a file in the cache.
//
//               If the file is cacheable, then regardless of whether
//               the file is found in the cache or not, this returns a
//               BamCacheRecord.  On the other hand, if the file
//               cannot be cached, returns NULL.
//
//               If record->has_data() returns true, then the file was
//               found in the cache, and you may call
//               record->extract_data() to get the object.  If
//               record->has_data() returns false, then the file was
//               not found in the cache or the cache was stale; and
//               you should reload the source file (calling
//               record->add_dependent_file() for each file loaded,
//               including the original source file), and then call
//               record->set_data() to record the resulting loaded
//               object; and finally, you should call store() to write
//               the cached record to disk.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1930  15 source_filename 1 1926  15 cache_extension 1 1890  
127 0 0 6 145 1905 0 0 478 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::store
//       Access: Published
//  Description: Flushes a cache entry to disk.  You must have
//               retrieved the cache record via a prior call to
//               lookup(), and then stored the data via
//               record->set_data().  Returns true on success, false
//               on failure.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1930  6 record 1 1925  
128 0 0 4 146 1894 0 0 325 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::consider_flush_index
//       Access: Published
//  Description: Flushes the index if enough time has elapsed since
//               the index was last flushed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1930  
129 0 0 4 147 1894 0 0 258 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::flush_index
//       Access: Published
//  Description: Ensures the index is written to disk.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1930  
130 0 0 4 148 1894 0 0 272 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::list_index
//       Access: Published
//  Description: Writes the contents of the index to standard output.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1931  3 out 1 1898  12 indent_level 1 1891  
131 0 0 6 149 1930 0 0 376 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_global_ptr
//       Access: Published, Static
//  Description: Returns a pointer to the global BamCache object,
//               which is used automatically by the ModelPool and
//               TexturePool.
//////////////////////////////////////////////////////////////////// 0 
132 0 0 4 150 1894 0 0 335 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::consider_flush_global_index
//       Access: Published, Static
//  Description: If there is a global BamCache object, calls
//               consider_flush_index() on it.
//////////////////////////////////////////////////////////////////// 0 
133 0 0 4 151 1894 0 0 317 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::flush_global_index
//       Access: Published, Static
//  Description: If there is a global BamCache object, calls
//               flush_index() on it.
//////////////////////////////////////////////////////////////////// 0 
134 0 0 7 160 1936 1040 0 230 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 1934  
135 0 0 7 160 1936 1040 0 225 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 5 flags 1 1891  
136 0 0 7 160 1936 1040 0 225 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 5 flags 1 1891  13 texture_flags 1 1891  
137 0 0 6 161 1936 0 0 0 2 4 this 3 1936  4 copy 1 1934  
138 0 0 4 162 1894 0 0 223 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_flags
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1936  5 flags 1 1891  
139 0 0 6 163 1891 0 0 223 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_flags
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 1934  
140 0 0 4 164 1894 0 0 231 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_texture_flags
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1936  5 flags 1 1891  
141 0 0 6 165 1891 0 0 231 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_texture_flags
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 1934  
142 0 0 4 166 1894 0 0 767 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_texture_num_views
//       Access: Published
//  Description: Specifies the expected number of views to load for
//               the texture.  This is ignored unless TF_multiview is
//               included in texture_flags.  This must be specified
//               when loading a 3-d multiview texture, in which case
//               it is used to differentiate z levels from separate
//               views; it may be zero in the case of 2-d textures or
//               cube maps, in which case the number of views can be
//               inferred from the number of images found on disk.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1936  9 num_views 1 1891  
143 0 0 6 167 1891 0 0 264 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_texture_num_views
//       Access: Published
//  Description: See set_texture_num_views().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1934  
144 0 0 4 168 1894 0 0 480 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_auto_texture_scale
//       Access: Published
//  Description: Set this flag to ATS_none, ATS_up, ATS_down, or
//               ATS_pad to control how a texture is scaled from
//               disk when it is subsequently loaded.  Set it to
//               ATS_unspecified to restore the default behavior.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1936  5 scale 1 1780  
145 0 0 6 169 1780 0 0 266 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_auto_texture_scale
//       Access: Published
//  Description: See set_auto_texture_scale().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1934  
146 0 0 4 170 1894 0 0 221 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 1934  3 out 1 1898  
147 0 0 7 173 1920 1042 0 221 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 6 source 1 1937  
148 0 0 4 175 1894 0 0 383 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::set_source
//       Access: Published
//  Description: Changes the source of future datagrams for this
//               BamReader.  This also implicitly calls init() if it
//               has not already been called.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1920  6 source 1 1937  
149 0 0 6 176 1937 0 0 324 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_source
//       Access: Published
//  Description: Returns the current source of the BamReader as set by
//               set_source() or the constructor.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1920  
150 0 0 6 177 1905 0 0 474 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::init
//       Access: Published
//  Description: Initializes the BamReader prior to reading any
//               objects from its source.  This includes reading the
//               Bam header.
//
//               This returns true if the BamReader successfully
//               initialized, false otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1920  
151 0 0 4 178 1894 0 0 1496 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::set_aux_data
//       Access: Published
//  Description: Associates an arbitrary block of data with the
//               indicated object (or NULL), and the indicated name.
//
//               This is intended to provide a place for temporary
//               storage for objects reading themselves from the bam
//               file.  To use it, inherit from BamReader::AuxData and
//               store whatever data you like there.  Then associate
//               your AuxData with the object as it is being read with
//               set_aux_data().  You may later set the aux data to
//               NULL to remove it; or it will automatically be
//               removed (and deleted) after finalize() is called for
//               the object in question.
//
//               If the TypedWritable pointer is NULL, the the aux
//               data is stored globally for the BamReader in general.
//               This pointer is available to any bam objects, and
//               will not be automatically removed until the BamReader
//               itself destructs.
//
//               In either case, the name is just an arbitrary
//               user-defined key.  If there is already a data pointer
//               stored for the obj/name pair, that data pointer will
//               be replaced (and deleted).
//////////////////////////////////////////////////////////////////// 4 4 this 3 1920  3 obj 1 1914  4 name 1 1890  4 data 1 1938  
152 0 0 7 179 1938 0 0 413 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_aux_data
//       Access: Published
//  Description: Returns the pointer previously associated with the
//               bam reader by a previous call to set_aux_data(), or
//               NULL if data with the indicated key has not been set.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1940  3 obj 1 1914  4 name 1 1890  
153 0 0 6 180 1926 0 0 457 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_filename
//       Access: Published
//  Description: If a BAM is a file, then the BamReader should
//               contain the name of the file.  This enables the
//               reader to interpret pathnames in the BAM as relative
//               to the directory containing the BAM.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1940  
154 0 0 6 181 1934 0 0 330 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_loader_options
//       Access: Published
//  Description: Returns the LoaderOptions passed to the loader when
//               the model was requested, if any.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1940  
155 0 0 4 182 1894 0 0 276 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::set_loader_options
//       Access: Published
//  Description: Specifies the LoaderOptions for this BamReader.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1920  7 options 1 1934  
156 0 0 6 183 1914 0 0 1569 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::read_object
//       Access: Published
//  Description: Reads a single object from the Bam file.  If the
//               object type is known, a new object of the appropriate
//               type is created and returned; otherwise, NULL is
//               returned.  NULL is also returned when the end of the
//               file is reached.  is_eof() may be called to
//               differentiate between these two cases.
//
//               This may be called repeatedly to extract out all the
//               objects in the Bam file, but typically (especially
//               for scene graph files, indicated with the .bam
//               extension), only one object is retrieved directly
//               from the Bam file: the root of the scene graph.  The
//               remaining objects will all be retrieved recursively
//               by the first object.
//
//               Note that the object returned may not yet be
//               complete.  In particular, some of its pointers may
//               not be filled in; you must call resolve() to fill in
//               all the available pointers before you can safely use
//               any objects returned by read_object().
//
//               This flavor of read_object() requires the caller to
//               know what type of object it has received in order to
//               properly manage the reference counts.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1920  
157 0 0 6 184 1905 0 0 375 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::is_eof
//       Access: Published
//  Description: Returns true if the reader has reached end-of-file,
//               false otherwise.  This call is only valid after a
//               call to read_object().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1940  
158 0 0 6 185 1905 0 0 935 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::resolve
//       Access: Published
//  Description: This may be called at any time during processing of
//               the Bam file to resolve all the known pointers so
//               far.  It is usually called at the end of the
//               processing, after all objects have been read, which
//               is generally the best time to call it.
//
//               This must be called at least once after reading a
//               particular object via get_object() in order to
//               validate that object.
//
//               The return value is true if all objects have been
//               resolved, or false if some objects are still
//               outstanding (in which case you will need to call
//               resolve() again later).
//////////////////////////////////////////////////////////////////// 1 4 this 3 1920  
159 0 0 6 186 1905 0 0 724 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::change_pointer
//       Access: Published
//  Description: Indicates that an object recently read from the bam
//               stream should be replaced with a new object.  Any
//               future occurrences of the original object in the
//               stream will henceforth return the new object instead.
//
//               The return value is true if the replacement was
//               successfully made, or false if the object was not
//               read from the stream (or if change_pointer had
//               already been called on it).
//////////////////////////////////////////////////////////////////// 3 4 this 3 1920  12 orig_pointer 1 1915  11 new_pointer 1 1915  
160 0 0 6 187 1891 0 0 316 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_major_ver
//       Access: Published
//  Description: Returns the major version number of the Bam file
//               currently being read.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1940  
161 0 0 6 188 1891 0 0 316 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_minor_ver
//       Access: Published
//  Description: Returns the minor version number of the Bam file
//               currently being read.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1940  
162 0 0 6 189 1790 0 0 528 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_endian
//       Access: Published
//  Description: Returns the endian preference indicated by the Bam
//               file currently being read.  This does not imply that
//               every number is stored using the indicated
//               convention, but individual objects may choose to
//               respect this flag when recording data.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1940  
163 0 0 6 190 1905 0 0 489 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_stdfloat_double
//       Access: Published
//  Description: Returns true if the file stores all "standard"
//               floats as 64-bit doubles, or false if they are 32-bit
//               floats.  This is determined by the compilation flags
//               of the version of Panda that generated this file.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1940  
164 0 0 6 191 1891 0 0 440 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_current_major_ver
//       Access: Published
//  Description: Returns the major version number of Bam files
//               supported by the current code base.  This must match
//               get_file_major_ver() in order to successfully read a
//               file.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1940  
165 0 0 6 192 1891 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_current_minor_ver
//       Access: Published
//  Description: Returns the minor version number of Bam files
//               supported by the current code base.  This must match
//               or exceed get_file_minor_ver() in order to
//               successfully read a file.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1940  
166 0 0 7 194 1919 1062 0 221 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 6 target 1 1942  
167 0 0 4 196 1894 0 0 394 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::set_target
//       Access: Published
//  Description: Changes the destination of future datagrams written
//               by the BamWriter.  This also implicitly calls init()
//               if it has not already been called.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1919  6 target 1 1942  
168 0 0 6 197 1942 0 0 324 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_target
//       Access: Published
//  Description: Returns the current target of the BamWriter as set by
//               set_target() or the constructor.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1919  
169 0 0 6 198 1905 0 0 483 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::init
//       Access: Published
//  Description: Initializes the BamWriter prior to writing any
//               objects to its output stream.  This includes writing
//               out the Bam header.
//
//               This returns true if the BamWriter successfully
//               initialized, false otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1919  
170 0 0 6 199 1926 0 0 455 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_filename
//       Access: Published
//  Description: If a BAM is a file, then the BamWriter should
//               contain the name of the file.  This enables the
//               writer to convert pathnames in the BAM to relative
//               to the directory containing the BAM.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1944  
171 0 0 6 200 1905 0 0 1153 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::write_object
//       Access: Published
//  Description: Writes a single object to the Bam file, so that the
//               BamReader::read_object() can later correctly restore
//               the object and all its pointers.
//
//               This implicitly also writes any additional objects
//               this object references (if they haven't already been
//               written), so that pointers may be fully resolved.
//
//               This may be called repeatedly to write a sequence of
//               objects to the Bam file, but typically (especially
//               for scene graph files, indicated with the .bam
//               extension), only one object is written directly from
//               the Bam file: the root of the scene graph.  The
//               remaining objects will all be written recursively by
//               the first object.
//
//               Returns true if the object is successfully written,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1919  3 obj 1 1915  
172 0 0 6 201 1905 0 0 408 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::has_object
//       Access: Published
//  Description: Returns true if the object has previously been
//               written (or at least requested to be written) to the
//               bam file, or false if we've never heard of it before.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1944  3 obj 1 1915  
173 0 0 4 202 1894 0 0 307 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::flush
//       Access: Published
//  Description: Ensures that all data written thus far is manifested
//               on the output stream.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1919  
174 0 0 6 203 1790 0 0 531 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_file_endian
//       Access: Published
//  Description: Returns the endian preference indicated by the Bam
//               file currently being written.  This does not imply
//               that every number is stored using the indicated
//               convention, but individual objects may choose to
//               respect this flag when recording data.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1944  
175 0 0 6 204 1905 0 0 531 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_file_stdfloat_double
//       Access: Published
//  Description: Returns true if the file will store all "standard"
//               floats as 64-bit doubles, or false if they are 32-bit
//               floats.  This isn't runtime settable; it's based on
//               the compilation flags of the version of Panda that
//               generated this file.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1944  
176 0 0 6 205 1792 0 0 462 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_file_texture_mode
//       Access: Published
//  Description: Returns the BamTextureMode preference indicated by
//               the Bam file currently being written.  Texture
//               objects written to this Bam file will be encoded
//               according to the specified mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1944  
177 0 0 4 206 1894 0 0 453 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::set_file_texture_mode
//       Access: Published
//  Description: Changes the BamTextureMode preference for
//               the Bam file currently being written.  Texture
//               objects written to this Bam file will be encoded
//               according to the specified mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1919  17 file_texture_mode 1 1792  
178 0 0 7 208 1946 1081 0 0 0 
179 0 0 7 208 1946 1081 0 0 1 4 copy 1 1947  
180 0 0 7 208 1946 1081 0 0 1 10 init_value 1 1949  
181 0 0 6 209 1946 0 0 0 2 4 this 3 1946  4 copy 1 1947  
182 0 0 7 210 1946 1081 0 0 0 
183 0 0 7 211 1946 1081 0 0 0 
184 0 0 7 212 1946 1081 0 0 1 7 on_bits 1 1891  
185 0 0 7 213 1946 1081 0 0 1 5 index 1 1891  
186 0 0 7 214 1946 1081 0 0 2 7 low_bit 1 1891  4 size 1 1891  
187 0 0 6 216 1905 0 0 0 0 
188 0 0 6 217 1891 0 0 0 0 
189 0 0 6 218 1891 0 0 0 0 
190 0 0 6 219 1905 0 0 0 2 4 this 3 1947  5 index 1 1891  
191 0 0 4 220 1894 0 0 0 2 4 this 3 1946  5 index 1 1891  
192 0 0 4 221 1894 0 0 0 2 4 this 3 1946  5 index 1 1891  
193 0 0 4 222 1894 0 0 0 3 4 this 3 1946  5 index 1 1891  5 value 1 1905  
194 0 0 6 223 1905 0 0 0 1 4 this 3 1947  
195 0 0 6 224 1905 0 0 0 1 4 this 3 1947  
196 0 0 6 225 1949 0 0 0 3 4 this 3 1947  7 low_bit 1 1891  4 size 1 1891  
197 0 0 4 226 1894 0 0 0 4 4 this 3 1946  5 value 1 1949  7 low_bit 1 1891  4 size 1 1891  
198 0 0 6 227 1905 0 0 0 3 4 this 3 1947  7 low_bit 1 1891  4 size 1 1891  
199 0 0 6 228 1905 0 0 0 3 4 this 3 1947  7 low_bit 1 1891  4 size 1 1891  
200 0 0 4 229 1894 0 0 0 3 4 this 3 1946  7 low_bit 1 1891  4 size 1 1891  
201 0 0 4 230 1894 0 0 0 3 4 this 3 1946  7 low_bit 1 1891  4 size 1 1891  
202 0 0 4 231 1894 0 0 0 4 4 this 3 1946  5 value 1 1905  7 low_bit 1 1891  4 size 1 1891  
203 0 0 6 232 1949 0 0 0 1 4 this 3 1947  
204 0 0 4 233 1894 0 0 0 2 4 this 3 1946  5 value 1 1949  
205 0 0 6 234 1891 0 0 0 1 4 this 3 1947  
206 0 0 6 235 1891 0 0 0 1 4 this 3 1947  
207 0 0 6 236 1891 0 0 0 1 4 this 3 1947  
208 0 0 6 237 1891 0 0 0 1 4 this 3 1947  
209 0 0 6 238 1891 0 0 0 1 4 this 3 1947  
210 0 0 6 239 1891 0 0 0 1 4 this 3 1947  
211 0 0 6 240 1891 0 0 0 2 4 this 3 1947  7 low_bit 1 1891  
212 0 0 4 241 1894 0 0 0 1 4 this 3 1946  
213 0 0 6 242 1905 0 0 0 2 4 this 3 1947  5 other 1 1947  
214 0 0 4 243 1894 0 0 0 1 4 this 3 1946  
215 0 0 4 244 1894 0 0 0 2 4 this 3 1947  3 out 1 1898  
216 0 0 4 245 1894 0 0 0 3 4 this 3 1947  3 out 1 1898  12 spaces_every 1 1891  
217 0 0 4 246 1894 0 0 0 3 4 this 3 1947  3 out 1 1898  12 spaces_every 1 1891  
218 0 0 4 247 1894 0 0 0 3 4 this 3 1947  3 out 1 1898  12 indent_level 1 1891  
219 0 0 6 248 1905 0 0 0 2 4 this 3 1947  5 other 1 1947  
220 0 0 6 249 1905 0 0 0 2 4 this 3 1947  5 other 1 1947  
221 0 0 6 250 1905 0 0 0 2 4 this 3 1947  5 other 1 1947  
222 0 0 6 251 1891 0 0 0 2 4 this 3 1947  5 other 1 1947  
223 0 0 7 252 1946 1081 0 0 2 4 this 3 1947  5 other 1 1947  
224 0 0 7 253 1946 1081 0 0 2 4 this 3 1947  5 other 1 1947  
225 0 0 7 254 1946 1081 0 0 2 4 this 3 1947  5 other 1 1947  
226 0 0 7 255 1946 1081 0 0 1 4 this 3 1947  
227 0 0 7 256 1946 1081 0 0 2 4 this 3 1947  5 shift 1 1891  
228 0 0 7 257 1946 1081 0 0 2 4 this 3 1947  5 shift 1 1891  
229 0 0 6 258 1946 0 0 0 2 4 this 3 1946  5 other 1 1947  
230 0 0 6 259 1946 0 0 0 2 4 this 3 1946  5 other 1 1947  
231 0 0 6 260 1946 0 0 0 2 4 this 3 1946  5 other 1 1947  
232 0 0 6 261 1946 0 0 0 2 4 this 3 1946  5 shift 1 1891  
233 0 0 6 262 1946 0 0 0 2 4 this 3 1946  5 shift 1 1891  
234 0 0 4 263 1894 0 0 0 1 4 this 3 1946  
235 0 0 4 264 1894 0 0 0 1 4 this 3 1946  
236 0 0 7 265 1946 1081 0 0 1 4 this 3 1947  
237 0 0 7 266 1946 1081 0 0 1 4 this 3 1947  
238 0 0 7 267 1946 1081 0 0 1 4 this 3 1947  
239 0 0 7 267 1946 1081 0 0 2 4 this 3 1947  5 other 1 1947  
240 0 0 7 267 1946 1081 0 0 2 4 this 3 1947  5 index 1 1891  
241 0 0 7 268 1946 1081 0 0 1 4 this 3 1947  
242 0 0 7 268 1946 1081 0 0 2 4 this 3 1947  5 other 1 1947  
243 0 0 7 268 1946 1081 0 0 2 4 this 3 1947  5 index 1 1891  
244 0 0 6 269 1891 0 0 0 1 4 this 3 1947  
245 0 0 6 270 1905 0 0 0 1 4 this 3 1947  
246 0 0 7 271 1901 0 0 0 0 
247 0 0 7 274 1950 1145 0 0 0 
248 0 0 7 274 1950 1145 0 0 1 4 copy 1 1951  
249 0 0 7 274 1950 1145 0 0 1 10 init_value 1 1953  
250 0 0 6 275 1950 0 0 0 2 4 this 3 1950  4 copy 1 1951  
251 0 0 7 276 1950 1145 0 0 0 
252 0 0 7 277 1950 1145 0 0 0 
253 0 0 7 278 1950 1145 0 0 1 7 on_bits 1 1891  
254 0 0 7 279 1950 1145 0 0 1 5 index 1 1891  
255 0 0 7 280 1950 1145 0 0 2 7 low_bit 1 1891  4 size 1 1891  
256 0 0 6 282 1905 0 0 0 0 
257 0 0 6 283 1891 0 0 0 0 
258 0 0 6 284 1891 0 0 0 0 
259 0 0 6 285 1905 0 0 0 2 4 this 3 1951  5 index 1 1891  
260 0 0 4 286 1894 0 0 0 2 4 this 3 1950  5 index 1 1891  
261 0 0 4 287 1894 0 0 0 2 4 this 3 1950  5 index 1 1891  
262 0 0 4 288 1894 0 0 0 3 4 this 3 1950  5 index 1 1891  5 value 1 1905  
263 0 0 6 289 1905 0 0 0 1 4 this 3 1951  
264 0 0 6 290 1905 0 0 0 1 4 this 3 1951  
265 0 0 6 291 1953 0 0 0 3 4 this 3 1951  7 low_bit 1 1891  4 size 1 1891  
266 0 0 4 292 1894 0 0 0 4 4 this 3 1950  5 value 1 1953  7 low_bit 1 1891  4 size 1 1891  
267 0 0 6 293 1905 0 0 0 3 4 this 3 1951  7 low_bit 1 1891  4 size 1 1891  
268 0 0 6 294 1905 0 0 0 3 4 this 3 1951  7 low_bit 1 1891  4 size 1 1891  
269 0 0 4 295 1894 0 0 0 3 4 this 3 1950  7 low_bit 1 1891  4 size 1 1891  
270 0 0 4 296 1894 0 0 0 3 4 this 3 1950  7 low_bit 1 1891  4 size 1 1891  
271 0 0 4 297 1894 0 0 0 4 4 this 3 1950  5 value 1 1905  7 low_bit 1 1891  4 size 1 1891  
272 0 0 6 298 1953 0 0 0 1 4 this 3 1951  
273 0 0 4 299 1894 0 0 0 2 4 this 3 1950  5 value 1 1953  
274 0 0 6 300 1891 0 0 0 1 4 this 3 1951  
275 0 0 6 301 1891 0 0 0 1 4 this 3 1951  
276 0 0 6 302 1891 0 0 0 1 4 this 3 1951  
277 0 0 6 303 1891 0 0 0 1 4 this 3 1951  
278 0 0 6 304 1891 0 0 0 1 4 this 3 1951  
279 0 0 6 305 1891 0 0 0 1 4 this 3 1951  
280 0 0 6 306 1891 0 0 0 2 4 this 3 1951  7 low_bit 1 1891  
281 0 0 4 307 1894 0 0 0 1 4 this 3 1950  
282 0 0 6 308 1905 0 0 0 2 4 this 3 1951  5 other 1 1951  
283 0 0 4 309 1894 0 0 0 1 4 this 3 1950  
284 0 0 4 310 1894 0 0 0 2 4 this 3 1951  3 out 1 1898  
285 0 0 4 311 1894 0 0 0 3 4 this 3 1951  3 out 1 1898  12 spaces_every 1 1891  
286 0 0 4 312 1894 0 0 0 3 4 this 3 1951  3 out 1 1898  12 spaces_every 1 1891  
287 0 0 4 313 1894 0 0 0 3 4 this 3 1951  3 out 1 1898  12 indent_level 1 1891  
288 0 0 6 314 1905 0 0 0 2 4 this 3 1951  5 other 1 1951  
289 0 0 6 315 1905 0 0 0 2 4 this 3 1951  5 other 1 1951  
290 0 0 6 316 1905 0 0 0 2 4 this 3 1951  5 other 1 1951  
291 0 0 6 317 1891 0 0 0 2 4 this 3 1951  5 other 1 1951  
292 0 0 7 318 1950 1145 0 0 2 4 this 3 1951  5 other 1 1951  
293 0 0 7 319 1950 1145 0 0 2 4 this 3 1951  5 other 1 1951  
294 0 0 7 320 1950 1145 0 0 2 4 this 3 1951  5 other 1 1951  
295 0 0 7 321 1950 1145 0 0 1 4 this 3 1951  
296 0 0 7 322 1950 1145 0 0 2 4 this 3 1951  5 shift 1 1891  
297 0 0 7 323 1950 1145 0 0 2 4 this 3 1951  5 shift 1 1891  
298 0 0 6 324 1950 0 0 0 2 4 this 3 1950  5 other 1 1951  
299 0 0 6 325 1950 0 0 0 2 4 this 3 1950  5 other 1 1951  
300 0 0 6 326 1950 0 0 0 2 4 this 3 1950  5 other 1 1951  
301 0 0 6 327 1950 0 0 0 2 4 this 3 1950  5 shift 1 1891  
302 0 0 6 328 1950 0 0 0 2 4 this 3 1950  5 shift 1 1891  
303 0 0 4 329 1894 0 0 0 1 4 this 3 1950  
304 0 0 4 330 1894 0 0 0 1 4 this 3 1950  
305 0 0 7 331 1950 1145 0 0 1 4 this 3 1951  
306 0 0 7 332 1950 1145 0 0 1 4 this 3 1951  
307 0 0 7 333 1950 1145 0 0 1 4 this 3 1951  
308 0 0 7 333 1950 1145 0 0 2 4 this 3 1951  5 other 1 1951  
309 0 0 7 333 1950 1145 0 0 2 4 this 3 1951  5 index 1 1891  
310 0 0 7 334 1950 1145 0 0 1 4 this 3 1951  
311 0 0 7 334 1950 1145 0 0 2 4 this 3 1951  5 other 1 1951  
312 0 0 7 334 1950 1145 0 0 2 4 this 3 1951  5 index 1 1891  
313 0 0 6 335 1891 0 0 0 1 4 this 3 1951  
314 0 0 6 336 1905 0 0 0 1 4 this 3 1951  
315 0 0 7 337 1901 0 0 0 0 
316 0 0 7 340 1954 1209 0 0 0 
317 0 0 7 340 1954 1209 0 0 1 4 copy 1 1955  
318 0 0 7 340 1954 1209 0 0 1 10 init_value 1 1957  
319 0 0 6 341 1954 0 0 0 2 4 this 3 1954  4 copy 1 1955  
320 0 0 7 342 1954 1209 0 0 0 
321 0 0 7 343 1954 1209 0 0 0 
322 0 0 7 344 1954 1209 0 0 1 7 on_bits 1 1891  
323 0 0 7 345 1954 1209 0 0 1 5 index 1 1891  
324 0 0 7 346 1954 1209 0 0 2 7 low_bit 1 1891  4 size 1 1891  
325 0 0 6 348 1905 0 0 0 0 
326 0 0 6 349 1891 0 0 0 0 
327 0 0 6 350 1891 0 0 0 0 
328 0 0 6 351 1905 0 0 0 2 4 this 3 1955  5 index 1 1891  
329 0 0 4 352 1894 0 0 0 2 4 this 3 1954  5 index 1 1891  
330 0 0 4 353 1894 0 0 0 2 4 this 3 1954  5 index 1 1891  
331 0 0 4 354 1894 0 0 0 3 4 this 3 1954  5 index 1 1891  5 value 1 1905  
332 0 0 6 355 1905 0 0 0 1 4 this 3 1955  
333 0 0 6 356 1905 0 0 0 1 4 this 3 1955  
334 0 0 6 357 1957 0 0 0 3 4 this 3 1955  7 low_bit 1 1891  4 size 1 1891  
335 0 0 4 358 1894 0 0 0 4 4 this 3 1954  5 value 1 1957  7 low_bit 1 1891  4 size 1 1891  
336 0 0 6 359 1905 0 0 0 3 4 this 3 1955  7 low_bit 1 1891  4 size 1 1891  
337 0 0 6 360 1905 0 0 0 3 4 this 3 1955  7 low_bit 1 1891  4 size 1 1891  
338 0 0 4 361 1894 0 0 0 3 4 this 3 1954  7 low_bit 1 1891  4 size 1 1891  
339 0 0 4 362 1894 0 0 0 3 4 this 3 1954  7 low_bit 1 1891  4 size 1 1891  
340 0 0 4 363 1894 0 0 0 4 4 this 3 1954  5 value 1 1905  7 low_bit 1 1891  4 size 1 1891  
341 0 0 6 364 1957 0 0 0 1 4 this 3 1955  
342 0 0 4 365 1894 0 0 0 2 4 this 3 1954  5 value 1 1957  
343 0 0 6 366 1891 0 0 0 1 4 this 3 1955  
344 0 0 6 367 1891 0 0 0 1 4 this 3 1955  
345 0 0 6 368 1891 0 0 0 1 4 this 3 1955  
346 0 0 6 369 1891 0 0 0 1 4 this 3 1955  
347 0 0 6 370 1891 0 0 0 1 4 this 3 1955  
348 0 0 6 371 1891 0 0 0 1 4 this 3 1955  
349 0 0 6 372 1891 0 0 0 2 4 this 3 1955  7 low_bit 1 1891  
350 0 0 4 373 1894 0 0 0 1 4 this 3 1954  
351 0 0 6 374 1905 0 0 0 2 4 this 3 1955  5 other 1 1955  
352 0 0 4 375 1894 0 0 0 1 4 this 3 1954  
353 0 0 4 376 1894 0 0 0 2 4 this 3 1955  3 out 1 1898  
354 0 0 4 377 1894 0 0 0 3 4 this 3 1955  3 out 1 1898  12 spaces_every 1 1891  
355 0 0 4 378 1894 0 0 0 3 4 this 3 1955  3 out 1 1898  12 spaces_every 1 1891  
356 0 0 4 379 1894 0 0 0 3 4 this 3 1955  3 out 1 1898  12 indent_level 1 1891  
357 0 0 6 380 1905 0 0 0 2 4 this 3 1955  5 other 1 1955  
358 0 0 6 381 1905 0 0 0 2 4 this 3 1955  5 other 1 1955  
359 0 0 6 382 1905 0 0 0 2 4 this 3 1955  5 other 1 1955  
360 0 0 6 383 1891 0 0 0 2 4 this 3 1955  5 other 1 1955  
361 0 0 7 384 1954 1209 0 0 2 4 this 3 1955  5 other 1 1955  
362 0 0 7 385 1954 1209 0 0 2 4 this 3 1955  5 other 1 1955  
363 0 0 7 386 1954 1209 0 0 2 4 this 3 1955  5 other 1 1955  
364 0 0 7 387 1954 1209 0 0 1 4 this 3 1955  
365 0 0 7 388 1954 1209 0 0 2 4 this 3 1955  5 shift 1 1891  
366 0 0 7 389 1954 1209 0 0 2 4 this 3 1955  5 shift 1 1891  
367 0 0 6 390 1954 0 0 0 2 4 this 3 1954  5 other 1 1955  
368 0 0 6 391 1954 0 0 0 2 4 this 3 1954  5 other 1 1955  
369 0 0 6 392 1954 0 0 0 2 4 this 3 1954  5 other 1 1955  
370 0 0 6 393 1954 0 0 0 2 4 this 3 1954  5 shift 1 1891  
371 0 0 6 394 1954 0 0 0 2 4 this 3 1954  5 shift 1 1891  
372 0 0 4 395 1894 0 0 0 1 4 this 3 1954  
373 0 0 4 396 1894 0 0 0 1 4 this 3 1954  
374 0 0 7 397 1954 1209 0 0 1 4 this 3 1955  
375 0 0 7 398 1954 1209 0 0 1 4 this 3 1955  
376 0 0 7 399 1954 1209 0 0 1 4 this 3 1955  
377 0 0 7 399 1954 1209 0 0 2 4 this 3 1955  5 other 1 1955  
378 0 0 7 399 1954 1209 0 0 2 4 this 3 1955  5 index 1 1891  
379 0 0 7 400 1954 1209 0 0 1 4 this 3 1955  
380 0 0 7 400 1954 1209 0 0 2 4 this 3 1955  5 other 1 1955  
381 0 0 7 400 1954 1209 0 0 2 4 this 3 1955  5 index 1 1891  
382 0 0 6 401 1891 0 0 0 1 4 this 3 1955  
383 0 0 6 402 1905 0 0 0 1 4 this 3 1955  
384 0 0 7 403 1901 0 0 0 0 
385 0 0 7 408 1959 1273 0 220 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
386 0 0 7 408 1959 1273 0 225 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 1960  
387 0 0 7 408 1959 1273 0 0 1 10 init_value 1 1962  
388 0 0 7 408 1959 1273 0 239 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Constructor (from SparseArray)
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 from 1 1963  
389 0 0 6 409 1959 0 0 233 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Copy Assignment Operator
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1959  4 copy 1 1960  
390 0 0 7 410 1959 1273 0 317 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a BitArray with an infinite array of bits,
//               all on.
//////////////////////////////////////////////////////////////////// 0 
391 0 0 7 411 1959 1273 0 284 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a BitArray whose bits are all off.
//////////////////////////////////////////////////////////////////// 0 
392 0 0 7 412 1959 1273 0 295 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named lower_on constructor
//       Access: Published, Static
//  Description: Returns a BitArray whose lower on_bits bits are on.
//////////////////////////////////////////////////////////////////// 1 7 on_bits 1 1891  
393 0 0 7 413 1959 1273 0 289 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named bit constructor
//       Access: Published, Static
//  Description: Returns a BitArray with only the indicated bit on.
//////////////////////////////////////////////////////////////////// 1 5 index 1 1891  
394 0 0 7 414 1959 1273 0 323 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named range constructor
//       Access: Published, Static
//  Description: Returns a BitArray whose size bits, beginning at
//               low_bit, are on.
//////////////////////////////////////////////////////////////////// 2 7 low_bit 1 1891  4 size 1 1891  
395 0 0 6 416 1905 0 0 714 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_max_num_bits
//       Access: Published, Static
//  Description: Returns true if there is a maximum number of bits
//               that may be stored in this structure, false
//               otherwise.  If this returns true, the number may be
//               queried in get_max_num_bits().
//
//               This method always returns false.  The BitArray has
//               no maximum number of bits.  This method is defined so
//               generic programming algorithms can use BitMask or
//               BitArray interchangeably.
//////////////////////////////////////////////////////////////////// 0 
396 0 0 6 417 1891 0 0 749 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_max_num_bits
//       Access: Published, Static
//  Description: If get_max_num_bits() returned true, this method may
//               be called to return the maximum number of bits that
//               may be stored in this structure.  It is an error to
//               call this if get_max_num_bits() return false.
//
//               It is always an error to call this method.  The
//               BitArray has no maximum number of bits.  This method
//               is defined so generic programming algorithms can use
//               BitMask or BitArray interchangeably.
//////////////////////////////////////////////////////////////////// 0 
397 0 0 6 418 1891 0 0 476 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_bits_per_word
//       Access: Published, Static
//  Description: Returns the number of bits stored per word
//               internally.  This is of interest only in that it
//               limits the maximum number of bits that may be queried
//               or set at once by extract() and store().
//////////////////////////////////////////////////////////////////// 0 
398 0 0 6 419 1891 0 0 604 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_bits
//       Access: Published
//  Description: Returns the current number of possibly different bits
//               in this array.  There are actually an infinite number
//               of bits, but every bit higher than this bit will have
//               the same value, either 0 or 1 (see
//               get_highest_bits()).
//
//               This number may grow and/or shrink automatically as
//               needed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1960  
399 0 0 6 420 1905 0 0 442 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_bit
//       Access: Published
//  Description: Returns true if the nth bit is set, false if it is
//               cleared.  It is valid for n to increase beyond
//               get_num_bits(), but the return value get_num_bits()
//               will always be the same.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1960  5 index 1 1891  
400 0 0 4 421 1894 0 0 317 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_bit
//       Access: Published
//  Description: Sets the nth bit on.  If n >= get_num_bits(), this
//               automatically extends the array.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1959  5 index 1 1891  
401 0 0 4 422 1894 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::clear_bit
//       Access: Published
//  Description: Sets the nth bit off.  If n >= get_num_bits(), this
//               automatically extends the array.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1959  5 index 1 1891  
402 0 0 4 423 1894 0 0 310 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_bit_to
//       Access: Published
//  Description: Sets the nth bit either on or off, according to the
//               indicated bool value.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1959  5 index 1 1891  5 value 1 1905  
403 0 0 6 424 1905 0 0 364 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_highest_bits
//       Access: Published
//  Description: Returns true if the infinite set of bits beyond
//               get_num_bits() are all on, or false of they are all
//               off.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1960  
404 0 0 6 425 1905 0 0 294 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::is_zero
//       Access: Published
//  Description: Returns true if the entire bitmask is zero, false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1960  
405 0 0 6 426 1905 0 0 295 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::is_all_on
//       Access: Published
//  Description: Returns true if the entire bitmask is one, false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1960  
406 0 0 6 427 1962 0 0 438 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::extract
//       Access: Published
//  Description: Returns a word that represents only the indicated
//               range of bits within this BitArray, shifted to the
//               least-significant position.  size must be <=
//               get_num_bits_per_word().
//////////////////////////////////////////////////////////////////// 3 4 this 3 1960  7 low_bit 1 1891  4 size 1 1891  
407 0 0 4 428 1894 0 0 310 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::store
//       Access: Published
//  Description: Stores the indicated word into the indicated range of
//               bits with this BitArray.
//////////////////////////////////////////////////////////////////// 4 4 this 3 1959  5 value 1 1962  7 low_bit 1 1891  4 size 1 1891  
408 0 0 6 429 1905 0 0 308 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_any_of
//       Access: Published
//  Description: Returns true if any bit in the indicated range is
//               set, false otherwise.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1960  7 low_bit 1 1891  4 size 1 1891  
409 0 0 6 430 1905 0 0 310 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_all_of
//       Access: Published
//  Description: Returns true if all bits in the indicated range are
//               set, false otherwise.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1960  7 low_bit 1 1891  4 size 1 1891  
410 0 0 4 431 1894 0 0 255 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_range
//       Access: Published
//  Description: Sets the indicated range of bits on.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1959  7 low_bit 1 1891  4 size 1 1891  
411 0 0 4 432 1894 0 0 258 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::clear_range
//       Access: Published
//  Description: Sets the indicated range of bits off.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1959  7 low_bit 1 1891  4 size 1 1891  
412 0 0 4 433 1894 0 0 275 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_range_to
//       Access: Published
//  Description: Sets the indicated range of bits to either on or off.
//////////////////////////////////////////////////////////////////// 4 4 this 3 1959  5 value 1 1905  7 low_bit 1 1891  4 size 1 1891  
413 0 0 6 434 1891 0 0 372 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_on_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 1 in the
//               array.  Returns -1 if there are an infinite number of
//               1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1960  
414 0 0 6 435 1891 0 0 373 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_off_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 0 in the
//               array.  Returns -1 if there are an infinite number of
//               0 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1960  
415 0 0 6 436 1891 0 0 330 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_lowest_on_bit
//       Access: Published
//  Description: Returns the index of the lowest 1 bit in the array.
//               Returns -1 if there are no 1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1960  
416 0 0 6 437 1891 0 0 331 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_lowest_off_bit
//       Access: Published
//  Description: Returns the index of the lowest 0 bit in the array.
//               Returns -1 if there are no 0 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1960  
417 0 0 6 438 1891 0 0 390 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_highest_on_bit
//       Access: Published
//  Description: Returns the index of the highest 1 bit in the array.
//               Returns -1 if there are no 1 bits or if there an
//               infinite number of 1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1960  
418 0 0 6 439 1891 0 0 391 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_highest_off_bit
//       Access: Published
//  Description: Returns the index of the highest 0 bit in the array.
//               Returns -1 if there are no 0 bits or if there an
//               infinite number of 1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1960  
419 0 0 6 440 1891 0 0 591 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_next_higher_different_bit
//       Access: Published
//  Description: Returns the index of the next bit in the array, above
//               low_bit, whose value is different that the value of
//               low_bit.  Returns low_bit again if all bits higher
//               than low_bit have the same value.
//
//               This can be used to quickly iterate through all of
//               the bits in the array.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1960  7 low_bit 1 1891  
420 0 0 6 441 1891 0 0 304 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_words
//       Access: Published
//  Description: Returns the number of possibly-unique words stored in
//               the array.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1960  
421 0 0 7 442 1966 0 0 410 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_word
//       Access: Published
//  Description: Returns the nth word in the array.  It is valid for n
//               to be greater than get_num_words(), but the return
//               value beyond get_num_words() will always be the same.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1960  1 n 1 1891  
422 0 0 4 443 1894 0 0 351 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_word
//       Access: Published
//  Description: Replaces the nth word in the array.  If n >=
//               get_num_words(), this automatically extends the
//               array.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1959  1 n 1 1891  5 value 1 1962  
423 0 0 4 444 1894 0 0 318 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::invert_in_place
//       Access: Published
//  Description: Inverts all the bits in the BitArray.  This is
//               equivalent to array = ~array.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1959  
424 0 0 6 445 1905 0 0 440 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_bits_in_common
//       Access: Published
//  Description: Returns true if this BitArray has any "one" bits in
//               common with the other one, false otherwise.
//
//               This is equivalent to (array & other) != 0, but may
//               be faster.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1960  5 other 1 1960  
425 0 0 4 446 1894 0 0 253 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::clear
//       Access: Published
//  Description: Sets all the bits in the BitArray off.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1959  
426 0 0 4 447 1894 0 0 443 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::output
//       Access: Published
//  Description: Writes the BitArray out as a hex number.  For a
//               BitArray, this is always the same as output_hex();
//               it's too confusing for the output format to change
//               back and forth at runtime.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1960  3 out 1 1898  
427 0 0 4 448 1894 0 0 312 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::output_binary
//       Access: Published
//  Description: Writes the BitArray out as a binary number, with
//               spaces every four bits.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1960  3 out 1 1898  12 spaces_every 1 1891  
428 0 0 4 449 1894 0 0 316 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::output_hex
//       Access: Published
//  Description: Writes the BitArray out as a hexadecimal number, with
//               spaces every four digits.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1960  3 out 1 1898  12 spaces_every 1 1891  
429 0 0 4 450 1894 0 0 317 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::write
//       Access: Published
//  Description: Writes the BitArray out as a binary or a hex number,
//               according to the number of bits.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1960  3 out 1 1898  12 indent_level 1 1891  
430 0 0 6 451 1905 0 0 0 2 4 this 3 1960  5 other 1 1960  
431 0 0 6 452 1905 0 0 0 2 4 this 3 1960  5 other 1 1960  
432 0 0 6 453 1905 0 0 0 2 4 this 3 1960  5 other 1 1960  
433 0 0 6 454 1891 0 0 487 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::compare_to
//       Access: Published
//  Description: Returns a number less than zero if this BitArray sorts
//               before the indicated other BitArray, greater than zero
//               if it sorts after, or 0 if they are equivalent.  This
//               is based on the same ordering defined by operator <.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1960  5 other 1 1960  
434 0 0 7 455 1959 1273 0 0 2 4 this 3 1960  5 other 1 1960  
435 0 0 7 456 1959 1273 0 0 2 4 this 3 1960  5 other 1 1960  
436 0 0 7 457 1959 1273 0 0 2 4 this 3 1960  5 other 1 1960  
437 0 0 7 458 1959 1273 0 0 1 4 this 3 1960  
438 0 0 7 459 1959 1273 0 0 2 4 this 3 1960  5 shift 1 1891  
439 0 0 7 460 1959 1273 0 0 2 4 this 3 1960  5 shift 1 1891  
440 0 0 6 461 1959 0 0 0 2 4 this 3 1959  5 other 1 1960  
441 0 0 6 462 1959 0 0 0 2 4 this 3 1959  5 other 1 1960  
442 0 0 6 463 1959 0 0 0 2 4 this 3 1959  5 other 1 1960  
443 0 0 6 464 1959 0 0 0 2 4 this 3 1959  5 shift 1 1891  
444 0 0 6 465 1959 0 0 0 2 4 this 3 1959  5 shift 1 1891  
445 0 0 7 466 1901 0 0 0 0 
446 0 0 7 468 1967 1344 0 539 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Constructor
//       Access: Published
//  Description: The default constructor must do nothing, because we
//               can't guarantee ordering of static initializers.  If
//               the constructor tried to initialize its value, it
//               might happen after the value had already been set
//               previously by another static initializer!
//////////////////////////////////////////////////////////////////// 0 
447 0 0 7 468 1967 1344 0 229 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 1968  
448 0 0 7 468 1967 1344 0 399 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Constructor
//       Access: Published
//  Description: Constructs a ButtonHandle with the corresponding
//               index number, which may have been returned by an
//               earlier call to ButtonHandle::get_index().
//////////////////////////////////////////////////////////////////// 1 5 index 1 1891  
449 0 0 7 468 1967 1344 0 644 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Constructor
//       Access: Published
//  Description: Constructs a ButtonHandle with the corresponding
//               name, which is looked up in the ButtonRegistry.
//               This exists for the purpose of being able to
//               automatically coerce a string into a ButtonHandle;
//               for most purposes, you should use either the static
//               KeyboardButton/MouseButton getters or
//               ButtonRegistry::register_button().
//////////////////////////////////////////////////////////////////// 1 4 name 1 1890  
450 0 0 6 469 1905 0 0 0 2 4 this 3 1968  5 other 1 1968  
451 0 0 6 470 1905 0 0 0 2 4 this 3 1968  5 other 1 1968  
452 0 0 6 471 1905 0 0 0 2 4 this 3 1968  5 other 1 1968  
453 0 0 6 472 1905 0 0 0 2 4 this 3 1968  5 other 1 1968  
454 0 0 6 473 1905 0 0 0 2 4 this 3 1968  5 other 1 1968  
455 0 0 6 474 1905 0 0 0 2 4 this 3 1968  5 other 1 1968  
456 0 0 6 475 1891 0 0 467 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::compare_to
//       Access: Published
//  Description: Sorts ButtonHandles arbitrarily (according to <, >,
//               etc.).  Returns a number less than 0 if this type
//               sorts before the other one, greater than zero if it
//               sorts after, 0 if they are equivalent.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1968  5 other 1 1968  
457 0 0 6 476 1886 0 0 265 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_hash
//       Access: Published
//  Description: Returns a hash code suitable for phash_map.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1968  
458 0 0 6 477 1890 0 0 250 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_name
//       Access: Public
//  Description: Returns the name of the button.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1968  
459 0 0 6 478 1905 0 0 375 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::has_ascii_equivalent
//       Access: Published
//  Description: Returns true if the button was created with an ASCII
//               equivalent code (e.g. for a standard keyboard
//               button).
//////////////////////////////////////////////////////////////////// 1 4 this 3 1968  
460 0 0 6 479 1970 0 0 346 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_ascii_equivalent
//       Access: Published
//  Description: Returns the character code associated with the
//               button, or '\0' if no ASCII code was associated.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1968  
461 0 0 7 480 1967 1344 0 692 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_alias
//       Access: Published
//  Description: Returns the alias (alternate name) associated with
//               the button, if any, or ButtonHandle::none() if the
//               button has no alias.
//
//               Each button is allowed to have one alias, and
//               multiple different buttons can refer to the same
//               alias.  The alias should be the more general name for
//               the button, for instance, shift is an alias for
//               lshift, but not vice-versa.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1968  
462 0 0 6 481 1905 0 0 532 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::matches
//       Access: Published
//  Description: Returns true if this ButtonHandle is the same as the
//               other one, or if the other one is an alias for this
//               one.  (Does not return true if this button is an
//               alias for the other one, however.)
//
//               This is a more general comparison than operator ==.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1968  5 other 1 1968  
463 0 0 6 482 1891 0 0 664 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_index
//       Access: Published
//  Description: Returns the integer index associated with this
//               ButtonHandle. Each different ButtonHandle will have a
//               different index.  However, you probably shouldn't be
//               using this method; you should just treat the
//               ButtonHandles as opaque classes.  This is provided
//               for the convenience of non-C++ scripting languages to
//               build a hashtable of ButtonHandles.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1968  
464 0 0 4 483 1894 0 0 219 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::output
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1968  3 out 1 1898  
465 0 0 7 484 1967 1344 0 321 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::none
//       Access: Published, Static
//  Description: Returns a special zero-valued ButtonHandle that is
//               used to indicate no button.
//////////////////////////////////////////////////////////////////// 0 
466 0 0 7 486 1901 0 0 0 0 
467 0 0 6 485 1905 0 0 0 1 4 this 3 1968  
468 0 0 7 489 1967 1344 0 396 ////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::get_button
//       Access: Published
//  Description: Finds a ButtonHandle in the registry matching the
//               indicated name.  If there is no such ButtonHandle,
//               registers a new one and returns it.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1971  4 name 1 1890  
469 0 0 7 490 1967 1344 0 391 ////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::find_button
//       Access: Published
//  Description: Finds a ButtonHandle in the registry matching the
//               indicated name.  If there is no such ButtonHandle,
//               returns ButtonHandle::none().
//////////////////////////////////////////////////////////////////// 2 4 this 3 1971  4 name 1 1890  
470 0 0 7 491 1967 1344 0 419 ////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::find_ascii_button
//       Access: Published
//  Description: Finds a ButtonHandle in the registry matching the
//               indicated ASCII equivalent character.  If there is no
//               such ButtonHandle, returns ButtonHandle::none().
//////////////////////////////////////////////////////////////////// 2 4 this 3 1972  16 ascii_equivalent 1 1970  
471 0 0 4 492 1894 0 0 220 ////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::write
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1972  3 out 1 1898  
472 0 0 6 493 1971 0 0 300 ////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::ptr
//       Access: Published, Static
//  Description: Returns the pointer to the global ButtonRegistry
//               object.
//////////////////////////////////////////////////////////////////// 0 
473 0 0 6 497 1891 0 0 308 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_num_buttons
//       Access: Published
//  Description: Returns the number of buttons that this button
//               mapping specifies.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1974  
474 0 0 7 498 1967 1344 0 307 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_raw_button
//       Access: Published
//  Description: Returns the underlying raw button associated with
//               the nth button.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1974  1 i 1 1891  
475 0 0 7 499 1967 1344 0 411 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button
//       Access: Published
//  Description: Returns the button that the given button is mapped
//               to, or ButtonHandle::none() if this map does not
//               specify a mapped button for the given raw button.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1974  3 raw 1 1967  
476 0 0 7 499 1967 1344 0 332 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button
//       Access: Published
//  Description: Returns the nth mapped button, meaning the button
//               that the nth raw button is mapped to.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1974  1 i 1 1891  
477 0 0 7 499 1967 1344 0 411 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button
//       Access: Published
//  Description: Returns the button that the given button is mapped
//               to, or ButtonHandle::none() if this map does not
//               specify a mapped button for the given raw button.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1974  8 raw_name 1 1890  
478 0 0 6 500 1890 0 0 664 ////////////////////////////////////////////////////////////////////
//     Function: ButtoMap::get_mapped_button_label
//       Access: Published
//  Description: If the button map specifies a special name for the
//               button (eg. if the operating system or keyboard
//               device has a localized name describing the key),
//               returns it, or the empty string otherwise.
//
//               Note that this is not the same as
//               get_mapped_button().get_name(), which returns the
//               name of the Panda event associated with the button.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1974  3 raw 1 1967  
479 0 0 6 500 1890 0 0 381 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button_label
//       Access: Published
//  Description: Returns the label associated with the nth mapped
//               button, meaning the button that the nth raw
//               button is mapped to.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1974  1 i 1 1891  
480 0 0 6 500 1890 0 0 664 ////////////////////////////////////////////////////////////////////
//     Function: ButtoMap::get_mapped_button_label
//       Access: Published
//  Description: If the button map specifies a special name for the
//               button (eg. if the operating system or keyboard
//               device has a localized name describing the key),
//               returns it, or the empty string otherwise.
//
//               Note that this is not the same as
//               get_mapped_button().get_name(), which returns the
//               name of the Panda event associated with the button.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1974  8 raw_name 1 1890  
481 0 0 4 501 1894 0 0 217 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 1974  3 out 1 1898  
482 0 0 4 502 1894 0 0 216 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::write
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 1974  3 out 1 1898  12 indent_level 1 1891  
483 0 0 7 503 1901 0 0 0 0 
484 0 0 4 506 1894 0 0 230 ////////////////////////////////////////////////////////////////////
//     Function: CallbackObject::output
//       Access: Published, Virtual
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1976  3 out 1 1898  
485 0 0 7 507 1978 1362 0 0 1 8 function 1 1883  
486 0 0 7 508 1901 0 0 0 0 
487 0 0 6 511 1891 0 0 290 ////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::get_cache_ref_count
//       Access: Published
//  Description: Returns the current reference count.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1979  
488 0 0 4 512 1894 0 0 355 ////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::cache_ref
//       Access: Published
//  Description: Explicitly increments the cache reference count and
//               the normal reference count simultaneously.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1979  
489 0 0 6 513 1905 0 0 479 ////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::cache_unref
//       Access: Published
//  Description: Explicitly decrements the cache reference count and
//               the normal reference count simultaneously.
//
//               The return value is true if the new reference count
//               is nonzero, false if it is zero.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1979  
490 0 0 6 514 1905 0 0 359 ////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::test_ref_count_integrity
//       Access: Published
//  Description: Does some easy checks to make sure that the reference
//               count isn't completely bogus.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1979  
491 0 0 7 515 1901 0 0 0 0 
492 0 0 4 517 1894 0 0 228 ////////////////////////////////////////////////////////////////////
//     Function: CallbackData::output
//       Access: Published, Virtual
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1981  3 out 1 1898  
493 0 0 4 518 1894 0 0 408 ////////////////////////////////////////////////////////////////////
//     Function: CallbackData::upcall
//       Access: Published, Virtual
//  Description: You should make this call during the callback if you
//               want to continue the normal function that would have
//               been done in the absence of a callback.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1983  
494 0 0 7 519 1901 0 0 0 0 
495 0 0 7 522 1984 1362 0 0 1 8 function 1 1883  
496 0 0 4 523 1894 0 0 0 2 4 this 3 1984  4 size 1 1886  
497 0 0 4 526 1894 0 0 0 2 4 this 3 1984  8 function 1 1883  
498 0 0 6 527 1883 0 0 0 1 4 this 3 1984  
499 0 0 7 528 1901 0 0 0 0 
500 0 0 7 530 1985 1384 0 218 ////////////////////////////////////////////////////////////////////
//     Function: TimeVal::contructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
501 0 0 6 531 1817 0 0 215 ////////////////////////////////////////////////////////////////////
//     Function: TimeVal::get_sec
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 1986  
502 0 0 6 532 1817 0 0 216 ////////////////////////////////////////////////////////////////////
//     Function: TimeVal::get_usec
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 1986  
503 0 0 4 537 1894 0 0 0 2 4 this 3 1985  5 value 1 1816  
504 0 0 6 536 1816 0 0 0 1 4 this 3 1986  
505 0 0 7 542 1988 0 0 223 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
506 0 0 7 542 1988 0 0 229 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 1989  
507 0 0 4 543 1894 0 0 2596 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_mode
//       Access: Published
//  Description: Changes the mode of the clock.  Normally, the clock
//               is in mode M_normal. In this mode, each call to
//               tick() will set the value returned by
//               get_frame_time() to the current real time; thus, the
//               clock simply reports time advancing.
//
//               Other possible modes:
//
//               M_non_real_time - the clock ignores real time
//               completely; at each call to tick(), it pretends that
//               exactly dt seconds have elapsed since the last call
//               to tick().  You may set the value of dt with
//               set_dt() or set_frame_rate().
//
//               M_limited - the clock will run as fast as it can, as
//               in M_normal, but will not run faster than the rate
//               specified by set_frame_rate().  If the application
//               would run faster than this rate, the clock will slow
//               down the application.
//
//               M_integer - the clock will run as fast as it can, but
//               the rate will be constrained to be an integer
//               multiple or divisor of the rate specified by
//               set_frame_rate().  The clock will slow down the
//               application a bit to guarantee this.
//
//               M_integer_limited - a combination of M_limited and
//               M_integer; the clock will not run faster than
//               set_frame_rate(), and if it runs slower, it will run
//               at a integer divisor of that rate.
//
//               M_forced - the clock forces the application to run at
//               the rate specified by set_frame_rate().  If the
//               application would run faster than this rate, the
//               clock will slow down the application; if the
//               application would run slower than this rate, the
//               clock slows down time so that the application
//               believes it is running at the given rate.
//
//               M_degrade - the clock runs at real time, but the
//               application is slowed down by a set factor of its
//               frame rate, specified by set_degrade_factor().
//
//               M_slave - the clock does not advance, but relies on
//               the user to call set_frame_time() and/or
//               set_frame_count() each frame.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1988  4 mode 1 1820  
508 0 0 6 544 1820 0 0 293 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_mode
//       Access: Published
//  Description: Returns the current mode of the clock.  See
//               set_mode().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1989  
509 0 0 6 545 1904 0 0 656 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_frame_time
//       Access: Published
//  Description: Returns the time in seconds as of the last time
//               tick() was called (typically, this will be as of the
//               start of the current frame).
//
//               This is generally the kind of time you want to ask
//               for in most rendering and animation contexts, since
//               it's important that all of the animation for a given
//               frame remains in sync with each other.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1989  14 current_thread 1 1991  
510 0 0 6 546 1904 0 0 769 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_real_time
//       Access: Published
//  Description: Returns the actual number of seconds elapsed since
//               the ClockObject was created, or since it was last
//               reset.  This is useful for doing real timing
//               measurements, e.g. for performance statistics.
//
//               This returns the most precise timer we have for short
//               time intervals, but it may tend to drift over the
//               long haul.  If more accurate timekeeping is needed
//               over a long period of time, use get_long_time()
//               instead.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1989  
511 0 0 6 547 1904 0 0 773 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_long_time
//       Access: Published
//  Description: Returns the actual number of seconds elapsed since
//               the ClockObject was created, or since it was last
//               reset.
//
//               This is similar to get_real_time(), except that it
//               uses the most accurate counter we have over a long
//               period of time, and so it is less likely to drift.
//               However, it may not be very precise for measuring
//               short intervals.  On Windows, for instace, this is
//               only accurate to within about 55 milliseconds.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1989  
512 0 0 4 548 1894 0 0 299 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::reset
//       Access: Published
//  Description: Simultaneously resets both the time and the frame
//               count to zero.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1988  
513 0 0 4 549 1894 0 0 607 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_real_time
//       Access: Published
//  Description: Resets the clock to the indicated time.  This
//               changes only the real time of the clock as reported
//               by get_real_time(), but does not immediately change
//               the time reported by get_frame_time()--that will
//               change after the next call to tick().  Also see
//               reset(), set_frame_time(), and set_frame_count().
//////////////////////////////////////////////////////////////////// 2 4 this 3 1988  4 time 1 1904  
514 0 0 4 550 1894 0 0 477 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_frame_time
//       Access: Published
//  Description: Changes the time as reported for the current frame to
//               the indicated time.  Normally, the way to adjust the
//               frame time is via tick(); this function is provided
//               only for occasional special adjustments.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1988  4 time 1 1904  14 current_thread 1 1991  
515 0 0 4 551 1894 0 0 380 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_frame_count
//       Access: Published
//  Description: Resets the number of frames counted to the indicated
//               number.  Also see reset(), set_real_time(), and
//               set_frame_time().
//////////////////////////////////////////////////////////////////// 3 4 this 3 1988  11 frame_count 1 1891  14 current_thread 1 1991  
516 0 0 6 552 1891 0 0 457 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_frame_count
//       Access: Published
//  Description: Returns the number of times tick() has been called
//               since the ClockObject was created, or since it was
//               last reset.  This is generally the number of frames
//               that have been rendered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1989  14 current_thread 1 1991  
517 0 0 6 553 1904 0 0 523 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_net_frame_rate
//       Access: Published
//  Description: Returns the average frame rate since the last reset.
//               This is simply the total number of frames divided by
//               the total elapsed time.  This reports the virtual
//               frame rate if the clock is in (or has been in)
//               M_non_real_time mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1989  14 current_thread 1 1991  
518 0 0 6 554 1904 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_dt
//       Access: Published
//  Description: Returns the elapsed time for the previous frame: the
//               number of seconds elapsed between the last two calls
//               to tick().
//////////////////////////////////////////////////////////////////// 2 4 this 3 1989  14 current_thread 1 1991  
519 0 0 4 555 1894 0 0 575 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_dt
//       Access: Published
//  Description: In non-real-time mode, sets the number of seconds
//               that should appear to elapse between frames.  In
//               forced mode or limited mode, sets our target dt.  In
//               normal mode, this has no effect.  
//
//               Also see set_frame_rate(), which is a different way
//               to specify the same quantity.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1988  2 dt 1 1904  
520 0 0 4 556 1894 0 0 583 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_frame_rate
//       Access: Published
//  Description: In non-real-time mode, sets the number of frames per
//               second that we should appear to be running.  In forced
//               mode or limited mode, sets our target frame rate.  In
//               normal mode, this has no effect.
//
//               Also see set_dt(), which is a different way to
//               specify the same quantity.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1988  10 frame_rate 1 1904  
521 0 0 6 557 1904 0 0 333 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_max_dt
//       Access: Published
//  Description: Returns the current maximum allowable time elapsed
//               between any two frames.  See set_max_dt().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1989  
522 0 0 4 558 1894 0 0 872 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_max_dt
//       Access: Published
//  Description: Sets a limit on the value returned by get_dt().  If
//               this value is less than zero, no limit is imposed;
//               otherwise, this is the maximum value that will ever
//               be returned by get_dt(), regardless of how much time
//               has actually elapsed between frames.
//
//               This limit is only imposed in real-time mode; in
//               non-real-time mode, the dt is fixed anyway and max_dt
//               is ignored.
//
//               This is generally used to guarantee reasonable
//               behavior even in the presence of a very slow or
//               chuggy frame rame.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1988  6 max_dt 1 1904  
523 0 0 6 559 1904 0 0 544 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_degrade_factor
//       Access: Published
//  Description: In degrade mode, returns the ratio by which the
//               performance is degraded.  A value of 2.0 causes the
//               clock to be slowed down by a factor of two (reducing
//               performance to 1/2 what would be otherwise).
//
//               This has no effect if mode is not M_degrade.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1989  
524 0 0 4 560 1894 0 0 541 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_degrade_factor
//       Access: Published
//  Description: In degrade mode, sets the ratio by which the
//               performance is degraded.  A value of 2.0 causes the
//               clock to be slowed down by a factor of two (reducing
//               performance to 1/2 what would be otherwise).
//
//               This has no effect if mode is not M_degrade.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1988  14 degrade_factor 1 1904  
525 0 0 4 561 1894 0 0 729 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_average_frame_rate_interval
//       Access: Published
//  Description: Specifies the interval of time (in seconds) over
//               which get_average_frame_rate() averages the number of
//               frames per second to compute the frame rate.
//               Changing this does not necessarily immediately change
//               the result of get_average_frame_rate(), until this
//               interval of time has elapsed again.
//
//               Setting this to zero disables the computation of
//               get_average_frame_rate().
//////////////////////////////////////////////////////////////////// 2 4 this 3 1988  4 time 1 1904  
526 0 0 6 562 1904 0 0 423 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_average_frame_rate_interval
//       Access: Published
//  Description: Returns the interval of time (in seconds) over
//               which get_average_frame_rate() averages the number of frames
//               per second to compute the frame rate.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1989  
527 0 0 6 563 1904 0 0 500 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_average_frame_rate
//       Access: Published
//  Description: Returns the average frame rate in number of frames
//               per second over the last
//               get_average_frame_rate_interval() seconds.  This
//               measures the virtual frame rate if the clock is in
//               M_non_real_time mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1989  14 current_thread 1 1991  
528 0 0 6 564 1904 0 0 343 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_max_frame_duration
//       Access: Published
//  Description: Returns the maximum frame duration over the last
//               get_average_frame_rate_interval() seconds.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1989  14 current_thread 1 1991  
529 0 0 6 565 1904 0 0 915 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::calc_frame_time_deviation
//       Access: Published
//  Description: Returns the standard deviation of the frame times of
//               the frames rendered over the past
//               get_average_frame_rate_interval() seconds.  This
//               number gives an estimate of the chugginess of the
//               frame rate; if it is large, there is a large
//               variation in the frame rate; if is small, all of the
//               frames are consistent in length.
//
//               A large value might also represent just a recent
//               change in frame rate, for instance, because the
//               camera has just rotated from looking at a simple
//               scene to looking at a more complex scene.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1989  14 current_thread 1 1991  
530 0 0 4 566 1894 0 0 566 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::tick
//       Access: Published
//  Description: Instructs the clock that a new frame has just begun.
//               In normal, real-time mode, get_frame_time() will
//               henceforth report the time as of this instant as the
//               current start-of-frame time.  In non-real-time mode,
//               get_frame_time() will be incremented by the value of
//               dt.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1988  14 current_thread 1 1991  
531 0 0 4 567 1894 0 0 756 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::sync_frame_time
//       Access: Published
//  Description: Resets the frame time to the current real time.  This
//               is similar to tick(), except that it does not advance
//               the frame counter and does not affect dt.  This is
//               intended to be used in the middle of a particularly
//               long frame to compensate for the time that has
//               already elapsed.
//
//               In non-real-time mode, this function has no effect
//               (because in this mode all frames take the same length
//               of time).
//////////////////////////////////////////////////////////////////// 2 4 this 3 1988  14 current_thread 1 1991  
532 0 0 6 568 1905 0 0 609 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::check_errors
//       Access: Published
//  Description: Returns true if a clock error was detected since the
//               last time check_errors() was called.  A clock error
//               means that something happened, an OS or BIOS bug, for
//               instance, that makes the current value of the clock
//               somewhat suspect, and an application may wish to
//               resynchronize with any external clocks.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1988  14 current_thread 1 1991  
533 0 0 7 569 1988 0 0 408 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_global_clock
//       Access: Published
//  Description: Returns a pointer to the global ClockObject.  This is
//               the ClockObject that most code should use for
//               handling scene graph rendering and animation.
//////////////////////////////////////////////////////////////////// 0 
534 0 0 7 570 1901 0 0 0 0 
535 0 0 4 578 1894 0 0 279 ////////////////////////////////////////////////////////////////////
//     Function: CopyOnWriteObject::cache_ref
//       Access: Published
//  Description: See CachedTypedWritableReferenceCount::cache_ref().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1993  
536 0 0 7 579 1901 0 0 0 0 
537 0 0 7 583 1995 0 0 229 ////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
538 0 0 6 584 1905 0 0 325 ////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::open
//       Access: Published
//  Description: Opens the indicated filename for reading.  Returns
//               true on success, false on failure.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1995  4 file 1 1996  
539 0 0 6 584 1905 0 0 325 ////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::open
//       Access: Published
//  Description: Opens the indicated filename for reading.  Returns
//               true on success, false on failure.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1995  8 filename 1 1926  
540 0 0 6 584 1905 0 0 504 ////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::open
//       Access: Published
//  Description: Starts reading from the indicated stream.  Returns
//               true on success, false on failure.  The
//               DatagramInputFile does not take ownership of the
//               stream; you are responsible for closing or deleting
//               it when you are done.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1995  2 in 1 1999  8 filename 1 1926  
541 0 0 6 585 1999 0 0 279 ////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::get_stream
//       Access: Published
//  Description: Returns the istream represented by the input file.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1995  
542 0 0 4 586 1894 0 0 325 ////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::close
//       Access: Published
//  Description: Closes the file.  This is also implicitly done when
//               the DatagramInputFile destructs.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1995  
543 0 0 6 587 1905 0 0 535 ////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::read_header
//       Access: Published
//  Description: Reads a sequence of bytes from the beginning of the
//               datagram file.  This may be called any number of
//               times after the file has been opened and before the
//               first datagram is read.  It may not be called once
//               the first datagram has been read.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1995  6 header 1 1917  9 num_bytes 1 1886  
544 0 0 7 589 2001 1433 0 0 0 
545 0 0 7 589 2001 1433 0 0 1 4 copy 1 2002  
546 0 0 6 590 2001 0 0 0 2 4 this 3 2001  4 copy 1 2002  
547 0 0 7 591 2001 1433 0 0 0 
548 0 0 7 592 2001 1433 0 0 0 
549 0 0 7 593 2001 1433 0 0 1 7 on_bits 1 1891  
550 0 0 7 594 2001 1433 0 0 1 5 index 1 1891  
551 0 0 7 595 2001 1433 0 0 2 7 low_bit 1 1891  4 size 1 1891  
552 0 0 6 597 1905 0 0 0 0 
553 0 0 6 598 1891 0 0 0 0 
554 0 0 6 599 1891 0 0 0 0 
555 0 0 6 600 1905 0 0 0 2 4 this 3 2002  5 index 1 1891  
556 0 0 4 601 1894 0 0 0 2 4 this 3 2001  5 index 1 1891  
557 0 0 4 602 1894 0 0 0 2 4 this 3 2001  5 index 1 1891  
558 0 0 4 603 1894 0 0 0 3 4 this 3 2001  5 index 1 1891  5 value 1 1905  
559 0 0 6 604 1905 0 0 0 1 4 this 3 2002  
560 0 0 6 605 1905 0 0 0 1 4 this 3 2002  
561 0 0 6 606 1957 0 0 0 3 4 this 3 2002  7 low_bit 1 1891  4 size 1 1891  
562 0 0 4 607 1894 0 0 0 4 4 this 3 2001  5 value 1 1957  7 low_bit 1 1891  4 size 1 1891  
563 0 0 6 608 1905 0 0 0 3 4 this 3 2002  7 low_bit 1 1891  4 size 1 1891  
564 0 0 6 609 1905 0 0 0 3 4 this 3 2002  7 low_bit 1 1891  4 size 1 1891  
565 0 0 4 610 1894 0 0 0 3 4 this 3 2001  7 low_bit 1 1891  4 size 1 1891  
566 0 0 4 611 1894 0 0 0 3 4 this 3 2001  7 low_bit 1 1891  4 size 1 1891  
567 0 0 4 612 1894 0 0 0 4 4 this 3 2001  5 value 1 1905  7 low_bit 1 1891  4 size 1 1891  
568 0 0 6 613 1891 0 0 0 1 4 this 3 2002  
569 0 0 6 614 1891 0 0 0 1 4 this 3 2002  
570 0 0 6 615 1891 0 0 0 1 4 this 3 2002  
571 0 0 6 616 1891 0 0 0 1 4 this 3 2002  
572 0 0 6 617 1891 0 0 0 1 4 this 3 2002  
573 0 0 6 618 1891 0 0 0 1 4 this 3 2002  
574 0 0 6 619 1891 0 0 0 2 4 this 3 2002  7 low_bit 1 1891  
575 0 0 4 620 1894 0 0 0 1 4 this 3 2001  
576 0 0 6 621 1905 0 0 0 2 4 this 3 2002  5 other 1 2002  
577 0 0 4 622 1894 0 0 0 1 4 this 3 2001  
578 0 0 4 623 1894 0 0 0 2 4 this 3 2002  3 out 1 1898  
579 0 0 4 624 1894 0 0 0 3 4 this 3 2002  3 out 1 1898  12 spaces_every 1 1891  
580 0 0 4 625 1894 0 0 0 3 4 this 3 2002  3 out 1 1898  12 spaces_every 1 1891  
581 0 0 4 626 1894 0 0 0 3 4 this 3 2002  3 out 1 1898  12 indent_level 1 1891  
582 0 0 6 627 1905 0 0 0 2 4 this 3 2002  5 other 1 2002  
583 0 0 6 628 1905 0 0 0 2 4 this 3 2002  5 other 1 2002  
584 0 0 6 629 1905 0 0 0 2 4 this 3 2002  5 other 1 2002  
585 0 0 6 630 1891 0 0 0 2 4 this 3 2002  5 other 1 2002  
586 0 0 7 631 2001 1433 0 0 2 4 this 3 2002  5 other 1 2002  
587 0 0 7 632 2001 1433 0 0 2 4 this 3 2002  5 other 1 2002  
588 0 0 7 633 2001 1433 0 0 2 4 this 3 2002  5 other 1 2002  
589 0 0 7 634 2001 1433 0 0 1 4 this 3 2002  
590 0 0 7 635 2001 1433 0 0 2 4 this 3 2002  5 shift 1 1891  
591 0 0 7 636 2001 1433 0 0 2 4 this 3 2002  5 shift 1 1891  
592 0 0 6 637 2001 0 0 0 2 4 this 3 2001  5 other 1 2002  
593 0 0 6 638 2001 0 0 0 2 4 this 3 2001  5 other 1 2002  
594 0 0 6 639 2001 0 0 0 2 4 this 3 2001  5 other 1 2002  
595 0 0 6 640 2001 0 0 0 2 4 this 3 2001  5 shift 1 1891  
596 0 0 6 641 2001 0 0 0 2 4 this 3 2001  5 shift 1 1891  
597 0 0 7 642 1901 0 0 0 0 
598 0 0 7 645 2004 1487 0 0 0 
599 0 0 7 645 2004 1487 0 0 1 4 copy 1 2005  
600 0 0 6 646 2004 0 0 0 2 4 this 3 2004  4 copy 1 2005  
601 0 0 7 647 2004 1487 0 0 0 
602 0 0 7 648 2004 1487 0 0 0 
603 0 0 7 649 2004 1487 0 0 1 7 on_bits 1 1891  
604 0 0 7 650 2004 1487 0 0 1 5 index 1 1891  
605 0 0 7 651 2004 1487 0 0 2 7 low_bit 1 1891  4 size 1 1891  
606 0 0 6 653 1905 0 0 0 0 
607 0 0 6 654 1891 0 0 0 0 
608 0 0 6 655 1891 0 0 0 0 
609 0 0 6 656 1905 0 0 0 2 4 this 3 2005  5 index 1 1891  
610 0 0 4 657 1894 0 0 0 2 4 this 3 2004  5 index 1 1891  
611 0 0 4 658 1894 0 0 0 2 4 this 3 2004  5 index 1 1891  
612 0 0 4 659 1894 0 0 0 3 4 this 3 2004  5 index 1 1891  5 value 1 1905  
613 0 0 6 660 1905 0 0 0 1 4 this 3 2005  
614 0 0 6 661 1905 0 0 0 1 4 this 3 2005  
615 0 0 6 662 1957 0 0 0 3 4 this 3 2005  7 low_bit 1 1891  4 size 1 1891  
616 0 0 4 663 1894 0 0 0 4 4 this 3 2004  5 value 1 1957  7 low_bit 1 1891  4 size 1 1891  
617 0 0 6 664 1905 0 0 0 3 4 this 3 2005  7 low_bit 1 1891  4 size 1 1891  
618 0 0 6 665 1905 0 0 0 3 4 this 3 2005  7 low_bit 1 1891  4 size 1 1891  
619 0 0 4 666 1894 0 0 0 3 4 this 3 2004  7 low_bit 1 1891  4 size 1 1891  
620 0 0 4 667 1894 0 0 0 3 4 this 3 2004  7 low_bit 1 1891  4 size 1 1891  
621 0 0 4 668 1894 0 0 0 4 4 this 3 2004  5 value 1 1905  7 low_bit 1 1891  4 size 1 1891  
622 0 0 6 669 1891 0 0 0 1 4 this 3 2005  
623 0 0 6 670 1891 0 0 0 1 4 this 3 2005  
624 0 0 6 671 1891 0 0 0 1 4 this 3 2005  
625 0 0 6 672 1891 0 0 0 1 4 this 3 2005  
626 0 0 6 673 1891 0 0 0 1 4 this 3 2005  
627 0 0 6 674 1891 0 0 0 1 4 this 3 2005  
628 0 0 6 675 1891 0 0 0 2 4 this 3 2005  7 low_bit 1 1891  
629 0 0 4 676 1894 0 0 0 1 4 this 3 2004  
630 0 0 6 677 1905 0 0 0 2 4 this 3 2005  5 other 1 2005  
631 0 0 4 678 1894 0 0 0 1 4 this 3 2004  
632 0 0 4 679 1894 0 0 0 2 4 this 3 2005  3 out 1 1898  
633 0 0 4 680 1894 0 0 0 3 4 this 3 2005  3 out 1 1898  12 spaces_every 1 1891  
634 0 0 4 681 1894 0 0 0 3 4 this 3 2005  3 out 1 1898  12 spaces_every 1 1891  
635 0 0 4 682 1894 0 0 0 3 4 this 3 2005  3 out 1 1898  12 indent_level 1 1891  
636 0 0 6 683 1905 0 0 0 2 4 this 3 2005  5 other 1 2005  
637 0 0 6 684 1905 0 0 0 2 4 this 3 2005  5 other 1 2005  
638 0 0 6 685 1905 0 0 0 2 4 this 3 2005  5 other 1 2005  
639 0 0 6 686 1891 0 0 0 2 4 this 3 2005  5 other 1 2005  
640 0 0 7 687 2004 1487 0 0 2 4 this 3 2005  5 other 1 2005  
641 0 0 7 688 2004 1487 0 0 2 4 this 3 2005  5 other 1 2005  
642 0 0 7 689 2004 1487 0 0 2 4 this 3 2005  5 other 1 2005  
643 0 0 7 690 2004 1487 0 0 1 4 this 3 2005  
644 0 0 7 691 2004 1487 0 0 2 4 this 3 2005  5 shift 1 1891  
645 0 0 7 692 2004 1487 0 0 2 4 this 3 2005  5 shift 1 1891  
646 0 0 6 693 2004 0 0 0 2 4 this 3 2004  5 other 1 2005  
647 0 0 6 694 2004 0 0 0 2 4 this 3 2004  5 other 1 2005  
648 0 0 6 695 2004 0 0 0 2 4 this 3 2004  5 other 1 2005  
649 0 0 6 696 2004 0 0 0 2 4 this 3 2004  5 shift 1 1891  
650 0 0 6 697 2004 0 0 0 2 4 this 3 2004  5 shift 1 1891  
651 0 0 7 698 1901 0 0 0 0 
652 0 0 7 702 1967 1344 0 394 ////////////////////////////////////////////////////////////////////
//     Function: KeyboardButton::ascii_key
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               particular ASCII character, if there is one, or
//               ButtonHandle::none() if there is not.
//////////////////////////////////////////////////////////////////// 1 16 ascii_equivalent 1 1970  
653 0 0 7 703 1967 1344 0 0 0 
654 0 0 7 704 1967 1344 0 0 0 
655 0 0 7 705 1967 1344 0 0 0 
656 0 0 7 706 1967 1344 0 0 0 
657 0 0 7 707 1967 1344 0 0 0 
658 0 0 7 708 1967 1344 0 0 0 
659 0 0 7 709 1967 1344 0 0 0 
660 0 0 7 710 1967 1344 0 0 0 
661 0 0 7 711 1967 1344 0 0 0 
662 0 0 7 712 1967 1344 0 0 0 
663 0 0 7 713 1967 1344 0 0 0 
664 0 0 7 714 1967 1344 0 0 0 
665 0 0 7 715 1967 1344 0 0 0 
666 0 0 7 716 1967 1344 0 0 0 
667 0 0 7 717 1967 1344 0 0 0 
668 0 0 7 718 1967 1344 0 0 0 
669 0 0 7 719 1967 1344 0 0 0 
670 0 0 7 720 1967 1344 0 59 // PC keyboards don't have these four buttons, but Macs do. 0 
671 0 0 7 721 1967 1344 0 0 0 
672 0 0 7 722 1967 1344 0 0 0 
673 0 0 7 723 1967 1344 0 0 0 
674 0 0 7 724 1967 1344 0 0 0 
675 0 0 7 725 1967 1344 0 0 0 
676 0 0 7 726 1967 1344 0 0 0 
677 0 0 7 727 1967 1344 0 0 0 
678 0 0 7 728 1967 1344 0 0 0 
679 0 0 7 729 1967 1344 0 0 0 
680 0 0 7 730 1967 1344 0 0 0 
681 0 0 7 731 1967 1344 0 0 0 
682 0 0 7 732 1967 1344 0 0 0 
683 0 0 7 733 1967 1344 0 27 // delete is a C++ keyword. 0 
684 0 0 7 734 1967 1344 0 27 // delete is a C++ keyword. 0 
685 0 0 7 735 1967 1344 0 0 0 
686 0 0 7 736 1967 1344 0 0 0 
687 0 0 7 737 1967 1344 0 0 0 
688 0 0 7 738 1967 1344 0 0 0 
689 0 0 7 739 1967 1344 0 0 0 
690 0 0 7 740 1967 1344 0 0 0 
691 0 0 7 741 1967 1344 0 0 0 
692 0 0 7 742 1967 1344 0 0 0 
693 0 0 7 743 1967 1344 0 0 0 
694 0 0 7 744 1967 1344 0 0 0 
695 0 0 7 745 1967 1344 0 0 0 
696 0 0 7 746 1967 1344 0 0 0 
697 0 0 7 747 1967 1344 0 0 0 
698 0 0 7 748 1967 1344 0 0 0 
699 0 0 7 749 1967 1344 0 0 0 
700 0 0 7 750 1967 1344 0 0 0 
701 0 0 7 751 1967 1344 0 0 0 
702 0 0 7 752 1967 1344 0 0 0 
703 0 0 7 753 1967 1344 0 0 0 
704 0 0 7 760 2007 1592 0 227 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
705 0 0 7 760 2007 1592 0 232 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 2008  
706 0 0 6 762 2007 0 0 0 2 4 this 3 2007  4 copy 1 2008  
707 0 0 6 763 1905 0 0 0 2 4 this 3 2008  5 other 1 2008  
708 0 0 6 764 1905 0 0 0 2 4 this 3 2008  5 other 1 2008  
709 0 0 6 765 1905 0 0 0 2 4 this 3 2008  5 other 1 2008  
710 0 0 7 766 2007 1592 0 0 2 4 this 3 2008  5 other 1 2008  
711 0 0 7 767 2007 1592 0 0 2 4 this 3 2008  5 other 1 2008  
712 0 0 6 768 2007 0 0 0 2 4 this 3 2007  5 other 1 2008  
713 0 0 6 769 2007 0 0 0 2 4 this 3 2007  5 other 1 2008  
714 0 0 4 770 1894 0 0 698 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::set_button_list
//       Access: Published
//  Description: Sets the list of buttons to watch to be the same as
//               that of the other ModifierButtons object.  This makes
//               the lists pointer equivalent (until one or the other
//               is later modified).
//
//               This will preserve the state of any button that was
//               on the original list and is also on the new lists.
//               Any other buttons will get reset to the default state
//               of "up".
//////////////////////////////////////////////////////////////////// 2 4 this 3 2007  5 other 1 2008  
715 0 0 6 771 1905 0 0 504 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::matches
//       Access: Published
//  Description: Returns true if the set of buttons indicated as down
//               by this ModifierButtons object is the same set of
//               buttons indicated as down by the other
//               ModifierButtons object.  The buttons indicated as up
//               are not relevant.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2008  5 other 1 2008  
716 0 0 6 772 1905 0 0 523 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::add_button
//       Access: Published
//  Description: Adds the indicated button to the set of buttons that
//               will be monitored for upness and downness.  Returns
//               true if the button was added, false if it was already
//               being monitored or if too many buttons are currently
//               being monitored.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2007  6 button 1 1967  
717 0 0 6 773 1905 0 0 339 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::has_button
//       Access: Published
//  Description: Returns true if the indicated button is in the set of
//               buttons being monitored, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2008  6 button 1 1967  
718 0 0 6 774 1905 0 0 623 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::remove_button
//       Access: Published
//  Description: Removes the indicated button from the set of buttons
//               being monitored.  Returns true if the button was
//               removed, false if it was not being monitored in the
//               first place.
//
//               Unlike the other methods, you cannot remove a button
//               by removing its alias; you have to remove exactly the
//               button itself.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2007  6 button 1 1967  
719 0 0 6 775 1891 0 0 394 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::get_num_buttons
//       Access: Published
//  Description: Returns the number of buttons that the
//               ModifierButtons object is monitoring (e.g. the number
//               of buttons passed to add_button()).
//////////////////////////////////////////////////////////////////// 1 4 this 3 2008  
720 0 0 7 776 1967 1344 0 446 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::get_button
//       Access: Published
//  Description: Returns the nth button that the ModifierButtons
//               object is monitoring (the nth button passed to
//               add_button()).  This must be in the range 0 <= index
//               < get_num_buttons().
//////////////////////////////////////////////////////////////////// 2 4 this 3 2008  5 index 1 1891  
721 0 0 6 777 1905 0 0 597 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::button_down
//       Access: Published
//  Description: Records that a particular button has been pressed.
//               If the given button is one of the buttons that is
//               currently being monitored, this will update the
//               internal state appropriately; otherwise, it will do
//               nothing.  Returns true if the button is one that was
//               monitored, or false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2007  6 button 1 1967  
722 0 0 6 778 1905 0 0 596 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::button_up
//       Access: Published
//  Description: Records that a particular button has been released.
//               If the given button is one of the buttons that is
//               currently being monitored, this will update the
//               internal state appropriately; otherwise, it will do
//               nothing.  Returns true if the button is one that was
//               monitored, or false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2007  6 button 1 1967  
723 0 0 4 779 1894 0 0 303 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::all_buttons_up
//       Access: Published
//  Description: Marks all monitored buttons as being in the "up"
//               state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2007  
724 0 0 6 780 1905 0 0 401 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::is_down
//       Access: Published
//  Description: Returns true if the indicated button is known to be
//               down, or false if it is known to be up or if it is
//               not in the set of buttons being tracked.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2008  6 button 1 1967  
725 0 0 6 780 1905 0 0 332 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::is_down
//       Access: Published
//  Description: Returns true if the indicated button is known to be
//               down, or false if it is known to be up.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2008  5 index 1 1891  
726 0 0 6 781 1905 0 0 340 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::is_any_down
//       Access: Published
//  Description: Returns true if any of the tracked button are known
//               to be down, or false if all of them are up.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2008  
727 0 0 6 782 1890 0 0 397 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::get_prefix
//       Access: Published
//  Description: Returns a string which can be used to prefix any
//               button name or event name with the unique set of
//               modifier buttons currently being held.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2008  
728 0 0 4 783 1894 0 0 298 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::output
//       Access: Published
//  Description: Writes a one-line summary of the buttons known to be
//               down.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2008  3 out 1 1898  
729 0 0 4 784 1894 0 0 365 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::write
//       Access: Published
//  Description: Writes a multi-line summary including all of the
//               buttons being monitored and which ones are known to
//               be down.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2008  3 out 1 1898  
730 0 0 7 786 1967 1344 0 424 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::button
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               particular numbered mouse button (zero-based), if
//               there is one, or ButtonHandle::none() if there is
//               not.
//////////////////////////////////////////////////////////////////// 1 13 button_number 1 1891  
731 0 0 7 787 1967 1344 0 302 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::one
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               first mouse button.
//////////////////////////////////////////////////////////////////// 0 
732 0 0 7 788 1967 1344 0 303 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::two
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               second mouse button.
//////////////////////////////////////////////////////////////////// 0 
733 0 0 7 789 1967 1344 0 304 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::three
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               third mouse button.
//////////////////////////////////////////////////////////////////// 0 
734 0 0 7 790 1967 1344 0 304 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::four
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               fourth mouse button.
//////////////////////////////////////////////////////////////////// 0 
735 0 0 7 791 1967 1344 0 303 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::five
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               fifth mouse button.
//////////////////////////////////////////////////////////////////// 0 
736 0 0 7 792 1967 1344 0 327 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_up
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               wheel is rolled one notch upwards.
//////////////////////////////////////////////////////////////////// 0 
737 0 0 7 793 1967 1344 0 331 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_down
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               wheel is rolled one notch downwards.
//////////////////////////////////////////////////////////////////// 0 
738 0 0 7 794 1967 1344 0 396 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_left
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               is scrolled to the left. Usually, you'll only
//               find the horizontal scroll on laptops.
//////////////////////////////////////////////////////////////////// 0 
739 0 0 7 795 1967 1344 0 398 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_right
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               is scrolled to the right. Usually, you'll only
//               find the horizontal scroll on laptops.
//////////////////////////////////////////////////////////////////// 0 
740 0 0 6 796 1905 0 0 353 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::is_mouse_button
//       Access: Public, Static
//  Description: Returns true if the indicated ButtonHandle is a mouse
//               button, false if it is some other kind of button.
//////////////////////////////////////////////////////////////////// 1 6 button 1 1967  
741 0 0 7 799 2010 1634 0 221 ////////////////////////////////////////////////////////////////////
//     Function: MouseData::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
742 0 0 7 799 2010 1634 0 226 ////////////////////////////////////////////////////////////////////
//     Function: MouseData::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 2011  
743 0 0 6 800 2010 0 0 0 2 4 this 3 2010  4 copy 1 2011  
744 0 0 6 801 1904 0 0 215 ////////////////////////////////////////////////////////////////////
//     Function: MouseData::get_x
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 2011  
745 0 0 6 802 1904 0 0 215 ////////////////////////////////////////////////////////////////////
//     Function: MouseData::get_y
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 2011  
746 0 0 6 803 1905 0 0 223 ////////////////////////////////////////////////////////////////////
//     Function: MouseData::get_in_window
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 2011  
747 0 0 4 804 1894 0 0 216 ////////////////////////////////////////////////////////////////////
//     Function: MouseData::output
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 2011  3 out 1 1898  
748 0 0 6 807 1891 0 0 280 ////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::get_node_ref_count
//       Access: Published
//  Description: Returns the current reference count.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2013  
749 0 0 4 808 1894 0 0 662 ////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::node_ref
//       Access: Published
//  Description: Explicitly increments the reference count.
//
//               This function is const, even though it changes the
//               object, because generally fiddling with an object's
//               reference count isn't considered part of fiddling
//               with the object.  An object might be const in other
//               ways, but we still need to accurately count the
//               number of references to it.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2013  
750 0 0 6 809 1905 0 0 468 ////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::node_unref
//       Access: Published
//  Description: Explicitly decrements the node reference count and
//               the normal reference count simultaneously.
//
//               The return value is true if the new reference count
//               is nonzero, false if it is zero.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2013  
751 0 0 6 810 1905 0 0 350 ////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::test_ref_count_integrity
//       Access: Published
//  Description: Does some easy checks to make sure that the reference
//               count isn't completely bogus.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2013  
752 0 0 6 812 1891 0 0 600 ////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::get_referenced_bits
//       Access: Published
//  Description: Returns the union of the values defined in the
//               Referenced enum that represents the various things
//               that appear to be holding a pointer to this object.
//
//               If R_node is included, at least one node is holding a
//               pointer; if R_cache is included, at least one cache
//               element is.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2013  
753 0 0 7 813 1901 0 0 0 0 
754 0 0 7 815 2015 1648 0 223 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
755 0 0 7 815 2015 1648 0 239 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Constructor (from BitArray)
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 from 1 1960  
756 0 0 7 815 2015 1648 0 228 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 1963  
757 0 0 6 816 2015 0 0 236 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Copy Assignment Operator
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 2015  4 copy 1 1963  
758 0 0 7 817 2015 1648 0 323 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a SparseArray with an infinite array of bits,
//               all on.
//////////////////////////////////////////////////////////////////// 0 
759 0 0 7 818 2015 1648 0 290 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a SparseArray whose bits are all off.
//////////////////////////////////////////////////////////////////// 0 
760 0 0 7 819 2015 1648 0 301 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named lower_on constructor
//       Access: Published, Static
//  Description: Returns a SparseArray whose lower on_bits bits are on.
//////////////////////////////////////////////////////////////////// 1 7 on_bits 1 1891  
761 0 0 7 820 2015 1648 0 295 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named bit constructor
//       Access: Published, Static
//  Description: Returns a SparseArray with only the indicated bit on.
//////////////////////////////////////////////////////////////////// 1 5 index 1 1891  
762 0 0 7 821 2015 1648 0 329 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named range constructor
//       Access: Published, Static
//  Description: Returns a SparseArray whose size bits, beginning at
//               low_bit, are on.
//////////////////////////////////////////////////////////////////// 2 7 low_bit 1 1891  4 size 1 1891  
763 0 0 6 823 1905 0 0 723 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_max_num_bits
//       Access: Published, Static
//  Description: Returns true if there is a maximum number of bits
//               that may be stored in this structure, false
//               otherwise.  If this returns true, the number may be
//               queried in get_max_num_bits().
//
//               This method always returns false.  The SparseArray has
//               no maximum number of bits.  This method is defined so
//               generic programming algorithms can use BitMask or
//               SparseArray interchangeably.
//////////////////////////////////////////////////////////////////// 0 
764 0 0 6 824 1891 0 0 758 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_max_num_bits
//       Access: Published, Static
//  Description: If get_max_num_bits() returned true, this method may
//               be called to return the maximum number of bits that
//               may be stored in this structure.  It is an error to
//               call this if get_max_num_bits() return false.
//
//               It is always an error to call this method.  The
//               SparseArray has no maximum number of bits.  This method
//               is defined so generic programming algorithms can use
//               BitMask or SparseArray interchangeably.
//////////////////////////////////////////////////////////////////// 0 
765 0 0 6 825 1891 0 0 607 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_bits
//       Access: Published
//  Description: Returns the current number of possibly different bits
//               in this array.  There are actually an infinite number
//               of bits, but every bit higher than this bit will have
//               the same value, either 0 or 1 (see
//               get_highest_bits()).
//
//               This number may grow and/or shrink automatically as
//               needed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1963  
766 0 0 6 826 1905 0 0 445 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_bit
//       Access: Published
//  Description: Returns true if the nth bit is set, false if it is
//               cleared.  It is valid for n to increase beyond
//               get_num_bits(), but the return value get_num_bits()
//               will always be the same.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1963  5 index 1 1891  
767 0 0 4 827 1894 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_bit
//       Access: Published
//  Description: Sets the nth bit on.  If n >= get_num_bits(), this
//               automatically extends the array.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2015  5 index 1 1891  
768 0 0 4 828 1894 0 0 323 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::clear_bit
//       Access: Published
//  Description: Sets the nth bit off.  If n >= get_num_bits(), this
//               automatically extends the array.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2015  5 index 1 1891  
769 0 0 4 829 1894 0 0 313 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_bit_to
//       Access: Published
//  Description: Sets the nth bit either on or off, according to the
//               indicated bool value.
//////////////////////////////////////////////////////////////////// 3 4 this 3 2015  5 index 1 1891  5 value 1 1905  
770 0 0 6 830 1905 0 0 367 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_highest_bits
//       Access: Published
//  Description: Returns true if the infinite set of bits beyond
//               get_num_bits() are all on, or false of they are all
//               off.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1963  
771 0 0 6 831 1905 0 0 297 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::is_zero
//       Access: Published
//  Description: Returns true if the entire bitmask is zero, false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1963  
772 0 0 6 832 1905 0 0 298 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::is_all_on
//       Access: Published
//  Description: Returns true if the entire bitmask is one, false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1963  
773 0 0 6 833 1905 0 0 311 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_any_of
//       Access: Published
//  Description: Returns true if any bit in the indicated range is
//               set, false otherwise.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1963  7 low_bit 1 1891  4 size 1 1891  
774 0 0 6 834 1905 0 0 313 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_all_of
//       Access: Published
//  Description: Returns true if all bits in the indicated range are
//               set, false otherwise.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1963  7 low_bit 1 1891  4 size 1 1891  
775 0 0 4 835 1894 0 0 258 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_range
//       Access: Published
//  Description: Sets the indicated range of bits on.
//////////////////////////////////////////////////////////////////// 3 4 this 3 2015  7 low_bit 1 1891  4 size 1 1891  
776 0 0 4 836 1894 0 0 261 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::clear_range
//       Access: Published
//  Description: Sets the indicated range of bits off.
//////////////////////////////////////////////////////////////////// 3 4 this 3 2015  7 low_bit 1 1891  4 size 1 1891  
777 0 0 4 837 1894 0 0 278 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_range_to
//       Access: Published
//  Description: Sets the indicated range of bits to either on or off.
//////////////////////////////////////////////////////////////////// 4 4 this 3 2015  5 value 1 1905  7 low_bit 1 1891  4 size 1 1891  
778 0 0 6 838 1891 0 0 375 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_on_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 1 in the
//               array.  Returns -1 if there are an infinite number of
//               1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1963  
779 0 0 6 839 1891 0 0 376 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_off_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 0 in the
//               array.  Returns -1 if there are an infinite number of
//               0 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1963  
780 0 0 6 840 1891 0 0 395 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_lowest_on_bit
//       Access: Published
//  Description: Returns the index of the lowest 1 bit in the array.
//               Returns -1 if there are no 1 bits or if there are an
//               infinite number of 1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1963  
781 0 0 6 841 1891 0 0 396 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_lowest_off_bit
//       Access: Published
//  Description: Returns the index of the lowest 0 bit in the array.
//               Returns -1 if there are no 0 bits or if there are an
//               infinite number of 1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1963  
782 0 0 6 842 1891 0 0 393 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_highest_on_bit
//       Access: Published
//  Description: Returns the index of the highest 1 bit in the array.
//               Returns -1 if there are no 1 bits or if there an
//               infinite number of 1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1963  
783 0 0 6 843 1891 0 0 394 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_highest_off_bit
//       Access: Published
//  Description: Returns the index of the highest 0 bit in the array.
//               Returns -1 if there are no 0 bits or if there an
//               infinite number of 1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1963  
784 0 0 6 844 1891 0 0 594 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_next_higher_different_bit
//       Access: Published
//  Description: Returns the index of the next bit in the array, above
//               low_bit, whose value is different that the value of
//               low_bit.  Returns low_bit again if all bits higher
//               than low_bit have the same value.
//
//               This can be used to quickly iterate through all of
//               the bits in the array.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1963  7 low_bit 1 1891  
785 0 0 4 845 1894 0 0 324 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::invert_in_place
//       Access: Published
//  Description: Inverts all the bits in the SparseArray.  This is
//               equivalent to array = ~array.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2015  
786 0 0 6 846 1905 0 0 446 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_bits_in_common
//       Access: Published
//  Description: Returns true if this SparseArray has any "one" bits in
//               common with the other one, false otherwise.
//
//               This is equivalent to (array & other) != 0, but may
//               be faster.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1963  5 other 1 1963  
787 0 0 4 847 1894 0 0 259 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::clear
//       Access: Published
//  Description: Sets all the bits in the SparseArray off.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2015  
788 0 0 4 848 1894 0 0 219 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 1963  3 out 1 1898  
789 0 0 6 849 1905 0 0 0 2 4 this 3 1963  5 other 1 1963  
790 0 0 6 850 1905 0 0 0 2 4 this 3 1963  5 other 1 1963  
791 0 0 6 851 1905 0 0 0 2 4 this 3 1963  5 other 1 1963  
792 0 0 6 852 1891 0 0 513 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::compare_to
//       Access: Published
//  Description: Returns a number less than zero if this SparseArray
//               sorts before the indicated other SparseArray, greater
//               than zero if it sorts after, or 0 if they are
//               equivalent.  This is based on the same ordering
//               defined by operator <.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1963  5 other 1 1963  
793 0 0 7 853 2015 1648 0 0 2 4 this 3 1963  5 other 1 1963  
794 0 0 7 854 2015 1648 0 0 2 4 this 3 1963  5 other 1 1963  
795 0 0 7 855 2015 1648 0 0 2 4 this 3 1963  5 other 1 1963  
796 0 0 7 856 2015 1648 0 0 1 4 this 3 1963  
797 0 0 7 857 2015 1648 0 0 2 4 this 3 1963  5 shift 1 1891  
798 0 0 7 858 2015 1648 0 0 2 4 this 3 1963  5 shift 1 1891  
799 0 0 6 859 2015 0 0 0 2 4 this 3 2015  5 other 1 1963  
800 0 0 6 860 2015 0 0 0 2 4 this 3 2015  5 other 1 1963  
801 0 0 6 861 2015 0 0 0 2 4 this 3 2015  5 other 1 1963  
802 0 0 6 862 2015 0 0 0 2 4 this 3 2015  5 shift 1 1891  
803 0 0 6 863 2015 0 0 0 2 4 this 3 2015  5 shift 1 1891  
804 0 0 6 864 1905 0 0 614 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::is_inverse
//       Access: Published
//  Description: If this is true, the SparseArray is actually defined
//               as a list of subranges of integers that are *not* in
//               the set.  If this is false (the default), then the
//               subranges define the integers that *are* in the set.
//               This affects the interpretation of the values
//               returned by iterating through get_num_subranges().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1963  
805 0 0 6 865 1891 0 0 515 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_subranges
//       Access: Published
//  Description: Returns the number of separate subranges stored in
//               the SparseArray.  You can use this limit to iterate
//               through the subranges, calling get_subrange_begin()
//               and get_subrange_end() for each one.
//
//               Also see is_inverse().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1963  
806 0 0 6 866 1891 0 0 345 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_subrange_begin
//       Access: Published
//  Description: Returns the first numeric element in the nth
//               subrange.
//
//               Also see is_inverse().
//////////////////////////////////////////////////////////////////// 2 4 this 3 1963  1 n 1 1891  
807 0 0 6 867 1891 0 0 353 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_subrange_end
//       Access: Published
//  Description: Returns the last numeric element, plus one, in the
//               nth subrange.
//
//               Also see is_inverse().
//////////////////////////////////////////////////////////////////// 2 4 this 3 1963  1 n 1 1891  
808 0 0 7 868 1901 0 0 0 0 
809 0 0 7 870 1901 0 0 280 ////////////////////////////////////////////////////////////////////
//     Function: ParamValueBase::get_value_type
//       Access: Published, Virtual
//  Description: Returns the type of the underlying value.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2016  
810 0 0 4 871 1894 0 0 0 2 4 this 3 2016  3 out 1 1898  
811 0 0 7 872 1901 0 0 0 0 
812 0 0 7 874 2020 977 0 230 ////////////////////////////////////////////////////////////////////
//     Function: ParamTypedRefCount::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 5 value 1 2018  
813 0 0 7 875 2023 0 0 273 ////////////////////////////////////////////////////////////////////
//     Function: ParamTypedRefCount::get_value
//       Access: Published
//  Description: Retrieves the value stored in the parameter.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2021  
814 0 0 7 876 1901 0 0 0 0 
815 0 0 7 878 2024 977 0 0 1 5 value 1 1890  
816 0 0 4 879 1894 0 0 0 2 4 this 3 2024  5 value 1 1890  
817 0 0 6 880 1890 0 0 0 1 4 this 3 2025  
818 0 0 7 881 1901 0 0 0 0 
819 0 0 7 884 2027 977 0 0 1 5 value 1 1890  
820 0 0 4 885 1894 0 0 0 2 4 this 3 2027  5 value 1 1890  
821 0 0 6 886 1890 0 0 0 1 4 this 3 2028  
822 0 0 7 887 1901 0 0 0 0 
823 0 0 7 890 2033 977 0 0 1 5 value 1 2030  
824 0 0 4 891 1894 0 0 0 2 4 this 3 2033  5 value 1 2030  
825 0 0 6 892 2030 0 0 0 1 4 this 3 2034  
826 0 0 7 893 1901 0 0 0 0 
827 0 0 7 896 2039 977 0 0 1 5 value 1 2036  
828 0 0 4 897 1894 0 0 0 2 4 this 3 2039  5 value 1 2036  
829 0 0 6 898 2036 0 0 0 1 4 this 3 2040  
830 0 0 7 899 1901 0 0 0 0 
831 0 0 7 902 2045 977 0 0 1 5 value 1 2042  
832 0 0 4 903 1894 0 0 0 2 4 this 3 2045  5 value 1 2042  
833 0 0 6 904 2042 0 0 0 1 4 this 3 2046  
834 0 0 7 905 1901 0 0 0 0 
835 0 0 7 908 2051 977 0 0 1 5 value 1 2048  
836 0 0 4 909 1894 0 0 0 2 4 this 3 2051  5 value 1 2048  
837 0 0 6 910 2048 0 0 0 1 4 this 3 2052  
838 0 0 7 911 1901 0 0 0 0 
839 0 0 7 914 2057 977 0 0 1 5 value 1 2054  
840 0 0 4 915 1894 0 0 0 2 4 this 3 2057  5 value 1 2054  
841 0 0 6 916 2054 0 0 0 1 4 this 3 2058  
842 0 0 7 917 1901 0 0 0 0 
843 0 0 7 920 2063 977 0 0 1 5 value 1 2060  
844 0 0 4 921 1894 0 0 0 2 4 this 3 2063  5 value 1 2060  
845 0 0 6 922 2060 0 0 0 1 4 this 3 2064  
846 0 0 7 923 1901 0 0 0 0 
847 0 0 7 926 2069 977 0 0 1 5 value 1 2066  
848 0 0 4 927 1894 0 0 0 2 4 this 3 2069  5 value 1 2066  
849 0 0 6 928 2066 0 0 0 1 4 this 3 2070  
850 0 0 7 929 1901 0 0 0 0 
851 0 0 7 932 2075 977 0 0 1 5 value 1 2072  
852 0 0 4 933 1894 0 0 0 2 4 this 3 2075  5 value 1 2072  
853 0 0 6 934 2072 0 0 0 1 4 this 3 2076  
854 0 0 7 935 1901 0 0 0 0 
855 0 0 7 938 2081 977 0 0 1 5 value 1 2078  
856 0 0 4 939 1894 0 0 0 2 4 this 3 2081  5 value 1 2078  
857 0 0 6 940 2078 0 0 0 1 4 this 3 2082  
858 0 0 7 941 1901 0 0 0 0 
859 0 0 7 944 2087 977 0 0 1 5 value 1 2084  
860 0 0 4 945 1894 0 0 0 2 4 this 3 2087  5 value 1 2084  
861 0 0 6 946 2084 0 0 0 1 4 this 3 2088  
862 0 0 7 947 1901 0 0 0 0 
863 0 0 7 950 2093 977 0 0 1 5 value 1 2090  
864 0 0 4 951 1894 0 0 0 2 4 this 3 2093  5 value 1 2090  
865 0 0 6 952 2090 0 0 0 1 4 this 3 2094  
866 0 0 7 953 1901 0 0 0 0 
867 0 0 7 956 2099 977 0 0 1 5 value 1 2096  
868 0 0 4 957 1894 0 0 0 2 4 this 3 2099  5 value 1 2096  
869 0 0 6 958 2096 0 0 0 1 4 this 3 2100  
870 0 0 7 959 1901 0 0 0 0 
871 0 0 7 962 2105 977 0 0 1 5 value 1 2102  
872 0 0 4 963 1894 0 0 0 2 4 this 3 2105  5 value 1 2102  
873 0 0 6 964 2102 0 0 0 1 4 this 3 2106  
874 0 0 7 965 1901 0 0 0 0 
875 0 0 7 973 1901 0 0 0 0 
876 0 0 7 976 2108 1764 0 275 ////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::Constructor
//       Access: Published
//  Description: Create a free id pool in the range [min:max].
//////////////////////////////////////////////////////////////////// 2 3 min 1 1953  3 max 1 1953  
877 0 0 6 978 1953 0 0 381 ////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::allocate
//       Access: Published
//  Description: Returns an id between _min and _max (that were passed
//               to the constructor).
//               IndexEnd is returned if no ids are available.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2108  
878 0 0 4 979 1894 0 0 893 ////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::initial_reserve_id
//       Access: Published
//  Description: This may be called to mark a particular id as having
//               already been allocated (for instance, by a prior
//               pass).  The specified id is removed from the
//               available pool.
//
//               Because of the limitations of this algorithm, this is
//               most efficient when it is called before the first
//               call to allocate(), and when all the calls to
//               initial_reserve_id() are made in descending order by
//               id.  However, this is a performance warning only; if
//               performance is not an issue, any id may be reserved
//               at any time.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2108  2 id 1 1953  
879 0 0 4 980 1894 0 0 338 ////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::free
//       Access: Published
//  Description: Free an allocated index (index must be between _min
//               and _max that were passed to the constructor).
//////////////////////////////////////////////////////////////////// 2 4 this 3 2108  5 index 1 1953  
880 0 0 6 981 2111 0 0 350 ////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::fraction_used
//       Access: Published
//  Description: return the decimal fraction of the pool that is used.
//               The range is 0 to 1.0 (e.g. 75% would be 0.75).
//////////////////////////////////////////////////////////////////// 1 4 this 3 2109  
881 0 0 4 982 1894 0 0 256 ////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::output
//       Access: Published
//  Description: ...intended for debugging only.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2109  3 out 1 1898  
882 0 0 4 983 1894 0 0 255 ////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::write
//       Access: Published
//  Description: ...intended for debugging only.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2109  3 out 1 1898  
883 0 0 6 573 1822 0 0 0 1 3 str 1 1890  
884 0 0 6 574 1890 0 0 0 1 2 cs 1 1822  
885 0 0 6 575 2113 0 0 0 0 
886 0 0 6 576 2113 0 0 0 0 
887 0 0 6 755 2115 0 0 957 ////////////////////////////////////////////////////////////////////
//     Function: load_prc_file
//  Description: A convenience function for loading explicit prc files
//               from a disk file or from within a multifile (via the
//               virtual file system).  Save the return value and pass
//               it to unload_prc_file() if you ever want to unload
//               this file later.
//
//               The filename is first searched along the default prc
//               search path, and then also along the model path, for
//               convenience.
//
//               This function is defined in putil instead of in dtool
//               with the read of the prc stuff, so that it can take
//               advantage of the virtual file system (which is
//               defined in express), and the model path (which is in
//               putil).
//////////////////////////////////////////////////////////////////// 1 8 filename 1 1926  
888 0 0 6 756 2115 0 0 680 ////////////////////////////////////////////////////////////////////
//     Function: load_prc_file_data
//  Description: Another convenience function to load a prc file from
//               an explicit string, which represents the contents of
//               the prc file.
//
//               The first parameter is an arbitrary name to assign to
//               this in-memory prc file.  Supply a filename if the
//               data was read from a file, or use any other name that
//               is meaningful to you.  The name is only used when the
//               set of loaded prc files is listed.
//////////////////////////////////////////////////////////////////// 2 4 name 1 1890  4 data 1 1890  
889 0 0 6 757 1905 0 0 0 1 4 page 1 2115  
890 0 0 4 758 1894 0 0 0 1 4 hash 1 2117  
891 0 0 6 985 1883 0 0 0 2 10 this_class 1 1883  4 data 1 1890  
892 0 0 6 986 1883 0 0 0 3 9 unpickler 1 1883  10 this_class 1 1883  4 data 1 1890  
346
1773 29 ConstPointerToArray< ushort > 0 141313 29 ConstPointerToArray< ushort > 29 ConstPointerToArray< ushort > 0 0 0 1 896 906 0 9 897 898 899 900 901 902 903 904 905 0 0 1 0 1774 0 0 0 0 0

1774 28 PointerToArrayBase< ushort > 0 26625 28 PointerToArrayBase< ushort > 28 PointerToArrayBase< ushort > 0 0 0 0 895 0 0 0 0 1 0 1775 0 0 0 0 0

1775 49 PointerToBase< ReferenceCountedVector< ushort > > 0 43009 49 PointerToBase< ReferenceCountedVector< ushort > > 49 PointerToBase< ReferenceCountedVector< ushort > > 0 0 0 0 0 0 2 893 894 0 0 1 0 1776 0 0 0 0 0

1776 13 PointerToVoid 0 2049 13 PointerToVoid 13 PointerToVoid 0 0 0 0 0 0 0 0 0 0 0 0 635
////////////////////////////////////////////////////////////////////
//       Class : PointerToVoid
// Description : This is the non-template part of the base class for
//               PointerTo and ConstPointerTo.  It is necessary so we
//               can keep a pointer to a non-template class within the
//               ReferenceCount object, to implement weak reference
//               pointers--we need to have something to clean up when
//               the ReferenceCount object destructs.
//
//               This is the base class for PointerToBase<T>.
////////////////////////////////////////////////////////////////////

1777 24 PointerToArray< ushort > 0 141313 24 PointerToArray< ushort > 24 PointerToArray< ushort > 0 0 0 1 907 924 0 16 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 0 0 1 0 1774 0 0 0 0 0

1778 7 CString 0 1050625 20 basic_string< char > 20 basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

1779 13 AnimInterface 0 26625 13 AnimInterface 13 AnimInterface 0 0 0 0 925 0 17 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 0 0 0 0 0 464
////////////////////////////////////////////////////////////////////
//       Class : AnimInterface
// Description : This is the fundamental interface for things that
//               have a play/loop/stop type interface for frame-based
//               animation, such as animated characters.  This is the
//               base class for AnimControl and other, similar
//               classes.
////////////////////////////////////////////////////////////////////

1780 16 AutoTextureScale 0 532481 16 AutoTextureScale 16 AutoTextureScale 0 0 0 0 0 0 0 0 0 0 5 8 ATS_none 8 ATS_none 0
0 8 ATS_down 8 ATS_down 0
1 6 ATS_up 6 ATS_up 0
2 7 ATS_pad 7 ATS_pad 0
3 15 ATS_unspecified 15 ATS_unspecified 0
4 0 0

1781 9 UpdateSeq 0 141313 9 UpdateSeq 9 UpdateSeq 0 0 0 1 943 963 0 19 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 0 0 0 0 0 1140
////////////////////////////////////////////////////////////////////
//       Class : UpdateSeq
// Description : This is a sequence number that increments
//               monotonically.  It can be used to track cache
//               updates, or serve as a kind of timestamp for any
//               changing properties.
//
//               A special class is used instead of simply an int, so
//               we can elegantly handle such things as wraparound and
//               special cases.  There are two special cases.
//               Firstly, a sequence number is 'initial' when it is
//               first created.  This sequence is older than any other
//               sequence number.  Secondly, a sequence number may be
//               explicitly set to 'old'.  This is older than any
//               other sequence number except 'initial'.  Finally, we
//               have the explicit number 'fresh', which is newer
//               than any other sequence number.  All other sequences
//               are numeric and are monotonically increasing.
////////////////////////////////////////////////////////////////////

1782 13 TypedWritable 0 75777 13 TypedWritable 13 TypedWritable 0 0 0 0 0 0 7 964 965 966 967 968 969 970 0 0 1 0 1783 0 0 0 0 341
////////////////////////////////////////////////////////////////////
//       Class : TypedWritable
// Description : Base class for objects that can be written to and
//               read from Bam files.
//
//               See also TypedObject for detailed instructions.
////////////////////////////////////////////////////////////////////

1783 11 TypedObject 0 2049 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 3561
////////////////////////////////////////////////////////////////////
//       Class : TypedObject
// Description : This is an abstract class that all classes which
//               use TypeHandle, and also provide virtual functions to
//               support polymorphism, should inherit from.  Each
//               derived class should define get_type(), which should
//               return the specific type of the derived class.
//               Inheriting from this automatically provides support
//               for is_of_type() and is_exact_type().
//
//               All classes that inherit directly or indirectly from
//               TypedObject should redefine get_type() and
//               force_init_type(), as shown below.  Some classes that
//               do not inherit from TypedObject may still declare
//               TypeHandles for themselves by defining methods called
//               get_class_type() and init_type().  Classes such as
//               these may serve as base classes, but the dynamic type
//               identification system will be limited.  Classes that
//               do not inherit from TypedObject need not define the
//               virtual functions get_type() and force_init_type()
//               (or any other virtual functions).
//
//               There is a specific layout for defining the
//               overrides from this class.  Keeping the definitions
//               formatted just like these examples will allow
//               someone in the future to use a sed (or similar)
//               script to make global changes, if necessary.  Avoid
//               rearranging the braces or the order of the functions
//               unless you're ready to change them in every file all
//               at once.
//
//               What follows are some examples that can be used in
//               new classes that you create.
//
//               @par In the class definition (.h file):
//               @code
//               public:
//                 static TypeHandle get_class_type() {
//                   return _type_handle;
//                 }
//                 static void init_type() {
//                   <<<BaseClassOne>>>::init_type();
//                   <<<BaseClassTwo>>>::init_type();
//                   <<<BaseClassN>>>::init_type();
//                   register_type(_type_handle, "<<<ThisClassStringName>>>",
//                                 <<<BaseClassOne>>>::get_class_type(),
//                                 <<<BaseClassTwo>>>::get_class_type(),
//                                 <<<BaseClassN>>>::get_class_type());
//                 }
//                 virtual TypeHandle get_type() const {
//                   return get_class_type();
//                 }
//                 virtual TypeHandle force_init_type() {init_type(); return get_class_type();}
//
//               private:
//                 static TypeHandle _type_handle;
//               @endcode
//
//               @par In the class .cxx file:
//               @code
//               TypeHandle <<<ThisClassStringName>>>::_type_handle;
//               @endcode
//
//               @par In the class config_<<<PackageName>>>.cxx file:
//               @code
//               ConfigureFn(config_<<<PackageName>>>) {
//                 <<<ClassOne>>>::init_type();
//                 <<<ClassTwo>>>::init_type();
//                 <<<ClassN>>>::init_type();
//               }
//               @endcode
////////////////////////////////////////////////////////////////////

1784 27 TypedWritableReferenceCount 0 141313 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 977 0 2 975 976 0 0 2 3 1782 971 972 3 1785 973 974 0 0 722
////////////////////////////////////////////////////////////////////
//       Class : TypedWritableReferenceCount
// Description : A base class for things which need to inherit from
//               both TypedWritable and from ReferenceCount.  It's
//               convenient to define this intermediate base class
//               instead of multiply inheriting from the two classes
//               each time they are needed, so that we can sensibly
//               pass around pointers to things which are both
//               TypedWritables and ReferenceCounters.
//               
//               See also TypedObject for detailed instructions.
////////////////////////////////////////////////////////////////////

1785 14 ReferenceCount 0 2049 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 425
////////////////////////////////////////////////////////////////////
//       Class : ReferenceCount
// Description : A base class for all things that want to be
//               reference-counted.  ReferenceCount works in
//               conjunction with PointerTo to automatically delete
//               objects when the last pointer to them goes away.
////////////////////////////////////////////////////////////////////

1786 14 BamCacheRecord 0 26625 14 BamCacheRecord 14 BamCacheRecord 0 0 0 0 982 0 19 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 0 0 2 3 1784 978 979 3 1787 980 981 0 0 469
////////////////////////////////////////////////////////////////////
//       Class : BamCacheRecord
// Description : An instance of this class is written to the front of
//               a Bam or Txo file to make the file a cached instance
//               of some other loadable resource.  This record
//               contains information needed to test the validity of
//               the cache.
////////////////////////////////////////////////////////////////////

1787 14 LinkedListNode 0 1050625 14 LinkedListNode 14 LinkedListNode 0 0 0 0 0 0 0 0 0 0 0 0 762
////////////////////////////////////////////////////////////////////
//       Class : LinkedListNode
// Description : This just stores the pointers to implement a
//               doubly-linked list of some kind of object.  There are
//               occasions when a hand-rolled linked list is more
//               appropriate than an STL container.
//
//               Typically, each node of the linked list, as well as
//               the root of the list, will inherit from this class.
//
//               Note that this class is not inherently thread-safe;
//               derived classes are responsible for protecting any
//               calls into it within mutexes, if necessary.
////////////////////////////////////////////////////////////////////

1788 8 BamCache 0 26625 8 BamCache 8 BamCache 0 0 0 1 1002 1003 0 24 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 0 0 0 0 0 948
////////////////////////////////////////////////////////////////////
//       Class : BamCache
// Description : This class maintains a cache of Bam and/or Txo
//               objects generated from model files and texture images
//               (as well as possibly other kinds of loadable objects
//               that can be stored in bam file format).
//
//               This class also maintains a persistent index that
//               lists all of the cached objects (see BamCacheIndex).
//               We go through some considerable effort to make sure
//               this index gets saved correctly to disk, even in the
//               presence of multiple different processes writing to
//               the same index, and without relying too heavily on
//               low-level os-provided file locks (which work poorly
//               with C++ iostreams).
////////////////////////////////////////////////////////////////////

1789 8 BamEnums 0 141313 8 BamEnums 8 BamEnums 0 0 0 0 1028 0 0 0 0 0 0 3 1790 1791 1792 288
////////////////////////////////////////////////////////////////////
//       Class : BamEnums
// Description : This class exists just to provide scoping for the
//               enums shared by BamReader and BamWriter.
////////////////////////////////////////////////////////////////////

1790 9 BamEndian 0 794624 19 BamEnums::BamEndian 19 BamEnums::BamEndian 1789 0 0 0 0 0 0 0 0 0 3 12 BE_bigendian 22 BamEnums::BE_bigendian 0
0 15 BE_littleendian 25 BamEnums::BE_littleendian 0
1 9 BE_native 19 BamEnums::BE_native 0
1 0 345
// This defines an enumerated type used to represent the endianness of
// certain numeric values stored in a Bam file.  It really has only
// two possible values, either BE_bigendian or BE_littleendian; but
// through a preprocessor trick we also add BE_native, which is the
// same numerically as whichever value the hardware supports natively.

1791 13 BamObjectCode 0 794624 23 BamEnums::BamObjectCode 23 BamEnums::BamObjectCode 1789 0 0 0 0 0 0 0 0 0 5 8 BOC_push 18 BamEnums::BOC_push 0
0 7 BOC_pop 17 BamEnums::BOC_pop 0
1 11 BOC_adjunct 21 BamEnums::BOC_adjunct 0
2 10 BOC_remove 20 BamEnums::BOC_remove 0
3 13 BOC_file_data 23 BamEnums::BOC_file_data 0
4 0 565
// This is the code written along with each object.  It is used to
// control object scoping.  A BOC_push includes an object
// definition, and will always be eventually paired with a BOC_pop
// (which does not).  A BOC_adjunct includes an object definition
// but does not push the level; it is associated with the current
// level.  BOC_remove lists object ID's that have been deallocated
// on the sender end.  BOC_file_data may appear at any level and
// indicates the following datagram contains auxiliary file data
// that may be referenced by a later object.

1792 14 BamTextureMode 0 794624 24 BamEnums::BamTextureMode 24 BamEnums::BamTextureMode 1789 0 0 0 0 0 0 0 0 0 5 13 BTM_unchanged 23 BamEnums::BTM_unchanged 0
0 12 BTM_fullpath 22 BamEnums::BTM_fullpath 0
1 12 BTM_relative 22 BamEnums::BTM_relative 0
2 12 BTM_basename 22 BamEnums::BTM_basename 0
3 11 BTM_rawdata 21 BamEnums::BTM_rawdata 0
4 0 76
// This enum is used to control how textures are written to a bam
// stream.

1793 13 LoaderOptions 0 141313 13 LoaderOptions 13 LoaderOptions 0 0 0 1 1029 1040 0 10 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 0 0 0 0 2 1794 1795 257
////////////////////////////////////////////////////////////////////
//       Class : LoaderOptions
// Description : Specifies parameters that may be passed to the
//               loader.
////////////////////////////////////////////////////////////////////

1794 11 LoaderFlags 0 794624 26 LoaderOptions::LoaderFlags 26 LoaderOptions::LoaderFlags 1793 0 0 0 0 0 0 0 0 0 10 9 LF_search 24 LoaderOptions::LF_search 0
1 16 LF_report_errors 31 LoaderOptions::LF_report_errors 0
2 19 LF_convert_skeleton 34 LoaderOptions::LF_convert_skeleton 0
4 19 LF_convert_channels 34 LoaderOptions::LF_convert_channels 0
8 15 LF_convert_anim 30 LoaderOptions::LF_convert_anim 22
// skeleton + channels
12 16 LF_no_disk_cache 31 LoaderOptions::LF_no_disk_cache 20
// disallow BamCache
16 15 LF_no_ram_cache 30 LoaderOptions::LF_no_ram_cache 21
// disallow ModelPool
32 11 LF_no_cache 26 LoaderOptions::LF_no_cache 19
// no_disk + no_ram
48 13 LF_cache_only 28 LoaderOptions::LF_cache_only 23
// fail if not in cache
64 17 LF_allow_instance 32 LoaderOptions::LF_allow_instance 35
// returned pointer might be shared
128 0 33
// Flags for loading model files.

1795 12 TextureFlags 0 794624 27 LoaderOptions::TextureFlags 27 LoaderOptions::TextureFlags 1793 0 0 0 0 0 0 0 0 0 7 10 TF_preload 25 LoaderOptions::TF_preload 30
// Texture will have RAM image
4 17 TF_preload_simple 32 LoaderOptions::TF_preload_simple 37
// Texture will have simple RAM image
8 11 TF_allow_1d 26 LoaderOptions::TF_allow_1d 40
// If texture is Nx1, make a 1-d texture
16 19 TF_generate_mipmaps 34 LoaderOptions::TF_generate_mipmaps 30
// Consider generating mipmaps
32 12 TF_multiview 27 LoaderOptions::TF_multiview 36
// Load a multiview texture in pages
64 10 TF_integer 25 LoaderOptions::TF_integer 35
// Load as an integer (RGB) texture
128 8 TF_float 23 LoaderOptions::TF_float 43
// Load as a floating-point (depth) texture
256 0 35
// Flags for loading texture files.

1796 9 BamReader 0 26625 9 BamReader 9 BamReader 0 0 0 1 1041 1042 0 18 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 0 0 1 0 1789 0 0 0 0 1870
////////////////////////////////////////////////////////////////////
//       Class : BamReader
// Description : This is the fundamental interface for extracting
//               binary objects from a Bam file, as generated by a
//               BamWriter.
//
//               A Bam file can be thought of as a linear collection
//               of objects.  Each object is an instance of a class
//               that inherits, directly or indirectly, from
//               TypedWritable.  The objects may include pointers to
//               other objects within the Bam file; the BamReader
//               automatically manages these (with help from code
//               within each class) and restores the pointers
//               correctly.
//
//               This is the abstract interface and does not
//               specifically deal with disk files, but rather with a
//               DatagramGenerator of some kind, which is simply a
//               linear source of Datagrams.  It is probably from a
//               disk file, but it might conceivably be streamed
//               directly from a network or some such nonsense.
//
//               Bam files are most often used to store scene graphs
//               or subgraphs, and by convention they are given
//               filenames ending in the extension ".bam" when they
//               are used for this purpose.  However, a Bam file may
//               store any arbitrary list of TypedWritable objects;
//               in this more general usage, they are given filenames
//               ending in ".boo" to differentiate them from the more
//               common scene graph files.
//
//               See also BamFile, which defines a higher-level
//               interface to read and write Bam files on disk.
////////////////////////////////////////////////////////////////////

1797 9 BamWriter 0 26625 9 BamWriter 9 BamWriter 0 0 0 1 1061 1062 0 11 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 0 0 1 0 1789 0 0 0 0 1949
////////////////////////////////////////////////////////////////////
//       Class : BamWriter
// Description : This is the fundamental interface for writing binary
//               objects to a Bam file, to be extracted later by a
//               BamReader.
//
//               A Bam file can be thought of as a linear collection
//               of objects.  Each object is an instance of a class
//               that inherits, directly or indirectly, from
//               TypedWritable.  The objects may include pointers to
//               other objects; the BamWriter automatically manages
//               these (with help from code within each class) and
//               writes all referenced objects to the file in such a
//               way that the pointers may be correctly restored
//               later.
//
//               This is the abstract interface and does not
//               specifically deal with disk files, but rather with a
//               DatagramSink of some kind, which simply accepts a
//               linear stream of Datagrams.  It is probably written
//               to a disk file, but it might conceivably be streamed
//               directly to a network or some such nonsense.
//
//               Bam files are most often used to store scene graphs
//               or subgraphs, and by convention they are given
//               filenames ending in the extension ".bam" when they
//               are used for this purpose.  However, a Bam file may
//               store any arbitrary list of TypedWritable objects;
//               in this more general usage, they are given filenames
//               ending in ".boo" to differentiate them from the more
//               common scene graph files.
//
//               See also BamFile, which defines a higher-level
//               interface to read and write Bam files on disk.
////////////////////////////////////////////////////////////////////

1798 24 BitMask< PN_uint16, 16 > 0 26625 24 BitMask< PN_uint16, 16 > 24 BitMask< PN_uint16, 16 > 0 0 0 1 1074 1081 0 62 1075 1076 1077 1078 1079 1080 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 0 0 0 0 0 0

1799 9 BitMask16 0 2105345 9 BitMask16 9 BitMask16 0 0 1798 0 0 0 0 0 0 0 0 0 0

1800 24 BitMask< PN_uint32, 32 > 0 26625 24 BitMask< PN_uint32, 32 > 24 BitMask< PN_uint32, 32 > 0 0 0 1 1138 1145 0 62 1139 1140 1141 1142 1143 1144 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 0 0 0 0 0 0

1801 9 BitMask32 0 2105345 9 BitMask32 9 BitMask32 0 0 1800 0 0 0 0 0 0 0 0 0 0

1802 24 BitMask< PN_uint64, 64 > 0 26625 24 BitMask< PN_uint64, 64 > 24 BitMask< PN_uint64, 64 > 0 0 0 1 1202 1209 0 62 1203 1204 1205 1206 1207 1208 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 0 0 0 0 0 0

1803 9 BitMask64 0 2105345 9 BitMask64 9 BitMask64 0 0 1802 0 0 0 0 0 0 0 0 0 0

1804 13 BitMaskNative 0 1 13 BitMaskNative 13 BitMaskNative 0 0 0 0 0 0 0 0 0 0 0 0 0

1805 8 BitArray 0 26625 8 BitArray 8 BitArray 0 0 0 1 1266 1273 0 57 1267 1268 1269 1270 1271 1272 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 0 0 0 0 1 1806 425
////////////////////////////////////////////////////////////////////
//       Class : BitArray
// Description : A dynamic array with an unlimited number of bits.
//
//               This is similar to a BitMask, except it appears to
//               contain an infinite number of bits.  You can use it
//               very much as you would use a BitMask.
////////////////////////////////////////////////////////////////////

1806 0 0 794624 10 BitArray:: 0 1805 0 0 0 0 0 0 0 0 0 1 17 num_bits_per_word 27 BitArray::num_bits_per_word 0
64 0 0

1807 12 ButtonHandle 0 141313 12 ButtonHandle 12 ButtonHandle 0 0 0 1 1325 1344 0 17 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1343 0 1 1342 0 0 0 364
////////////////////////////////////////////////////////////////////
//       Class : ButtonHandle
// Description : A ButtonHandle represents a single button from any
//               device, including keyboard buttons and mouse buttons
//               (but see KeyboardButton and MouseButton).
////////////////////////////////////////////////////////////////////

1808 14 ButtonRegistry 0 141313 14 ButtonRegistry 14 ButtonRegistry 0 0 0 0 1350 0 5 1345 1346 1347 1348 1349 0 0 0 0 0 409
////////////////////////////////////////////////////////////////////
//       Class : ButtonRegistry
// Description : The ButtonRegistry class maintains all the assigned
//               ButtonHandles in a given system.  There should be only
//               one ButtonRegistry class during the lifetime of the
//               application.
////////////////////////////////////////////////////////////////////

1809 9 ButtonMap 0 141313 9 ButtonMap 9 ButtonMap 0 0 0 0 1358 0 7 1351 1352 1353 1354 1355 1356 1357 0 0 1 0 1810 0 0 0 0 571
////////////////////////////////////////////////////////////////////
//       Class : ButtonMap
// Description : This class represents a map containing all of the
//               buttons of a (keyboard) device, though it can also
//               be used as a generic mapping between ButtonHandles.
//               It maps an underlying 'raw' button to a 'virtual'
//               button, which may optionally be associated with an
//               appropriate platform-specific name for the button.
////////////////////////////////////////////////////////////////////

1810 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 710
////////////////////////////////////////////////////////////////////
//       Class : TypedReferenceCount
// Description : A base class for things which need to inherit from
//               both TypedObject and from ReferenceCount.  It's
//               convenient to define this intermediate base class
//               instead of multiply inheriting from the two classes
//               each time they are needed, so that we can sensibly
//               pass around pointers to things which are both
//               TypedObjects and ReferenceCounters.
//               
//               See also TypedObject for detailed instructions.
////////////////////////////////////////////////////////////////////

1811 14 CallbackObject 0 141313 14 CallbackObject 14 CallbackObject 0 0 0 0 1362 0 3 1359 1360 1361 0 0 1 0 1810 0 0 0 0 527
////////////////////////////////////////////////////////////////////
//       Class : CallbackObject
// Description : This is a generic object that can be assigned to a
//               callback at various points in the rendering process.
//               This is actually a base class for a handful of
//               specialized callback object types.  You can also
//               subclass it yourself to make your own callback
//               handler.
////////////////////////////////////////////////////////////////////

1812 33 CachedTypedWritableReferenceCount 0 43009 33 CachedTypedWritableReferenceCount 33 CachedTypedWritableReferenceCount 0 0 0 0 0 0 5 1363 1364 1365 1366 1367 0 0 1 0 1784 0 0 0 0 1112
////////////////////////////////////////////////////////////////////
//       Class : CachedTypedWritableReferenceCount
// Description : This is a special extension to ReferenceCount that
//               includes dual reference counts: the standard
//               reference count number, which includes all references
//               to the object, and a separate number (the cache
//               reference count) that counts the number of references
//               to the object just within its cache alone.  When
//               get_ref_count() == get_cache_ref_count(), the object
//               is not referenced outside the cache.
//
//               The cache refs must be explicitly maintained; there
//               is no PointerTo<> class to maintain the cache
//               reference counts automatically.  The cache reference
//               count is automatically included in the overall
//               reference count: calling cache_ref() and
//               cache_unref() automatically calls ref() and unref().
////////////////////////////////////////////////////////////////////

1813 12 CallbackData 0 141313 12 CallbackData 12 CallbackData 0 0 0 0 1371 0 3 1368 1369 1370 0 0 1 0 1783 0 0 0 0 610
////////////////////////////////////////////////////////////////////
//       Class : CallbackData
// Description : This is a generic data block that is passed along to
//               a CallbackObject when a callback is made.  It
//               contains data specific to the particular callback
//               type in question.
//
//               This is actually an abstract base class and contains
//               no data.  Specializations of this class will contain
//               the actual data relevant to each callback type.
////////////////////////////////////////////////////////////////////

1814 20 PythonCallbackObject 0 75777 20 PythonCallbackObject 20 PythonCallbackObject 0 0 0 1 1372 1362 0 6 1373 1374 1375 1376 1377 1378 0 0 1 0 1811 0 0 0 0 371
////////////////////////////////////////////////////////////////////
//       Class : PythonCallbackObject
// Description : This is a specialization on CallbackObject to allow
//               a callback to directly call an arbitarary Python
//               function.  Powerful!  But use with caution.
////////////////////////////////////////////////////////////////////

1815 7 TimeVal 0 141313 7 TimeVal 7 TimeVal 0 0 0 1 1379 1384 1 2119 2 1380 1381 0 0 0 0 0 0

1816 9 ulong [2] 0 4202496 9 ulong [2] 9 ulong [2] 0 0 1817 2 0 0 0 0 0 0 0 0 0 0

1817 5 ulong 0 2105344 5 ulong 5 ulong 0 0 1818 0 0 0 0 0 0 0 0 0 0

1818 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

1819 11 ClockObject 0 75777 11 ClockObject 11 ClockObject 0 0 0 1 1385 0 0 28 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 0 0 1 0 1785 0 0 0 1 1820 1457
////////////////////////////////////////////////////////////////////
//       Class : ClockObject
// Description : A ClockObject keeps track of elapsed real time and
//               discrete time.  In normal mode, get_frame_time()
//               returns the time as of the last time tick() was
//               called.  This is the "discrete" time, and is usually
//               used to get the time as of, for instance, the
//               beginning of the current frame.
//
//               In other modes, as set by set_mode() or the
//               clock-mode config variable, get_frame_time() may
//               return other values to simulate different timing
//               effects, for instance to perform non-real-time
//               animation.  See set_mode().
//
//               In all modes, get_real_time() always returns the
//               elapsed real time in seconds since the ClockObject
//               was constructed, or since it was last reset.
//
//               You can create your own ClockObject whenever you want
//               to have your own local timer.  There is also a
//               default, global ClockObject intended to represent
//               global time for the application; this is normally set
//               up to tick every frame so that its get_frame_time()
//               will return the time for the current frame.
////////////////////////////////////////////////////////////////////

1820 4 Mode 0 794624 17 ClockObject::Mode 17 ClockObject::Mode 1819 0 0 0 0 0 0 0 0 0 8 8 M_normal 21 ClockObject::M_normal 0
0 15 M_non_real_time 28 ClockObject::M_non_real_time 0
1 8 M_forced 21 ClockObject::M_forced 0
2 9 M_degrade 22 ClockObject::M_degrade 0
3 7 M_slave 20 ClockObject::M_slave 0
4 9 M_limited 22 ClockObject::M_limited 0
5 9 M_integer 22 ClockObject::M_integer 0
6 17 M_integer_limited 30 ClockObject::M_integer_limited 0
7 0 0

1821 11 CollideMask 0 2105345 11 CollideMask 11 CollideMask 0 0 1801 0 0 0 0 0 0 0 0 0 0

1822 10 ColorSpace 0 532481 10 ColorSpace 10 ColorSpace 0 0 0 0 0 0 0 0 0 0 4 14 CS_unspecified 14 CS_unspecified 105
// This value is not a color space, but is used to indicate that
// a color space has not been specified.
0 9 CS_linear 9 CS_linear 388
// CS_linear is not a color space per se, but represents the
// working color space of graphics APIs, which is linearized.  Since
// the conversion from sRGB to linear is defined, one could posit
// that it has the ITU-R BT.709 primaries, but this isn't meaningful
// as modern graphics APIs do not perform color management.
// All colors in Panda3D are linear unless otherwise specified.
1 7 CS_sRGB 7 CS_sRGB 107
// This is the standard, gamma-2.2-corrected sRGB color space, as
// used by the majority of image formats.
2 8 CS_scRGB 8 CS_scRGB 110
// This is a 16-bit encoded linear color space capable of encoding
// color values in the -0.5...7.4999 range.
3 0 0

1823 17 CopyOnWriteObject 0 141313 17 CopyOnWriteObject 17 CopyOnWriteObject 0 0 0 0 1420 0 2 1418 1419 0 0 1 0 1812 0 0 0 0 376
////////////////////////////////////////////////////////////////////
//       Class : CopyOnWriteObject
// Description : This base class provides basic reference counting,
//               but also can be used with a CopyOnWritePointer to
//               provide get_read_pointer() and get_write_pointer().
////////////////////////////////////////////////////////////////////

1824 17 DatagramInputFile 0 75777 17 DatagramInputFile 17 DatagramInputFile 0 0 0 1 1421 0 0 4 1422 1423 1424 1425 0 0 1 0 1825 0 0 0 0 340
////////////////////////////////////////////////////////////////////
//       Class : DatagramInputFile
// Description : This class can be used to read a binary file that
//               consists of an arbitrary header followed by a number
//               of datagrams.
////////////////////////////////////////////////////////////////////

1825 17 DatagramGenerator 0 2049 17 DatagramGenerator 17 DatagramGenerator 0 0 0 0 0 0 0 0 0 0 0 0 335
////////////////////////////////////////////////////////////////////
//       Class : DatagramGenerator
// Description : This class defines the abstract interace to any
//               source of datagrams, whether it be from a file or
//               from the net.
////////////////////////////////////////////////////////////////////

1826 30 DoubleBitMask< BitMaskNative > 0 26625 30 DoubleBitMask< BitMaskNative > 30 DoubleBitMask< BitMaskNative > 0 0 0 1 1426 1433 0 52 1427 1428 1429 1430 1431 1432 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 0 0 0 0 0 0

1827 19 DoubleBitMaskNative 0 2105345 19 DoubleBitMaskNative 19 DoubleBitMaskNative 0 0 1826 0 0 0 0 0 0 0 0 0 0

1828 36 DoubleBitMask< DoubleBitMaskNative > 0 26625 36 DoubleBitMask< DoubleBitMaskNative > 36 DoubleBitMask< DoubleBitMaskNative > 0 0 0 1 1480 1487 0 52 1481 1482 1483 1484 1485 1486 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 0 0 0 0 0 0

1829 17 QuadBitMaskNative 0 2105345 17 QuadBitMaskNative 17 QuadBitMaskNative 0 0 1828 0 0 0 0 0 0 0 0 0 0

1830 8 DrawMask 0 2105345 8 DrawMask 8 DrawMask 0 0 1801 0 0 0 0 0 0 0 0 0 0

1831 14 KeyboardButton 0 141313 14 KeyboardButton 14 KeyboardButton 0 0 0 0 1586 0 52 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 0 0 0 0 0 369
////////////////////////////////////////////////////////////////////
//       Class : KeyboardButton
// Description : This class is just used as a convenient namespace for
//               grouping all of these handy functions that return
//               buttons which map to standard keyboard keys.
////////////////////////////////////////////////////////////////////

1832 15 ModifierButtons 0 26625 15 ModifierButtons 15 ModifierButtons 0 0 0 1 1591 1592 0 23 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1 2120 0 0 0 0 343
////////////////////////////////////////////////////////////////////
//       Class : ModifierButtons
// Description : This class monitors the state of a number of
//               individual buttons and tracks whether each button is
//               known to be down or up.
////////////////////////////////////////////////////////////////////

1833 11 MouseButton 0 141313 11 MouseButton 11 MouseButton 0 0 0 0 1627 0 11 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 0 0 0 0 0 366
////////////////////////////////////////////////////////////////////
//       Class : MouseButton
// Description : This class is just used as a convenient namespace for
//               grouping all of these handy functions that return
//               buttons which map to standard mouse buttons.
////////////////////////////////////////////////////////////////////

1834 9 MouseData 0 141313 9 MouseData 9 MouseData 0 0 0 1 1628 1634 0 5 1629 1630 1631 1632 1633 0 0 0 0 0 326
////////////////////////////////////////////////////////////////////
//       Class : MouseData
// Description : Holds the data that might be generated by a 2-d
//               pointer input device, such as the mouse in the
//               GraphicsWindow.
////////////////////////////////////////////////////////////////////

1835 24 NodeCachedReferenceCount 0 43009 24 NodeCachedReferenceCount 24 NodeCachedReferenceCount 0 0 0 0 0 0 6 1635 1636 1637 1638 1639 1640 0 0 1 0 1812 0 0 0 1 1836 2143
////////////////////////////////////////////////////////////////////
//       Class : NodeCachedReferenceCount
// Description : This class further specializes
//               CachedTypedWritableReferenceCount to also add a
//               node_ref_count, for the purposes of counting the
//               number of times the object is referenced by a "node",
//               presumably a PandaNode.
//
//               This essentially combines the functionality of
//               NodeReferenceCount and
//               CachedTypedWritableReferenceCount, so that a
//               derivative of this object actually has three
//               counters: the standard reference count, the "cache"
//               reference count, and the "node" reference count.
//               Rather than multiply inheriting from the two
//               reference count classes, we inherit only from
//               CachedTypedWritableReferenceCount and simply
//               duplicate the functionality of NodeReferenceCount, to
//               avoid all of the problems associated with multiple
//               inheritance.
//
//               The intended design is to use this as a base class
//               for RenderState and TransformState, both of which are
//               held by PandaNodes, and also have caches which are
//               independently maintained.  By keeping track of how
//               many nodes hold a pointer to a particular object, we
//               can classify each object into node-referenced,
//               cache-referenced, or other, which is primarily useful
//               for PStats reporting.
//
//               As with CachedTypedWritableReferenceCount's
//               cache_ref() and cache_unref(), the new methods
//               node_ref() and node_unref() automatically increment
//               and decrement the primary reference count as well.
//               In this case, however, there does exist a
//               NodePointerTo<> class to maintain the node_ref
//               counters automatically.
////////////////////////////////////////////////////////////////////

1836 10 Referenced 0 794624 36 NodeCachedReferenceCount::Referenced 36 NodeCachedReferenceCount::Referenced 1835 0 0 0 0 0 0 0 0 0 2 6 R_node 32 NodeCachedReferenceCount::R_node 0
1 7 R_cache 33 NodeCachedReferenceCount::R_cache 0
2 0 0

1837 11 SparseArray 0 26625 11 SparseArray 11 SparseArray 0 0 0 1 1641 1648 0 52 1642 1643 1644 1645 1646 1647 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 0 0 0 0 0 1136
////////////////////////////////////////////////////////////////////
//       Class : SparseArray
// Description : This class records a set of integers, where each
//               integer is either present or not present in the set.
//
//               It is similar in principle and in interface to a
//               BitArray (which can be thought of as a set of
//               integers, one integer corresponding to each different
//               bit position), but the SparseArray is implemented as
//               a list of min/max subrange lists, rather than as a
//               bitmask.  
//
//               This makes it particularly efficient for storing sets
//               which consist of large sections of consecutively
//               included or consecutively excluded elements, with
//               arbitrarily large integers, but particularly
//               inefficient for doing boolean operations such as & or
//               |.
//
//               Also, unlike BitArray, the SparseArray can store
//               negative integers.
////////////////////////////////////////////////////////////////////

1838 14 ParamValueBase 0 75777 14 ParamValueBase 14 ParamValueBase 0 0 0 0 977 0 3 1695 1696 1697 0 0 1 0 1784 0 0 0 0 348
////////////////////////////////////////////////////////////////////
//       Class : ParamValueBase
// Description : A non-template base class of ParamValue (below),
//               which serves mainly to define the placeholder for the
//               virtual output function.
////////////////////////////////////////////////////////////////////

1839 18 ParamTypedRefCount 0 75777 18 ParamTypedRefCount 18 ParamTypedRefCount 0 0 0 1 1698 977 0 2 1699 1700 0 0 1 0 1838 0 0 0 0 354
////////////////////////////////////////////////////////////////////
//       Class : ParamTypedRefCount
// Description : A class object for storing specifically objects of
//               type TypedReferenceCount, which is different than
//               TypedWritableReferenceCount.
////////////////////////////////////////////////////////////////////

1840 20 ParamValue< string > 0 75777 20 ParamValue< string > 20 ParamValue< string > 0 0 0 1 1701 977 0 3 1702 1703 1704 0 0 1 0 1838 0 0 0 0 0

1841 11 ParamString 0 2105345 11 ParamString 11 ParamString 0 0 1840 0 0 0 0 0 0 0 0 0 0

1842 21 ParamValue< wstring > 0 75777 21 ParamValue< wstring > 21 ParamValue< wstring > 0 0 0 1 1705 977 0 3 1706 1707 1708 0 0 1 0 1838 0 0 0 0 0

1843 12 ParamWstring 0 2105345 12 ParamWstring 12 ParamWstring 0 0 1842 0 0 0 0 0 0 0 0 0 0

1844 24 ParamValue< LVecBase2d > 0 75777 24 ParamValue< LVecBase2d > 24 ParamValue< LVecBase2d > 0 0 0 1 1709 977 0 3 1710 1711 1712 0 0 1 0 1838 0 0 0 0 0

1845 14 ParamVecBase2d 0 2105345 14 ParamVecBase2d 14 ParamVecBase2d 0 0 1844 0 0 0 0 0 0 0 0 0 0

1846 24 ParamValue< LVecBase2f > 0 75777 24 ParamValue< LVecBase2f > 24 ParamValue< LVecBase2f > 0 0 0 1 1713 977 0 3 1714 1715 1716 0 0 1 0 1838 0 0 0 0 0

1847 14 ParamVecBase2f 0 2105345 14 ParamVecBase2f 14 ParamVecBase2f 0 0 1846 0 0 0 0 0 0 0 0 0 0

1848 24 ParamValue< LVecBase2i > 0 75777 24 ParamValue< LVecBase2i > 24 ParamValue< LVecBase2i > 0 0 0 1 1717 977 0 3 1718 1719 1720 0 0 1 0 1838 0 0 0 0 0

1849 14 ParamVecBase2i 0 2105345 14 ParamVecBase2i 14 ParamVecBase2i 0 0 1848 0 0 0 0 0 0 0 0 0 0

1850 24 ParamValue< LVecBase3d > 0 75777 24 ParamValue< LVecBase3d > 24 ParamValue< LVecBase3d > 0 0 0 1 1721 977 0 3 1722 1723 1724 0 0 1 0 1838 0 0 0 0 0

1851 14 ParamVecBase3d 0 2105345 14 ParamVecBase3d 14 ParamVecBase3d 0 0 1850 0 0 0 0 0 0 0 0 0 0

1852 24 ParamValue< LVecBase3f > 0 75777 24 ParamValue< LVecBase3f > 24 ParamValue< LVecBase3f > 0 0 0 1 1725 977 0 3 1726 1727 1728 0 0 1 0 1838 0 0 0 0 0

1853 14 ParamVecBase3f 0 2105345 14 ParamVecBase3f 14 ParamVecBase3f 0 0 1852 0 0 0 0 0 0 0 0 0 0

1854 24 ParamValue< LVecBase3i > 0 75777 24 ParamValue< LVecBase3i > 24 ParamValue< LVecBase3i > 0 0 0 1 1729 977 0 3 1730 1731 1732 0 0 1 0 1838 0 0 0 0 0

1855 14 ParamVecBase3i 0 2105345 14 ParamVecBase3i 14 ParamVecBase3i 0 0 1854 0 0 0 0 0 0 0 0 0 0

1856 24 ParamValue< LVecBase4d > 0 75777 24 ParamValue< LVecBase4d > 24 ParamValue< LVecBase4d > 0 0 0 1 1733 977 0 3 1734 1735 1736 0 0 1 0 1838 0 0 0 0 0

1857 14 ParamVecBase4d 0 2105345 14 ParamVecBase4d 14 ParamVecBase4d 0 0 1856 0 0 0 0 0 0 0 0 0 0

1858 24 ParamValue< LVecBase4f > 0 75777 24 ParamValue< LVecBase4f > 24 ParamValue< LVecBase4f > 0 0 0 1 1737 977 0 3 1738 1739 1740 0 0 1 0 1838 0 0 0 0 0

1859 14 ParamVecBase4f 0 2105345 14 ParamVecBase4f 14 ParamVecBase4f 0 0 1858 0 0 0 0 0 0 0 0 0 0

1860 24 ParamValue< LVecBase4i > 0 75777 24 ParamValue< LVecBase4i > 24 ParamValue< LVecBase4i > 0 0 0 1 1741 977 0 3 1742 1743 1744 0 0 1 0 1838 0 0 0 0 0

1861 14 ParamVecBase4i 0 2105345 14 ParamVecBase4i 14 ParamVecBase4i 0 0 1860 0 0 0 0 0 0 0 0 0 0

1862 23 ParamValue< LMatrix3d > 0 75777 23 ParamValue< LMatrix3d > 23 ParamValue< LMatrix3d > 0 0 0 1 1745 977 0 3 1746 1747 1748 0 0 1 0 1838 0 0 0 0 0

1863 13 ParamMatrix3d 0 2105345 13 ParamMatrix3d 13 ParamMatrix3d 0 0 1862 0 0 0 0 0 0 0 0 0 0

1864 23 ParamValue< LMatrix3f > 0 75777 23 ParamValue< LMatrix3f > 23 ParamValue< LMatrix3f > 0 0 0 1 1749 977 0 3 1750 1751 1752 0 0 1 0 1838 0 0 0 0 0

1865 13 ParamMatrix3f 0 2105345 13 ParamMatrix3f 13 ParamMatrix3f 0 0 1864 0 0 0 0 0 0 0 0 0 0

1866 23 ParamValue< LMatrix4d > 0 75777 23 ParamValue< LMatrix4d > 23 ParamValue< LMatrix4d > 0 0 0 1 1753 977 0 3 1754 1755 1756 0 0 1 0 1838 0 0 0 0 0

1867 13 ParamMatrix4d 0 2105345 13 ParamMatrix4d 13 ParamMatrix4d 0 0 1866 0 0 0 0 0 0 0 0 0 0

1868 23 ParamValue< LMatrix4f > 0 75777 23 ParamValue< LMatrix4f > 23 ParamValue< LMatrix4f > 0 0 0 1 1757 977 0 3 1758 1759 1760 0 0 1 0 1838 0 0 0 0 0

1869 13 ParamMatrix4f 0 2105345 13 ParamMatrix4f 13 ParamMatrix4f 0 0 1868 0 0 0 0 0 0 0 0 0 0

1870 13 ParamVecBase2 0 2105345 13 ParamVecBase2 13 ParamVecBase2 0 0 1847 0 0 0 0 0 0 0 0 0 0

1871 13 ParamVecBase3 0 2105345 13 ParamVecBase3 13 ParamVecBase3 0 0 1853 0 0 0 0 0 0 0 0 0 0

1872 13 ParamVecBase4 0 2105345 13 ParamVecBase4 13 ParamVecBase4 0 0 1859 0 0 0 0 0 0 0 0 0 0

1873 12 ParamMatrix3 0 2105345 12 ParamMatrix3 12 ParamMatrix3 0 0 1865 0 0 0 0 0 0 0 0 0 0

1874 12 ParamMatrix4 0 2105345 12 ParamMatrix4 12 ParamMatrix4 0 0 1869 0 0 0 0 0 0 0 0 0 0

1875 20 WritableConfigurable 0 141313 20 WritableConfigurable 20 WritableConfigurable 0 0 0 0 1762 0 1 1761 0 0 1 0 1782 0 0 0 0 666
////////////////////////////////////////////////////////////////////
//       Class : WritableConfigurable
// Description : Defined as a fix to allow creating Configurable and
//               Writable objects.  Otherwise the compiler gets
//               confused since both TypedWritable and Configurable
//               inherit from TypedObject.
//
//               An object that has data or parameters that are set
//               less frequently (at least occasionally) than every
//               frame.  We can cache the configuration info by
//               by using the "dirty" flag.
////////////////////////////////////////////////////////////////////

1876 17 UniqueIdAllocator 0 26625 17 UniqueIdAllocator 17 UniqueIdAllocator 0 0 0 1 1763 1764 0 6 1765 1766 1767 1768 1769 1770 0 0 0 0 0 1207
////////////////////////////////////////////////////////////////////
//       Class : UniqueIdAllocator
// Description : Manage a set of ID values from min to max inclusive.
//               The ID numbers that are freed will be allocated
//               (reused) in the same order.  I.e. the oldest ID numbers
//               will be allocated.
//
//               This implementation will use 4 bytes per id number,
//               plus a few bytes of management data.  e.g. 10,000
//               ID numbers will use 40KB.
//
//               Also be advised that ID -1 and -2 are used internally by
//               the allocator.  If allocate returns IndexEnd (-1) then
//               the allocator is out of free ID numbers.
//
//               There are other implementations that can better leverage
//               runs of used or unused IDs or use bit arrays for the
//               IDs.  But, it takes extra work to track the age of
//               freed IDs, which is required for what we wanted.  If
//               you would like to kick around other implementation
//               ideas, please contact Schuyler.
////////////////////////////////////////////////////////////////////

1877 10 PortalMask 0 2105345 10 PortalMask 10 PortalMask 0 0 1801 0 0 0 0 0 0 0 0 0 0

1878 37 ConstPointerToArray< ushort > const * 0 8576 37 ConstPointerToArray< ushort > const * 37 ConstPointerToArray< ushort > const * 0 0 1879 0 0 0 0 0 0 0 0 0 0

1879 35 ConstPointerToArray< ushort > const 0 8832 35 ConstPointerToArray< ushort > const 35 ConstPointerToArray< ushort > const 0 0 1773 0 0 0 0 0 0 0 0 0 0

1880 31 ConstPointerToArray< ushort > * 0 8576 31 ConstPointerToArray< ushort > * 31 ConstPointerToArray< ushort > * 0 0 1773 0 0 0 0 0 0 0 0 0 0

1881 32 PointerToArray< ushort > const * 0 8576 32 PointerToArray< ushort > const * 32 PointerToArray< ushort > const * 0 0 1882 0 0 0 0 0 0 0 0 0 0

1882 30 PointerToArray< ushort > const 0 8832 30 PointerToArray< ushort > const 30 PointerToArray< ushort > const 0 0 1777 0 0 0 0 0 0 0 0 0 0

1883 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 1884 0 0 0 0 0 0 0 0 0 0

1884 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 1885 0 0 0 0 0 0 0 0 0 0

1885 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

1886 6 size_t 0 2105344 6 size_t 6 size_t 0 0 1887 0 0 0 0 0 0 0 0 0 0

1887 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

1888 6 ushort 0 2105344 6 ushort 6 ushort 0 0 1889 0 0 0 0 0 0 0 0 0 0

1889 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0

1890 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

1891 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

1892 11 Py_buffer * 0 8576 11 Py_buffer * 11 Py_buffer * 0 0 1893 0 0 0 0 0 0 0 0 0 0

1893 9 Py_buffer 0 1024 9 Py_buffer 9 Py_buffer 0 0 0 0 0 0 0 0 0 0 0 0 0

1894 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

1895 51 PointerToBase< ReferenceCountedVector< ushort > > * 0 8576 51 PointerToBase< ReferenceCountedVector< ushort > > * 51 PointerToBase< ReferenceCountedVector< ushort > > * 0 0 1775 0 0 0 0 0 0 0 0 0 0

1896 57 PointerToBase< ReferenceCountedVector< ushort > > const * 0 8576 57 PointerToBase< ReferenceCountedVector< ushort > > const * 57 PointerToBase< ReferenceCountedVector< ushort > > const * 0 0 1897 0 0 0 0 0 0 0 0 0 0

1897 55 PointerToBase< ReferenceCountedVector< ushort > > const 0 8832 55 PointerToBase< ReferenceCountedVector< ushort > > const 55 PointerToBase< ReferenceCountedVector< ushort > > const 0 0 1775 0 0 0 0 0 0 0 0 0 0

1898 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 1899 0 0 0 0 0 0 0 0 0 0

1899 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

1900 26 PointerToArray< ushort > * 0 8576 26 PointerToArray< ushort > * 26 PointerToArray< ushort > * 0 0 1777 0 0 0 0 0 0 0 0 0 0

1901 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 1902 0 0 0 0 0 0 0 0 0 0

1902 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 1098
////////////////////////////////////////////////////////////////////
//       Class : TypeHandle
// Description : TypeHandle is the identifier used to differentiate
//               C++ class types.  Any C++ classes that inherit from
//               some base class, and must be differentiated at run
//               time, should store a static TypeHandle object that
//               can be queried through a static member function
//               named get_class_type().  Most of the time, it is also
//               desirable to inherit from TypedObject, which provides
//               some virtual functions to return the TypeHandle for a
//               particular instance.
//
//               At its essence, a TypeHandle is simply a unique
//               identifier that is assigned by the TypeRegistry.  The
//               TypeRegistry stores a tree of TypeHandles, so that
//               ancestry of a particular type may be queried, and the
//               type name may be retrieved for run-time display.
////////////////////////////////////////////////////////////////////

1903 15 AnimInterface * 0 8576 15 AnimInterface * 15 AnimInterface * 0 0 1779 0 0 0 0 0 0 0 0 0 0

1904 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

1905 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

1906 21 AnimInterface const * 0 8576 21 AnimInterface const * 21 AnimInterface const * 0 0 1907 0 0 0 0 0 0 0 0 0 0

1907 19 AnimInterface const 0 8832 19 AnimInterface const 19 AnimInterface const 0 0 1779 0 0 0 0 0 0 0 0 0 0

1908 11 UpdateSeq * 0 8576 11 UpdateSeq * 11 UpdateSeq * 0 0 1781 0 0 0 0 0 0 0 0 0 0

1909 17 UpdateSeq const * 0 8576 17 UpdateSeq const * 17 UpdateSeq const * 0 0 1910 0 0 0 0 0 0 0 0 0 0

1910 15 UpdateSeq const 0 8832 15 UpdateSeq const 15 UpdateSeq const 0 0 1781 0 0 0 0 0 0 0 0 0 0

1911 7 Integer 0 2367488 21 AtomicAdjust::Integer 21 AtomicAdjust::Integer 1912 0 1913 0 0 0 0 0 0 0 0 0 0

1912 12 AtomicAdjust 0 1024 12 AtomicAdjust 12 AtomicAdjust 0 0 0 0 0 0 0 0 0 0 0 0 0

1913 8 long int 0 8210 8 long int 8 long int 0 1 0 0 0 0 0 0 0 0 0 0 0

1914 15 TypedWritable * 0 8576 15 TypedWritable * 15 TypedWritable * 0 0 1782 0 0 0 0 0 0 0 0 0 0

1915 21 TypedWritable const * 0 8576 21 TypedWritable const * 21 TypedWritable const * 0 0 1916 0 0 0 0 0 0 0 0 0 0

1916 19 TypedWritable const 0 8832 19 TypedWritable const 19 TypedWritable const 0 0 1782 0 0 0 0 0 0 0 0 0 0

1917 8 string * 0 8576 8 string * 8 string * 0 0 1918 0 0 0 0 0 0 0 0 0 0

1918 6 string 0 2105344 6 string 6 string 0 0 1778 0 0 0 0 0 0 0 0 0 0

1919 11 BamWriter * 0 8576 11 BamWriter * 11 BamWriter * 0 0 1797 0 0 0 0 0 0 0 0 0 0

1920 11 BamReader * 0 8576 11 BamReader * 11 BamReader * 0 0 1796 0 0 0 0 0 0 0 0 0 0

1921 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 1784 0 0 0 0 0 0 0 0 0 0

1922 16 ReferenceCount * 0 8576 16 ReferenceCount * 16 ReferenceCount * 0 0 1785 0 0 0 0 0 0 0 0 0 0

1923 22 BamCacheRecord const * 0 8576 22 BamCacheRecord const * 22 BamCacheRecord const * 0 0 1924 0 0 0 0 0 0 0 0 0 0

1924 20 BamCacheRecord const 0 8832 20 BamCacheRecord const 20 BamCacheRecord const 0 0 1786 0 0 0 0 0 0 0 0 0 0

1925 16 BamCacheRecord * 0 8576 16 BamCacheRecord * 16 BamCacheRecord * 0 0 1786 0 0 0 0 0 0 0 0 0 0

1926 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 1927 0 0 0 0 0 0 0 0 0 0

1927 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 1928 0 0 0 0 0 0 0 0 0 0

1928 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 869
////////////////////////////////////////////////////////////////////
//       Class : Filename
// Description : The name of a file, such as a texture file or an Egg
//               file.  Stores the full pathname, and includes
//               functions for extracting out the directory prefix
//               part and the file extension and stuff.
//
//               A Filename is also aware of the mapping between the
//               Unix-like filename convention we use internally, and
//               the local OS's specific filename convention, and it
//               knows how to perform basic OS-specific I/O, like
//               testing for file existence and searching a
//               searchpath, as well as the best way to open an
//               fstream for reading or writing.
////////////////////////////////////////////////////////////////////

1929 6 time_t 0 2105344 6 time_t 6 time_t 0 0 1887 0 0 0 0 0 0 0 0 0 0

1930 10 BamCache * 0 8576 10 BamCache * 10 BamCache * 0 0 1788 0 0 0 0 0 0 0 0 0 0

1931 16 BamCache const * 0 8576 16 BamCache const * 16 BamCache const * 0 0 1932 0 0 0 0 0 0 0 0 0 0

1932 14 BamCache const 0 8832 14 BamCache const 14 BamCache const 0 0 1788 0 0 0 0 0 0 0 0 0 0

1933 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 1928 0 0 0 0 0 0 0 0 0 0

1934 21 LoaderOptions const * 0 8576 21 LoaderOptions const * 21 LoaderOptions const * 0 0 1935 0 0 0 0 0 0 0 0 0 0

1935 19 LoaderOptions const 0 8832 19 LoaderOptions const 19 LoaderOptions const 0 0 1793 0 0 0 0 0 0 0 0 0 0

1936 15 LoaderOptions * 0 8576 15 LoaderOptions * 15 LoaderOptions * 0 0 1793 0 0 0 0 0 0 0 0 0 0

1937 19 DatagramGenerator * 0 8576 19 DatagramGenerator * 19 DatagramGenerator * 0 0 1825 0 0 0 0 0 0 0 0 0 0

1938 9 AuxData * 0 8576 20 BamReader::AuxData * 20 BamReader::AuxData * 0 0 1939 0 0 0 0 0 0 0 0 0 0

1939 7 AuxData 0 1312768 18 BamReader::AuxData 18 BamReader::AuxData 1796 0 0 0 0 0 0 0 0 0 0 0 187
// Inherit from this class to piggyback additional temporary data on
// the bamReader (via set_aux_data() and get_aux_data()) for any
// particular objects during the bam reading process.

1940 17 BamReader const * 0 8576 17 BamReader const * 17 BamReader const * 0 0 1941 0 0 0 0 0 0 0 0 0 0

1941 15 BamReader const 0 8832 15 BamReader const 15 BamReader const 0 0 1796 0 0 0 0 0 0 0 0 0 0

1942 14 DatagramSink * 0 8576 14 DatagramSink * 14 DatagramSink * 0 0 1943 0 0 0 0 0 0 0 0 0 0

1943 12 DatagramSink 0 2048 12 DatagramSink 12 DatagramSink 0 0 0 0 0 0 0 0 0 0 0 0 340
////////////////////////////////////////////////////////////////////
//       Class : DatagramSink
// Description : This class defines the abstract interface to sending
//               datagrams to any target, whether it be into a file
//               or across the net
////////////////////////////////////////////////////////////////////

1944 17 BamWriter const * 0 8576 17 BamWriter const * 17 BamWriter const * 0 0 1945 0 0 0 0 0 0 0 0 0 0

1945 15 BamWriter const 0 8832 15 BamWriter const 15 BamWriter const 0 0 1797 0 0 0 0 0 0 0 0 0 0

1946 26 BitMask< PN_uint16, 16 > * 0 8576 26 BitMask< PN_uint16, 16 > * 26 BitMask< PN_uint16, 16 > * 0 0 1798 0 0 0 0 0 0 0 0 0 0

1947 32 BitMask< PN_uint16, 16 > const * 0 8576 32 BitMask< PN_uint16, 16 > const * 32 BitMask< PN_uint16, 16 > const * 0 0 1948 0 0 0 0 0 0 0 0 0 0

1948 30 BitMask< PN_uint16, 16 > const 0 8832 30 BitMask< PN_uint16, 16 > const 30 BitMask< PN_uint16, 16 > const 0 0 1798 0 0 0 0 0 0 0 0 0 0

1949 9 PN_uint16 0 2105344 9 PN_uint16 9 PN_uint16 0 0 1889 0 0 0 0 0 0 0 0 0 0

1950 26 BitMask< PN_uint32, 32 > * 0 8576 26 BitMask< PN_uint32, 32 > * 26 BitMask< PN_uint32, 32 > * 0 0 1800 0 0 0 0 0 0 0 0 0 0

1951 32 BitMask< PN_uint32, 32 > const * 0 8576 32 BitMask< PN_uint32, 32 > const * 32 BitMask< PN_uint32, 32 > const * 0 0 1952 0 0 0 0 0 0 0 0 0 0

1952 30 BitMask< PN_uint32, 32 > const 0 8832 30 BitMask< PN_uint32, 32 > const 30 BitMask< PN_uint32, 32 > const 0 0 1800 0 0 0 0 0 0 0 0 0 0

1953 9 PN_uint32 0 2105344 9 PN_uint32 9 PN_uint32 0 0 1887 0 0 0 0 0 0 0 0 0 0

1954 26 BitMask< PN_uint64, 64 > * 0 8576 26 BitMask< PN_uint64, 64 > * 26 BitMask< PN_uint64, 64 > * 0 0 1802 0 0 0 0 0 0 0 0 0 0

1955 32 BitMask< PN_uint64, 64 > const * 0 8576 32 BitMask< PN_uint64, 64 > const * 32 BitMask< PN_uint64, 64 > const * 0 0 1956 0 0 0 0 0 0 0 0 0 0

1956 30 BitMask< PN_uint64, 64 > const 0 8832 30 BitMask< PN_uint64, 64 > const 30 BitMask< PN_uint64, 64 > const 0 0 1802 0 0 0 0 0 0 0 0 0 0

1957 9 PN_uint64 0 2105344 9 PN_uint64 9 PN_uint64 0 0 1958 0 0 0 0 0 0 0 0 0 0

1958 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

1959 10 BitArray * 0 8576 10 BitArray * 10 BitArray * 0 0 1805 0 0 0 0 0 0 0 0 0 0

1960 16 BitArray const * 0 8576 16 BitArray const * 16 BitArray const * 0 0 1961 0 0 0 0 0 0 0 0 0 0

1961 14 BitArray const 0 8832 14 BitArray const 14 BitArray const 0 0 1805 0 0 0 0 0 0 0 0 0 0

1962 8 WordType 0 2367488 18 BitArray::WordType 18 BitArray::WordType 1805 0 1957 0 0 0 0 0 0 0 0 0 0

1963 19 SparseArray const * 0 8576 19 SparseArray const * 19 SparseArray const * 0 0 1964 0 0 0 0 0 0 0 0 0 0

1964 17 SparseArray const 0 8832 17 SparseArray const 17 SparseArray const 0 0 1837 0 0 0 0 0 0 0 0 0 0

1965 8 MaskType 0 2367488 18 BitArray::MaskType 18 BitArray::MaskType 1805 0 1804 0 0 0 0 0 0 0 0 0 0

1966 10 MaskType * 0 8576 20 BitArray::MaskType * 20 BitArray::MaskType * 0 0 1965 0 0 0 0 0 0 0 0 0 0

1967 14 ButtonHandle * 0 8576 14 ButtonHandle * 14 ButtonHandle * 0 0 1807 0 0 0 0 0 0 0 0 0 0

1968 20 ButtonHandle const * 0 8576 20 ButtonHandle const * 20 ButtonHandle const * 0 0 1969 0 0 0 0 0 0 0 0 0 0

1969 18 ButtonHandle const 0 8832 18 ButtonHandle const 18 ButtonHandle const 0 0 1807 0 0 0 0 0 0 0 0 0 0

1970 4 char 0 8194 4 char 4 char 0 5 0 0 0 0 0 0 0 0 0 0 0

1971 16 ButtonRegistry * 0 8576 16 ButtonRegistry * 16 ButtonRegistry * 0 0 1808 0 0 0 0 0 0 0 0 0 0

1972 22 ButtonRegistry const * 0 8576 22 ButtonRegistry const * 22 ButtonRegistry const * 0 0 1973 0 0 0 0 0 0 0 0 0 0

1973 20 ButtonRegistry const 0 8832 20 ButtonRegistry const 20 ButtonRegistry const 0 0 1808 0 0 0 0 0 0 0 0 0 0

1974 17 ButtonMap const * 0 8576 17 ButtonMap const * 17 ButtonMap const * 0 0 1975 0 0 0 0 0 0 0 0 0 0

1975 15 ButtonMap const 0 8832 15 ButtonMap const 15 ButtonMap const 0 0 1809 0 0 0 0 0 0 0 0 0 0

1976 22 CallbackObject const * 0 8576 22 CallbackObject const * 22 CallbackObject const * 0 0 1977 0 0 0 0 0 0 0 0 0 0

1977 20 CallbackObject const 0 8832 20 CallbackObject const 20 CallbackObject const 0 0 1811 0 0 0 0 0 0 0 0 0 0

1978 16 CallbackObject * 0 8576 16 CallbackObject * 16 CallbackObject * 0 0 1811 0 0 0 0 0 0 0 0 0 0

1979 41 CachedTypedWritableReferenceCount const * 0 8576 41 CachedTypedWritableReferenceCount const * 41 CachedTypedWritableReferenceCount const * 0 0 1980 0 0 0 0 0 0 0 0 0 0

1980 39 CachedTypedWritableReferenceCount const 0 8832 39 CachedTypedWritableReferenceCount const 39 CachedTypedWritableReferenceCount const 0 0 1812 0 0 0 0 0 0 0 0 0 0

1981 20 CallbackData const * 0 8576 20 CallbackData const * 20 CallbackData const * 0 0 1982 0 0 0 0 0 0 0 0 0 0

1982 18 CallbackData const 0 8832 18 CallbackData const 18 CallbackData const 0 0 1813 0 0 0 0 0 0 0 0 0 0

1983 14 CallbackData * 0 8576 14 CallbackData * 14 CallbackData * 0 0 1813 0 0 0 0 0 0 0 0 0 0

1984 22 PythonCallbackObject * 0 8576 22 PythonCallbackObject * 22 PythonCallbackObject * 0 0 1814 0 0 0 0 0 0 0 0 0 0

1985 9 TimeVal * 0 8576 9 TimeVal * 9 TimeVal * 0 0 1815 0 0 0 0 0 0 0 0 0 0

1986 15 TimeVal const * 0 8576 15 TimeVal const * 15 TimeVal const * 0 0 1987 0 0 0 0 0 0 0 0 0 0

1987 13 TimeVal const 0 8832 13 TimeVal const 13 TimeVal const 0 0 1815 0 0 0 0 0 0 0 0 0 0

1988 13 ClockObject * 0 8576 13 ClockObject * 13 ClockObject * 0 0 1819 0 0 0 0 0 0 0 0 0 0

1989 19 ClockObject const * 0 8576 19 ClockObject const * 19 ClockObject const * 0 0 1990 0 0 0 0 0 0 0 0 0 0

1990 17 ClockObject const 0 8832 17 ClockObject const 17 ClockObject const 0 0 1819 0 0 0 0 0 0 0 0 0 0

1991 8 Thread * 0 8576 8 Thread * 8 Thread * 0 0 1992 0 0 0 0 0 0 0 0 0 0

1992 6 Thread 0 2048 6 Thread 6 Thread 0 0 0 0 0 0 0 0 0 0 0 0 668
////////////////////////////////////////////////////////////////////
//       Class : Thread
// Description : A thread; that is, a lightweight process.  This is an
//               abstract base class; to use it, you must subclass
//               from it and redefine thread_main().
//
//               The thread itself will keep a reference count on the
//               Thread object while it is running; when the thread
//               returns from its root function, the Thread object
//               will automatically be destructed if no other pointers
//               are referencing it.
////////////////////////////////////////////////////////////////////

1993 25 CopyOnWriteObject const * 0 8576 25 CopyOnWriteObject const * 25 CopyOnWriteObject const * 0 0 1994 0 0 0 0 0 0 0 0 0 0

1994 23 CopyOnWriteObject const 0 8832 23 CopyOnWriteObject const 23 CopyOnWriteObject const 0 0 1823 0 0 0 0 0 0 0 0 0 0

1995 19 DatagramInputFile * 0 8576 19 DatagramInputFile * 19 DatagramInputFile * 0 0 1824 0 0 0 0 0 0 0 0 0 0

1996 21 FileReference const * 0 8576 21 FileReference const * 21 FileReference const * 0 0 1997 0 0 0 0 0 0 0 0 0 0

1997 19 FileReference const 0 8832 19 FileReference const 19 FileReference const 0 0 1998 0 0 0 0 0 0 0 0 0 0

1998 13 FileReference 0 2048 13 FileReference 13 FileReference 0 0 0 0 0 0 0 0 0 0 0 0 354
////////////////////////////////////////////////////////////////////
//       Class : FileReference
// Description : Keeps a reference-counted pointer to a file on disk.
//               As long as the FileReference is held, someone
//               presumably has a use for this file.
////////////////////////////////////////////////////////////////////

1999 9 istream * 0 8576 9 istream * 9 istream * 0 0 2000 0 0 0 0 0 0 0 0 0 0

2000 7 istream 0 2048 7 istream 7 istream 0 0 0 0 0 0 0 0 0 0 0 0 0

2001 32 DoubleBitMask< BitMaskNative > * 0 8576 32 DoubleBitMask< BitMaskNative > * 32 DoubleBitMask< BitMaskNative > * 0 0 1826 0 0 0 0 0 0 0 0 0 0

2002 38 DoubleBitMask< BitMaskNative > const * 0 8576 38 DoubleBitMask< BitMaskNative > const * 38 DoubleBitMask< BitMaskNative > const * 0 0 2003 0 0 0 0 0 0 0 0 0 0

2003 36 DoubleBitMask< BitMaskNative > const 0 8832 36 DoubleBitMask< BitMaskNative > const 36 DoubleBitMask< BitMaskNative > const 0 0 1826 0 0 0 0 0 0 0 0 0 0

2004 38 DoubleBitMask< DoubleBitMaskNative > * 0 8576 38 DoubleBitMask< DoubleBitMaskNative > * 38 DoubleBitMask< DoubleBitMaskNative > * 0 0 1828 0 0 0 0 0 0 0 0 0 0

2005 44 DoubleBitMask< DoubleBitMaskNative > const * 0 8576 44 DoubleBitMask< DoubleBitMaskNative > const * 44 DoubleBitMask< DoubleBitMaskNative > const * 0 0 2006 0 0 0 0 0 0 0 0 0 0

2006 42 DoubleBitMask< DoubleBitMaskNative > const 0 8832 42 DoubleBitMask< DoubleBitMaskNative > const 42 DoubleBitMask< DoubleBitMaskNative > const 0 0 1828 0 0 0 0 0 0 0 0 0 0

2007 17 ModifierButtons * 0 8576 17 ModifierButtons * 17 ModifierButtons * 0 0 1832 0 0 0 0 0 0 0 0 0 0

2008 23 ModifierButtons const * 0 8576 23 ModifierButtons const * 23 ModifierButtons const * 0 0 2009 0 0 0 0 0 0 0 0 0 0

2009 21 ModifierButtons const 0 8832 21 ModifierButtons const 21 ModifierButtons const 0 0 1832 0 0 0 0 0 0 0 0 0 0

2010 11 MouseData * 0 8576 11 MouseData * 11 MouseData * 0 0 1834 0 0 0 0 0 0 0 0 0 0

2011 17 MouseData const * 0 8576 17 MouseData const * 17 MouseData const * 0 0 2012 0 0 0 0 0 0 0 0 0 0

2012 15 MouseData const 0 8832 15 MouseData const 15 MouseData const 0 0 1834 0 0 0 0 0 0 0 0 0 0

2013 32 NodeCachedReferenceCount const * 0 8576 32 NodeCachedReferenceCount const * 32 NodeCachedReferenceCount const * 0 0 2014 0 0 0 0 0 0 0 0 0 0

2014 30 NodeCachedReferenceCount const 0 8832 30 NodeCachedReferenceCount const 30 NodeCachedReferenceCount const 0 0 1835 0 0 0 0 0 0 0 0 0 0

2015 13 SparseArray * 0 8576 13 SparseArray * 13 SparseArray * 0 0 1837 0 0 0 0 0 0 0 0 0 0

2016 22 ParamValueBase const * 0 8576 22 ParamValueBase const * 22 ParamValueBase const * 0 0 2017 0 0 0 0 0 0 0 0 0 0

2017 20 ParamValueBase const 0 8832 20 ParamValueBase const 20 ParamValueBase const 0 0 1838 0 0 0 0 0 0 0 0 0 0

2018 27 TypedReferenceCount const * 0 8576 27 TypedReferenceCount const * 27 TypedReferenceCount const * 0 0 2019 0 0 0 0 0 0 0 0 0 0

2019 25 TypedReferenceCount const 0 8832 25 TypedReferenceCount const 25 TypedReferenceCount const 0 0 1810 0 0 0 0 0 0 0 0 0 0

2020 20 ParamTypedRefCount * 0 8576 20 ParamTypedRefCount * 20 ParamTypedRefCount * 0 0 1839 0 0 0 0 0 0 0 0 0 0

2021 26 ParamTypedRefCount const * 0 8576 26 ParamTypedRefCount const * 26 ParamTypedRefCount const * 0 0 2022 0 0 0 0 0 0 0 0 0 0

2022 24 ParamTypedRefCount const 0 8832 24 ParamTypedRefCount const 24 ParamTypedRefCount const 0 0 1839 0 0 0 0 0 0 0 0 0 0

2023 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 1810 0 0 0 0 0 0 0 0 0 0

2024 22 ParamValue< string > * 0 8576 22 ParamValue< string > * 22 ParamValue< string > * 0 0 1840 0 0 0 0 0 0 0 0 0 0

2025 28 ParamValue< string > const * 0 8576 28 ParamValue< string > const * 28 ParamValue< string > const * 0 0 2026 0 0 0 0 0 0 0 0 0 0

2026 26 ParamValue< string > const 0 8832 26 ParamValue< string > const 26 ParamValue< string > const 0 0 1840 0 0 0 0 0 0 0 0 0 0

2027 23 ParamValue< wstring > * 0 8576 23 ParamValue< wstring > * 23 ParamValue< wstring > * 0 0 1842 0 0 0 0 0 0 0 0 0 0

2028 29 ParamValue< wstring > const * 0 8576 29 ParamValue< wstring > const * 29 ParamValue< wstring > const * 0 0 2029 0 0 0 0 0 0 0 0 0 0

2029 27 ParamValue< wstring > const 0 8832 27 ParamValue< wstring > const 27 ParamValue< wstring > const 0 0 1842 0 0 0 0 0 0 0 0 0 0

2030 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 2031 0 0 0 0 0 0 0 0 0 0

2031 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 2032 0 0 0 0 0 0 0 0 0 0

2032 10 LVecBase2d 0 2048 10 LVecBase2d 10 LVecBase2d 0 0 0 0 0 0 0 0 0 0 0 0 263
////////////////////////////////////////////////////////////////////
//       Class : LVecBase2
// Description : This is the base class for all two-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2033 26 ParamValue< LVecBase2d > * 0 8576 26 ParamValue< LVecBase2d > * 26 ParamValue< LVecBase2d > * 0 0 1844 0 0 0 0 0 0 0 0 0 0

2034 32 ParamValue< LVecBase2d > const * 0 8576 32 ParamValue< LVecBase2d > const * 32 ParamValue< LVecBase2d > const * 0 0 2035 0 0 0 0 0 0 0 0 0 0

2035 30 ParamValue< LVecBase2d > const 0 8832 30 ParamValue< LVecBase2d > const 30 ParamValue< LVecBase2d > const 0 0 1844 0 0 0 0 0 0 0 0 0 0

2036 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 2037 0 0 0 0 0 0 0 0 0 0

2037 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 2038 0 0 0 0 0 0 0 0 0 0

2038 10 LVecBase2f 0 2048 10 LVecBase2f 10 LVecBase2f 0 0 0 0 0 0 0 0 0 0 0 0 263
////////////////////////////////////////////////////////////////////
//       Class : LVecBase2
// Description : This is the base class for all two-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2039 26 ParamValue< LVecBase2f > * 0 8576 26 ParamValue< LVecBase2f > * 26 ParamValue< LVecBase2f > * 0 0 1846 0 0 0 0 0 0 0 0 0 0

2040 32 ParamValue< LVecBase2f > const * 0 8576 32 ParamValue< LVecBase2f > const * 32 ParamValue< LVecBase2f > const * 0 0 2041 0 0 0 0 0 0 0 0 0 0

2041 30 ParamValue< LVecBase2f > const 0 8832 30 ParamValue< LVecBase2f > const 30 ParamValue< LVecBase2f > const 0 0 1846 0 0 0 0 0 0 0 0 0 0

2042 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 2043 0 0 0 0 0 0 0 0 0 0

2043 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 2044 0 0 0 0 0 0 0 0 0 0

2044 10 LVecBase2i 0 2048 10 LVecBase2i 10 LVecBase2i 0 0 0 0 0 0 0 0 0 0 0 0 263
////////////////////////////////////////////////////////////////////
//       Class : LVecBase2
// Description : This is the base class for all two-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2045 26 ParamValue< LVecBase2i > * 0 8576 26 ParamValue< LVecBase2i > * 26 ParamValue< LVecBase2i > * 0 0 1848 0 0 0 0 0 0 0 0 0 0

2046 32 ParamValue< LVecBase2i > const * 0 8576 32 ParamValue< LVecBase2i > const * 32 ParamValue< LVecBase2i > const * 0 0 2047 0 0 0 0 0 0 0 0 0 0

2047 30 ParamValue< LVecBase2i > const 0 8832 30 ParamValue< LVecBase2i > const 30 ParamValue< LVecBase2i > const 0 0 1848 0 0 0 0 0 0 0 0 0 0

2048 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 2049 0 0 0 0 0 0 0 0 0 0

2049 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 2050 0 0 0 0 0 0 0 0 0 0

2050 10 LVecBase3d 0 2048 10 LVecBase3d 10 LVecBase3d 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase3
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2051 26 ParamValue< LVecBase3d > * 0 8576 26 ParamValue< LVecBase3d > * 26 ParamValue< LVecBase3d > * 0 0 1850 0 0 0 0 0 0 0 0 0 0

2052 32 ParamValue< LVecBase3d > const * 0 8576 32 ParamValue< LVecBase3d > const * 32 ParamValue< LVecBase3d > const * 0 0 2053 0 0 0 0 0 0 0 0 0 0

2053 30 ParamValue< LVecBase3d > const 0 8832 30 ParamValue< LVecBase3d > const 30 ParamValue< LVecBase3d > const 0 0 1850 0 0 0 0 0 0 0 0 0 0

2054 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 2055 0 0 0 0 0 0 0 0 0 0

2055 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 2056 0 0 0 0 0 0 0 0 0 0

2056 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase3
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2057 26 ParamValue< LVecBase3f > * 0 8576 26 ParamValue< LVecBase3f > * 26 ParamValue< LVecBase3f > * 0 0 1852 0 0 0 0 0 0 0 0 0 0

2058 32 ParamValue< LVecBase3f > const * 0 8576 32 ParamValue< LVecBase3f > const * 32 ParamValue< LVecBase3f > const * 0 0 2059 0 0 0 0 0 0 0 0 0 0

2059 30 ParamValue< LVecBase3f > const 0 8832 30 ParamValue< LVecBase3f > const 30 ParamValue< LVecBase3f > const 0 0 1852 0 0 0 0 0 0 0 0 0 0

2060 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 2061 0 0 0 0 0 0 0 0 0 0

2061 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 2062 0 0 0 0 0 0 0 0 0 0

2062 10 LVecBase3i 0 2048 10 LVecBase3i 10 LVecBase3i 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase3
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2063 26 ParamValue< LVecBase3i > * 0 8576 26 ParamValue< LVecBase3i > * 26 ParamValue< LVecBase3i > * 0 0 1854 0 0 0 0 0 0 0 0 0 0

2064 32 ParamValue< LVecBase3i > const * 0 8576 32 ParamValue< LVecBase3i > const * 32 ParamValue< LVecBase3i > const * 0 0 2065 0 0 0 0 0 0 0 0 0 0

2065 30 ParamValue< LVecBase3i > const 0 8832 30 ParamValue< LVecBase3i > const 30 ParamValue< LVecBase3i > const 0 0 1854 0 0 0 0 0 0 0 0 0 0

2066 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 2067 0 0 0 0 0 0 0 0 0 0

2067 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 2068 0 0 0 0 0 0 0 0 0 0

2068 10 LVecBase4d 0 2048 10 LVecBase4d 10 LVecBase4d 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase4
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2069 26 ParamValue< LVecBase4d > * 0 8576 26 ParamValue< LVecBase4d > * 26 ParamValue< LVecBase4d > * 0 0 1856 0 0 0 0 0 0 0 0 0 0

2070 32 ParamValue< LVecBase4d > const * 0 8576 32 ParamValue< LVecBase4d > const * 32 ParamValue< LVecBase4d > const * 0 0 2071 0 0 0 0 0 0 0 0 0 0

2071 30 ParamValue< LVecBase4d > const 0 8832 30 ParamValue< LVecBase4d > const 30 ParamValue< LVecBase4d > const 0 0 1856 0 0 0 0 0 0 0 0 0 0

2072 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 2073 0 0 0 0 0 0 0 0 0 0

2073 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 2074 0 0 0 0 0 0 0 0 0 0

2074 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase4
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2075 26 ParamValue< LVecBase4f > * 0 8576 26 ParamValue< LVecBase4f > * 26 ParamValue< LVecBase4f > * 0 0 1858 0 0 0 0 0 0 0 0 0 0

2076 32 ParamValue< LVecBase4f > const * 0 8576 32 ParamValue< LVecBase4f > const * 32 ParamValue< LVecBase4f > const * 0 0 2077 0 0 0 0 0 0 0 0 0 0

2077 30 ParamValue< LVecBase4f > const 0 8832 30 ParamValue< LVecBase4f > const 30 ParamValue< LVecBase4f > const 0 0 1858 0 0 0 0 0 0 0 0 0 0

2078 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 2079 0 0 0 0 0 0 0 0 0 0

2079 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 2080 0 0 0 0 0 0 0 0 0 0

2080 10 LVecBase4i 0 2048 10 LVecBase4i 10 LVecBase4i 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase4
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2081 26 ParamValue< LVecBase4i > * 0 8576 26 ParamValue< LVecBase4i > * 26 ParamValue< LVecBase4i > * 0 0 1860 0 0 0 0 0 0 0 0 0 0

2082 32 ParamValue< LVecBase4i > const * 0 8576 32 ParamValue< LVecBase4i > const * 32 ParamValue< LVecBase4i > const * 0 0 2083 0 0 0 0 0 0 0 0 0 0

2083 30 ParamValue< LVecBase4i > const 0 8832 30 ParamValue< LVecBase4i > const 30 ParamValue< LVecBase4i > const 0 0 1860 0 0 0 0 0 0 0 0 0 0

2084 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 2085 0 0 0 0 0 0 0 0 0 0

2085 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 2086 0 0 0 0 0 0 0 0 0 0

2086 9 LMatrix3d 0 2048 9 LMatrix3d 9 LMatrix3d 0 0 0 0 0 0 0 4 2121 2122 2123 2124 0 0 0 0 462
////////////////////////////////////////////////////////////////////
//       Class : LMatrix3
// Description : This is a 3-by-3 transform matrix.  It typically will
//               represent either a rotation-and-scale (no
//               translation) matrix in 3-d, or a full affine matrix
//               (rotation, scale, translation) in 2-d, e.g. for a
//               texture matrix.
////////////////////////////////////////////////////////////////////

2087 25 ParamValue< LMatrix3d > * 0 8576 25 ParamValue< LMatrix3d > * 25 ParamValue< LMatrix3d > * 0 0 1862 0 0 0 0 0 0 0 0 0 0

2088 31 ParamValue< LMatrix3d > const * 0 8576 31 ParamValue< LMatrix3d > const * 31 ParamValue< LMatrix3d > const * 0 0 2089 0 0 0 0 0 0 0 0 0 0

2089 29 ParamValue< LMatrix3d > const 0 8832 29 ParamValue< LMatrix3d > const 29 ParamValue< LMatrix3d > const 0 0 1862 0 0 0 0 0 0 0 0 0 0

2090 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 2091 0 0 0 0 0 0 0 0 0 0

2091 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 2092 0 0 0 0 0 0 0 0 0 0

2092 9 LMatrix3f 0 2048 9 LMatrix3f 9 LMatrix3f 0 0 0 0 0 0 0 4 2125 2126 2127 2128 0 0 0 0 462
////////////////////////////////////////////////////////////////////
//       Class : LMatrix3
// Description : This is a 3-by-3 transform matrix.  It typically will
//               represent either a rotation-and-scale (no
//               translation) matrix in 3-d, or a full affine matrix
//               (rotation, scale, translation) in 2-d, e.g. for a
//               texture matrix.
////////////////////////////////////////////////////////////////////

2093 25 ParamValue< LMatrix3f > * 0 8576 25 ParamValue< LMatrix3f > * 25 ParamValue< LMatrix3f > * 0 0 1864 0 0 0 0 0 0 0 0 0 0

2094 31 ParamValue< LMatrix3f > const * 0 8576 31 ParamValue< LMatrix3f > const * 31 ParamValue< LMatrix3f > const * 0 0 2095 0 0 0 0 0 0 0 0 0 0

2095 29 ParamValue< LMatrix3f > const 0 8832 29 ParamValue< LMatrix3f > const 29 ParamValue< LMatrix3f > const 0 0 1864 0 0 0 0 0 0 0 0 0 0

2096 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 2097 0 0 0 0 0 0 0 0 0 0

2097 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 2098 0 0 0 0 0 0 0 0 0 0

2098 9 LMatrix4d 0 2048 9 LMatrix4d 9 LMatrix4d 0 0 0 0 0 0 0 3 2129 2130 2131 0 0 0 0 215
////////////////////////////////////////////////////////////////////
//       Class : LMatrix4
// Description : This is a 4-by-4 transform matrix.
////////////////////////////////////////////////////////////////////

2099 25 ParamValue< LMatrix4d > * 0 8576 25 ParamValue< LMatrix4d > * 25 ParamValue< LMatrix4d > * 0 0 1866 0 0 0 0 0 0 0 0 0 0

2100 31 ParamValue< LMatrix4d > const * 0 8576 31 ParamValue< LMatrix4d > const * 31 ParamValue< LMatrix4d > const * 0 0 2101 0 0 0 0 0 0 0 0 0 0

2101 29 ParamValue< LMatrix4d > const 0 8832 29 ParamValue< LMatrix4d > const 29 ParamValue< LMatrix4d > const 0 0 1866 0 0 0 0 0 0 0 0 0 0

2102 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 2103 0 0 0 0 0 0 0 0 0 0

2103 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 2104 0 0 0 0 0 0 0 0 0 0

2104 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 3 2132 2133 2134 0 0 0 0 215
////////////////////////////////////////////////////////////////////
//       Class : LMatrix4
// Description : This is a 4-by-4 transform matrix.
////////////////////////////////////////////////////////////////////

2105 25 ParamValue< LMatrix4f > * 0 8576 25 ParamValue< LMatrix4f > * 25 ParamValue< LMatrix4f > * 0 0 1868 0 0 0 0 0 0 0 0 0 0

2106 31 ParamValue< LMatrix4f > const * 0 8576 31 ParamValue< LMatrix4f > const * 31 ParamValue< LMatrix4f > const * 0 0 2107 0 0 0 0 0 0 0 0 0 0

2107 29 ParamValue< LMatrix4f > const 0 8832 29 ParamValue< LMatrix4f > const 29 ParamValue< LMatrix4f > const 0 0 1868 0 0 0 0 0 0 0 0 0 0

2108 19 UniqueIdAllocator * 0 8576 19 UniqueIdAllocator * 19 UniqueIdAllocator * 0 0 1876 0 0 0 0 0 0 0 0 0 0

2109 25 UniqueIdAllocator const * 0 8576 25 UniqueIdAllocator const * 25 UniqueIdAllocator const * 0 0 2110 0 0 0 0 0 0 0 0 0 0

2110 23 UniqueIdAllocator const 0 8832 23 UniqueIdAllocator const 23 UniqueIdAllocator const 0 0 1876 0 0 0 0 0 0 0 0 0 0

2111 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 2112 0 0 0 0 0 0 0 0 0 0

2112 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

2113 26 ConfigVariableSearchPath * 0 8576 26 ConfigVariableSearchPath * 26 ConfigVariableSearchPath * 0 0 2114 0 0 0 0 0 0 0 0 0 0

2114 24 ConfigVariableSearchPath 0 2048 24 ConfigVariableSearchPath 24 ConfigVariableSearchPath 0 0 0 0 0 0 0 0 0 0 0 0 1125
////////////////////////////////////////////////////////////////////
//       Class : ConfigVariableSearchPath
// Description : This is similar to a ConfigVariableList, but it
//               returns its list as a DSearchPath, as a list of
//               directories.
//
//               You may locally append directories to the end of the
//               search path with the methods here, or prepend them to
//               the beginning.  Use these methods to make adjustments
//               to the path; do not attempt to directly modify the
//               const DSearchPath object returned by get_value().
//
//               Unlike other ConfigVariable types, local changes
//               (made by calling append_directory() and
//               prepend_directory()) are specific to this particular
//               instance of the ConfigVariableSearchPath.  A separate
//               instance of the same variable, created by using the
//               same name to the constructor, will not reflect the
//               local changes.
////////////////////////////////////////////////////////////////////

2115 12 ConfigPage * 0 8576 12 ConfigPage * 12 ConfigPage * 0 0 2116 0 0 0 0 0 0 0 0 0 0

2116 10 ConfigPage 0 2048 10 ConfigPage 10 ConfigPage 0 0 0 0 0 0 0 0 0 0 0 0 493
////////////////////////////////////////////////////////////////////
//       Class : ConfigPage
// Description : A page of ConfigDeclarations that may be loaded or
//               unloaded.  Typically this represents a single .prc
//               file that is read from disk at runtime, but it may
//               also represent a list of declarations built up
//               by application code and explicitly loaded.
////////////////////////////////////////////////////////////////////

2117 9 HashVal * 0 8576 9 HashVal * 9 HashVal * 0 0 2118 0 0 0 0 0 0 0 0 0 0

2118 7 HashVal 0 2048 7 HashVal 7 HashVal 0 0 0 0 0 0 0 0 0 0 0 0 0

0
1
2119 2 tv 0 6 1816 1382 1383 11 TimeVal::tv 0

15
2120 0 0 759 11 get_buttons 15 get_num_buttons 10 get_button 
2121 0 0 2055 8 get_rows 4 size 7 get_row 
2122 0 0 2055 8 get_cols 4 size 7 get_col 
2123 0 0 2055 9 get_col2s 4 size 8 get_col2 
2124 0 0 2055 9 get_row2s 4 size 8 get_row2 
2125 0 0 2065 8 get_rows 4 size 7 get_row 
2126 0 0 2065 8 get_cols 4 size 7 get_col 
2127 0 0 2065 9 get_col2s 4 size 8 get_col2 
2128 0 0 2065 9 get_row2s 4 size 8 get_row2 
2129 0 0 2075 8 get_rows 4 size 7 get_row 
2130 0 0 2075 8 get_cols 4 size 7 get_col 
2131 0 0 2075 9 get_row3s 4 size 8 get_row3 
2132 0 0 2085 8 get_rows 4 size 7 get_row 
2133 0 0 2085 8 get_cols 4 size 7 get_col 
2134 0 0 2085 9 get_row3s 4 size 8 get_row3 
